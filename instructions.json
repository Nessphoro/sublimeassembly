[
  {
    "Name": "AAA",
    "Brief": "ASCII Adjust After Addition",
    "Description": "\nAdjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.\n\nIf the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4 through 7 of the AL register are set to 0.\n\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.\n\nThe AF and CF flags are set to 1 if the adjustment results in a decimal carry; otherwise they are set to 0. The OF, SF, ZF, and PF flags are undefined.\n",
    "Alias": []
  },
  {
    "Name": "AAD",
    "Brief": "ASCII Adjust AX Before Division",
    "Description": "\nAdjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value.\n\nThe AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H. The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10) number in registers AH and AL.\n\nThe generalized version of this instruction allows adjustment of two unpacked digits of any number base, by setting the imm8 byte to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine code (D5 imm8).\n\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "AAM",
    "Brief": "ASCII Adjust AX After Multiply",
    "Description": "\nAdjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain the correct 2-digit unpacked (base 10) BCD result.\n\nThe generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked digits of any number base. Here, the imm8 byte is set to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the instruction must be hand coded in machine code (D4 imm8).\n\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.\n\nThe operation involves dividing the AL register by the immediate value (default 10 for AAM), setting AH to the quotient and AL to the remainder, effectively separating the digits of a two-digit BCD number.\n",
    "Alias": []
  },
  {
    "Name": "AAS",
    "Brief": "ASCII Adjust AL After Subtraction",
    "Description": "\nAdjusts the result of the subtraction of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.\n\nIf the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL register is left with its top four bits set to 0.\n\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "ADC",
    "Brief": "Add destination operand, source operand, and carry flag",
    "Description": "\nAdds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\n\nThe ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\n\nThe ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "ADCX",
    "Brief": "Unsigned Integer Addition of Two Operands With Carry Flag",
    "Description": "\nPerforms an unsigned addition of the destination operand (first operand), the source operand (second operand) and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.\n\nThe ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state. Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).\n\nThis instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.\n\nIn 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.\n\nADCX executes normally either inside or outside a transaction region.\n\nNote: ADCX defines the OF flag differently than the ADD/ADC instructions as defined in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 2A.\n",
    "Alias": []
  },
  {
    "Name": "ADD",
    "Brief": "Add the destination operand and the source operand and store the result in the destination operand",
    "Description": "\nAdds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\n\nThe ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "ADDPD",
    "Brief": "Add packed double precision floating-point values",
    "Description": "\nAdds two, four or eight packed double precision floating-point values from the first source operand to the second source operand, and stores the packed double precision floating-point result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "ADDPS",
    "Brief": "Add packed single precision floating-point values",
    "Description": "\nAdds four, eight or sixteen packed single precision floating-point values from the first source operand with the second source operand, and stores the packed single precision floating-point result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "ADDSD",
    "Brief": "Add low double precision floating-point values",
    "Description": "\nAdds the low double precision floating-point values from the second source operand and the first source operand and stores the double precision floating-point result in the destination operand.\n\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\n\nEVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX version: The low quadword element of the destination is updated according to the writemask.\n\nSoftware should ensure VADDSD is encoded with VEX.L=0. Encoding VADDSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "ADDSS",
    "Brief": "Add low single precision floating-point values",
    "Description": "\nAdds the low single precision floating-point values from the second source operand and the first source operand, and stores the double precision floating-point result in the destination operand.\n\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:32) of the corresponding the destination register remain unchanged.\n\nEVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX version: The low doubleword element of the destination is updated according to the writemask.\n\nSoftware should ensure VADDSS is encoded with VEX.L=0. Encoding VADDSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "ADDSUBPD",
    "Brief": "Packed Double Precision Floating-Point Add/Subtract",
    "Description": "\nAdds odd-numbered double precision floating-point values of the first source operand (second operand) with the corresponding double precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). \n\nSubtracts the even-numbered double precision floating-point values from the second source operand from the corresponding double precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\n128-bit Legacy SSE version: The second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\n\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n",
    "Alias": []
  },
  {
    "Name": "ADDSUBPS",
    "Brief": "Packed Single Precision Floating-Point Add/Subtract",
    "Description": "\nAdds odd-numbered single precision floating-point values of the first source operand (second operand) with the corresponding single precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered single precision floating-point values from the second source operand from the corresponding single precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\n\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n",
    "Alias": []
  },
  {
    "Name": "ADOX",
    "Brief": "Unsigned integer addition of two operands with overflow flag",
    "Description": "\nPerforms an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands.\n\nThe ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).\n\nThis instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.\n\nIn 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.\n\nADOX executes normally either inside or outside a transaction region.\n\nNote: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 2A.\n",
    "Alias": []
  },
  {
    "Name": "AESDEC",
    "Brief": "Perform one round of an AES decryption flow using the Equivalent Inverse Cipher",
    "Description": "\nThis instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher. It uses one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nUse the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDECLAST instruction.\n\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe decryption round involves the following steps:\n1. Inverse Shift Rows (InvShiftRows)\n2. Inverse Substitute Bytes (InvSubBytes)\n3. Inverse Mix Columns (InvMixColumns)\n4. XOR with the round key\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n",
    "Alias": []
  },
  {
    "Name": "VAESDEC",
    "Brief": "Perform one round of an AES decryption flow using the Equivalent Inverse Cipher with 3-operand operation",
    "Description": "\nThis instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher. It uses one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nUse the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDECLAST instruction.\n\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe decryption round involves the following steps:\n1. Inverse Shift Rows (InvShiftRows)\n2. Inverse Substitute Bytes (InvSubBytes)\n3. Inverse Mix Columns (InvMixColumns)\n4. XOR with the round key\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n",
    "Alias": []
  },
  {
    "Name": "AESDEC128KL",
    "Brief": "Perform Ten Rounds of AES Decryption Flow With Key Locker Using 128-Bit Key",
    "Description": "\nThe AESDEC128KL instruction performs 10 rounds of AES to decrypt the first operand using the 128-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).\n\nThe instruction works as follows:\n1. Load a 384-bit handle from the source memory location.\n2. Check if the handle is illegal based on several conditions:\n   - Reserved bits are set\n   - Handle is accessed at a privilege level > 0\n   - Specific handle bits are set\n   - Key type is not AES-128\n3. If the handle is illegal, set the Zero Flag (ZF) to 1.\n4. Otherwise, attempt to unwrap the key and authenticate it.\n5. If authentication fails, set the Zero Flag (ZF) to 1.\n6. If authentication succeeds, perform AES-128 decryption and set the Zero Flag (ZF) to 0.\n7. Clear other arithmetic flags (OF, SF, AF, PF, CF) to 0.\n\nThe instruction is part of the Key Locker (KL) feature and requires specific CPUID feature flags and control register settings to be used.\n",
    "Alias": []
  },
  {
    "Name": "AESDEC256KL",
    "Brief": "Perform 14 Rounds of AES Decryption Flow With Key Locker Using 256-Bit Key",
    "Description": "\nThe AESDEC256KL instruction performs 14 rounds of AES to decrypt the first operand using the 256-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).\n\nThe instruction performs the following key steps:\n1. Load a 512-bit handle from the source operand\n2. Check if the handle is legal (verifying reserved bits, privilege level, key type)\n3. If the handle is illegal, set the Zero Flag (ZF) to 1\n4. Otherwise, unwrap the key and authenticate it\n5. If authentication fails, set the Zero Flag (ZF) to 1\n6. If authentication succeeds, perform AES-256 decryption\n7. Set the Zero Flag (ZF) to 0 if the operation is successful\n\nThe instruction clears other arithmetic flags (OF, SF, AF, PF, CF) to 0.\n\nThis instruction is part of the Key Locker (KL) feature, which provides secure key management and cryptographic operations.\n",
    "Alias": []
  },
  {
    "Name": "AESDECLAST",
    "Brief": "Perform last round of an AES decryption flow using Equivalent Inverse Cipher",
    "Description": "\nThis instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe operation involves the following steps for each 128-bit block:\n1. Perform Inverse ShiftRows transformation\n2. Perform Inverse SubBytes transformation\n3. XOR the transformed state with the round key\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n\nSupported vector lengths:\n- 128-bit (1 block)\n- 256-bit (2 blocks)\n- 512-bit (4 blocks)\n",
    "Alias": []
  },
  {
    "Name": "VAESDECLAST",
    "Brief": "Perform last round of an AES decryption flow using Equivalent Inverse Cipher with vector support",
    "Description": "\nThis instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe operation involves the following steps for each 128-bit block:\n1. Perform Inverse ShiftRows transformation\n2. Perform Inverse SubBytes transformation\n3. XOR the transformed state with the round key\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n\nSupported vector lengths:\n- 128-bit (1 block)\n- 256-bit (2 blocks)\n- 512-bit (4 blocks)\n",
    "Alias": []
  },
  {
    "Name": "AESDECWIDE128KL",
    "Brief": "Perform ten rounds of AES decryption flow with Key Locker on 8 blocks using 128-bit key",
    "Description": "\nThe AESDECWIDE128KL instruction performs ten rounds of AES to decrypt each of the eight blocks in XMM0-7 using the 128-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding decrypted block if the operation succeeds (e.g., does not run into a handle violation failure).\n\nThe instruction works as follows:\n1. Load a 384-bit handle\n2. Check if the handle is legal (checking reserved bits, privilege level, key type)\n3. If the handle is illegal, set the Zero Flag (ZF) to 1\n4. Otherwise, unwrap the key and authenticate it\n5. If authentication fails, set the Zero Flag (ZF) to 1\n6. If authentication succeeds, decrypt each of the eight blocks in XMM0-7 using AES-128 decryption\n7. Set the Zero Flag (ZF) to 0 to indicate successful operation\n8. Clear other arithmetic flags (OF, SF, AF, PF, CF)\n\nThe instruction is part of the Intel Key Locker technology and requires specific CPUID feature flags and control register settings to be used.\n",
    "Alias": []
  },
  {
    "Name": "AESDECWIDE256KL",
    "Brief": "Perform 14 Rounds of AES Decryption Flow With Key Locker on 8 Blocks Using 256-Bit Key",
    "Description": "\nThe AESDECWIDE256KL instruction performs 14 rounds of AES to decrypt each of the eight blocks in XMM0-7 using the 256-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding decrypted block if the operation succeeds (e.g., does not run into a handle violation failure).\n\nThe instruction operates as follows:\n1. Load a 512-bit handle from the source memory location\n2. Check for illegal handle conditions (reserved bits, privilege level, key type)\n3. If the handle is legal, attempt to unwrap and authenticate the key\n4. If key authentication succeeds, perform AES-256 decryption on each of the eight XMM registers (XMM0-7)\n5. Set the Zero Flag (ZF) to indicate success (0) or failure (1)\n\nThe operation clears other arithmetic flags (OF, SF, AF, PF, CF) to 0.\n",
    "Alias": []
  },
  {
    "Name": "AESENC",
    "Brief": "Perform one round of an AES encryption flow",
    "Description": "\nThis instruction performs a single round of an AES encryption flow using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nUse the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENCCLAST instruction.\n\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe encryption round consists of the following steps:\n1. ShiftRows: Rearrange the bytes in the state\n2. SubBytes: Perform a byte substitution using a fixed substitution table\n3. MixColumns: Mix the data within each column\n4. XOR the modified state with the round key\n\nThe instruction supports different vector lengths:\n- 128-bit (XMM): One 128-bit state and round key\n- 256-bit (YMM): Two 128-bit states and round keys\n- 512-bit (ZMM): Four 128-bit states and round keys\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n",
    "Alias": []
  },
  {
    "Name": "VAESENC",
    "Brief": "Perform one round of an AES encryption flow with vector instructions",
    "Description": "\nThis instruction performs a single round of an AES encryption flow using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nUse the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENCCLAST instruction.\n\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe encryption round consists of the following steps:\n1. ShiftRows: Rearrange the bytes in the state\n2. SubBytes: Perform a byte substitution using a fixed substitution table\n3. MixColumns: Mix the data within each column\n4. XOR the modified state with the round key\n\nThe instruction supports different vector lengths:\n- 128-bit (XMM): One 128-bit state and round key\n- 256-bit (YMM): Two 128-bit states and round keys\n- 512-bit (ZMM): Four 128-bit states and round keys\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n",
    "Alias": []
  },
  {
    "Name": "AESENC128KL",
    "Brief": "Perform ten rounds of AES encryption with a 128-bit key using Key Locker",
    "Description": "\nThe AESENC128KL instruction performs ten rounds of AES to encrypt the first operand using the 128-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).\n\nThe instruction follows these key steps:\n1. Load a 384-bit handle\n2. Check for handle illegality (reserved bits, privilege level, key type)\n3. If handle is legal, unwrap the key and authenticate it\n4. If authentication succeeds, perform AES-128 encryption\n5. Set the Zero Flag (ZF) to indicate success or failure\n\nThe instruction is part of the Intel Key Locker (KL) technology, which provides secure key management and encryption capabilities. It requires specific CPUID feature flags and control register settings to be supported.\n\nFlags are affected as follows:\n- ZF is set to 0 if the operation succeeded\n- ZF is set to 1 if the operation failed due to a handle violation\n- Other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0\n",
    "Alias": []
  },
  {
    "Name": "AESENC256KL",
    "Brief": "Perform 14 Rounds of AES Encryption Flow With Key Locker Using 256-Bit Key",
    "Description": "\nThe AESENC256KL instruction performs 14 rounds of AES to encrypt the first operand using the 256-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).\n\nThe instruction first loads a 512-bit handle and checks for illegal handle conditions, such as:\n- Reserved bits set\n- Handle accessed at privilege level > 0\n- Incorrect key type (must be AES256)\n\nIf the handle is valid, the instruction:\n1. Unwraps the key and authenticates it\n2. If authentication is successful, performs AES256 encryption\n3. Sets the Zero Flag (ZF) to 0 on success, or 1 on failure\n\nThe other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.\n\nThis instruction is part of the Intel Key Locker (KL) technology, which provides secure key management and encryption capabilities.\n",
    "Alias": []
  },
  {
    "Name": "AESENCLAST",
    "Brief": "Perform the last round of an AES encryption flow",
    "Description": "\nThis instruction performs the last round of an AES encryption flow using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n\nThe instruction performs the following steps:\n1. Shift the rows of the state\n2. Substitute bytes\n3. XOR the state with the round key\n\nSupported vector lengths are 128-bit (1 state/key), 256-bit (2 states/keys), and 512-bit (4 states/keys).\n",
    "Alias": []
  },
  {
    "Name": "AESENCWIDE128KL",
    "Brief": "Perform ten rounds of AES encryption on 8 blocks using a 128-bit key with Key Locker",
    "Description": "\nThe AESENCWIDE128KL instruction performs ten rounds of AES to encrypt each of the eight blocks in XMM0-7 using the 128-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding encrypted block if the operation succeeds (e.g., does not run into a handle violation failure).\n\nThe instruction involves several key steps:\n1. Load a 384-bit handle\n2. Check for handle validity (including reserved bits, privilege level, and key type)\n3. Unwrap the key and authenticate it\n4. If authentication succeeds, perform AES-128 encryption on each of the eight XMM registers\n5. Set the Zero Flag (ZF) to indicate success or failure of the operation\n\nThe instruction is part of the Intel Key Locker (KL) technology, which provides secure key management and encryption capabilities.\n",
    "Alias": []
  },
  {
    "Name": "AESENCWIDE256KL",
    "Brief": "Perform 14 Rounds of AES Encryption Flow With Key Locker on 8 Blocks Using 256-Bit Key",
    "Description": "\nThe AESENCWIDE256KL instruction performs 14 rounds of AES to encrypt each of the eight blocks in XMM0-7 using the 256-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding encrypted block if the operation succeeds (e.g., does not run into a handle violation failure).\n\nThe instruction follows these key steps:\n1. Load a 512-bit handle\n2. Check for handle validity (checking reserved bits, privilege level, key type)\n3. If the handle is valid, unwrap the key and authenticate it\n4. If authentication succeeds, encrypt each of the eight XMM registers (XMM0-7) using the 256-bit AES key\n5. Set the Zero Flag (ZF) to indicate success (0) or failure (1)\n\nThe operation clears other arithmetic flags (OF, SF, AF, PF, CF) to 0.\n\nThis instruction is part of the Intel Key Locker (KL) technology, which provides secure key management and encryption capabilities.\n",
    "Alias": []
  },
  {
    "Name": "AESIMC",
    "Brief": "Perform the AES InvMixColumn Transformation on a 128-bit round key",
    "Description": "\nPerform the InvMixColumns transformation on the source operand and store the result in the destination operand. The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.\n\nNote: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round key) in order to prepare them for decryption using the \"Equivalent Inverse Cipher\" (defined in FIPS 197).\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VAESIMC",
    "Brief": "Perform the AES InvMixColumn Transformation on a 128-bit round key (VEX-encoded version)",
    "Description": "\nPerform the InvMixColumns transformation on the source operand and store the result in the destination operand. The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.\n\nNote: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round key) in order to prepare them for decryption using the \"Equivalent Inverse Cipher\" (defined in FIPS 197).\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "AESKEYGENASSIST",
    "Brief": "Assist in AES round key generation using 8-bit Round Constant (RCON)",
    "Description": "\nAssist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using 128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the result in the destination operand.\n\nThe destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nThe instruction performs the following operations:\n1. Breaks the source operand into 4 32-bit words\n2. Applies SubWord and RotWord transformations\n3. XORs the transformations with the zero-extended round constant\n4. Stores the result in the destination operand\n",
    "Alias": []
  },
  {
    "Name": "AND",
    "Brief": "Performs a bitwise AND operation on the destination and source operands",
    "Description": "\nPerforms a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\n\nThis instruction can be used with a LOCK prefix to allow it to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe AND instruction affects the following flags:\n- OF and CF flags are cleared\n- SF, ZF, and PF flags are set according to the result\n- AF flag state is undefined\n",
    "Alias": []
  },
  {
    "Name": "ANDN",
    "Brief": "Bitwise logical AND of inverted second operand with third operand",
    "Description": "\nPerforms a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the second source operand). The result is stored in the first operand (destination operand).\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nThe instruction works as follows:\n- DEST := (NOT SRC1) bitwiseAND SRC2\n- SF is set based on the most significant bit of the result\n- ZF is set if the result is zero\n- OF and CF flags are cleared\n- AF and PF flags are undefined\n",
    "Alias": []
  },
  {
    "Name": "ANDNPD",
    "Brief": "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms a bitwise logical AND NOT of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VANDNPD",
    "Brief": "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms a bitwise logical AND NOT of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "ANDNPS",
    "Brief": "Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values",
    "Description": "\nPerforms a bitwise logical AND NOT of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VANDNPS",
    "Brief": "Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values in AVX and AVX-512 variants",
    "Description": "\nPerforms a bitwise logical AND NOT of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "ANDPD",
    "Brief": "Bitwise Logical AND of Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms a bitwise logical AND of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "ANDPS",
    "Brief": "Bitwise Logical AND of Packed Single Precision Floating-Point Values",
    "Description": "\nPerforms a bitwise logical AND of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VANDPS",
    "Brief": "Bitwise Logical AND of Packed Single Precision Floating-Point Values (with VEX/EVEX encoding)",
    "Description": "\nPerforms a bitwise logical AND of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "ARPL",
    "Brief": "Adjust RPL Field of Segment Selector",
    "Description": "\nCompares the RPL (Requested Privilege Level) fields of two segment selectors. The first operand (the destination operand) contains one segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0 and 1 of each operand.)\n\nIf the RPL field of the destination operand is less than the RPL field of the source operand, the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand. Otherwise, the ZF flag is cleared and no change is made to the destination operand.\n\nThe ARPL instruction is primarily used by operating-system procedures to adjust the RPL of a segment selector passed to the operating system by an application program to match the privilege level of the application program. This ensures that the RPL of the segment selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of the application program.\n\nThis instruction executes in compatibility mode and legacy mode, but is not encodable in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "BEXTR",
    "Brief": "Extracts contiguous bits from a source operand using an index and length value",
    "Description": "\nExtracts contiguous bits from the first source operand (the second operand) using an index value and length value specified in the second source operand (the third operand). \n\nBit 7:0 of the second source operand specifies the starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the second source operand. \n\nBit 15:8 of the second source operand specifies the maximum number of bits (LENGTH) beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are extracted. \n\nThe extracted bits are written to the destination register, starting from the least significant bit. All higher order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is cleared if no bits are extracted.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n",
    "Alias": []
  },
  {
    "Name": "BLENDPD",
    "Brief": "Blend packed double precision floating-point values",
    "Description": "\nDouble-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [3:0] determine whether the corresponding double precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is \"1\", then the double precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\n\nVEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n",
    "Alias": []
  },
  {
    "Name": "VBLENDPD",
    "Brief": "Vector blend packed double precision floating-point values",
    "Description": "\nDouble-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [3:0] determine whether the corresponding double precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is \"1\", then the double precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\n\nVEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n",
    "Alias": []
  },
  {
    "Name": "BLENDPS",
    "Brief": "Blend packed single precision floating-point values from two sources based on an immediate mask",
    "Description": "\nPacked single precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is \"1\", then the single precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.\n\n128-bit Legacy SSE version: The second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n",
    "Alias": []
  },
  {
    "Name": "BLENDVPD",
    "Brief": "Variable blend packed double precision floating-point values using XMM0 as mask",
    "Description": "\nConditionally copy each quadword data element of double precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register.\n\nEach quadword element of the destination operand is copied from:\n- the corresponding quadword element in the second source operand, if a mask bit is \"1\"\n- the corresponding quadword element in the first source operand, if a mask bit is \"0\"\n\nThe register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register XMM0.\n\nThe 128-bit Legacy SSE version uses XMM0 implicitly as the mask and does not support non-destructive destination operation. The VEX-encoded versions (VBLENDVPD) allow the mask to be any XMM or YMM register and support more flexible blending operations.\n\nIn the VEX.128 and VEX.256 encoded versions, the mask operand is the third source register, encoded in bits[7:4] of the immediate byte(imm8). VEX.W must be 0, otherwise the instruction will cause an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VBLENDVPD",
    "Brief": "Variable blend packed double precision floating-point values with flexible mask register",
    "Description": "\nConditionally copy each quadword data element of double precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register.\n\nEach quadword element of the destination operand is copied from:\n- the corresponding quadword element in the second source operand, if a mask bit is \"1\"\n- the corresponding quadword element in the first source operand, if a mask bit is \"0\"\n\nThe register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register XMM0.\n\nThe 128-bit Legacy SSE version uses XMM0 implicitly as the mask and does not support non-destructive destination operation. The VEX-encoded versions (VBLENDVPD) allow the mask to be any XMM or YMM register and support more flexible blending operations.\n\nIn the VEX.128 and VEX.256 encoded versions, the mask operand is the third source register, encoded in bits[7:4] of the immediate byte(imm8). VEX.W must be 0, otherwise the instruction will cause an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "BLENDVPS",
    "Brief": "Variable blend packed single precision floating-point values",
    "Description": "\nConditionally copy each dword data element of single precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register.\n\nEach quadword element of the destination operand is copied from:\n- the corresponding dword element in the second source operand, if a mask bit is \"1\"\n- the corresponding dword element in the first source operand, if a mask bit is \"0\"\n\nThe register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register XMM0.\n\n128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0.\n\nVEX.128 and VEX.256 encoded versions support more flexible masking, allowing the mask to be any XMM or YMM register. The mask is encoded in bits[7:4] of the immediate byte.\n\nVBLENDVPS permits the mask to be any XMM or YMM register, in contrast to BLENDVPS which treats XMM0 implicitly as the mask and does not support non-destructive destination operation.\n",
    "Alias": []
  },
  {
    "Name": "VBLENDVPS",
    "Brief": "Conditionally copy single precision floating-point values with mask",
    "Description": "\nConditionally copy each dword data element of single precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register.\n\nEach quadword element of the destination operand is copied from:\n- the corresponding dword element in the second source operand, if a mask bit is \"1\"\n- the corresponding dword element in the first source operand, if a mask bit is \"0\"\n\nThe register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register XMM0.\n\n128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0.\n\nVEX.128 and VEX.256 encoded versions support more flexible masking, allowing the mask to be any XMM or YMM register. The mask is encoded in bits[7:4] of the immediate byte.\n\nVBLENDVPS permits the mask to be any XMM or YMM register, in contrast to BLENDVPS which treats XMM0 implicitly as the mask and does not support non-destructive destination operation.\n",
    "Alias": []
  },
  {
    "Name": "BLSI",
    "Brief": "Extract lowest set bit from source operand and set the corresponding bit in the destination register",
    "Description": "\nExtracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in the destination to 0 and sets ZF and CF.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nThe operation involves:\n1. Computing the two's complement of the source and performing a bitwise AND with the original source\n2. Setting the destination to this result\n3. Updating status flags (ZF, SF, CF) based on the result\n",
    "Alias": []
  },
  {
    "Name": "BLSMSK",
    "Brief": "Set all lower bits to '1' up to the lowest set bit in the source operand",
    "Description": "\nSets all the lower bits of the destination operand to \"1\" up to and including lowest set bit (=1) in the source operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nThe instruction performs the following operation:\n1. Compute temp = (SRC-1) XOR (SRC)\n2. Set SF based on the result\n3. Clear ZF\n4. If SRC is zero, set CF to 1; otherwise, set CF to 0\n5. Set DEST to temp\n\nFlags are affected as follows:\n- SF is updated based on the result\n- CF is set if the source is zero\n- ZF and OF flags are cleared\n- AF and PF flags are undefined\n",
    "Alias": []
  },
  {
    "Name": "BLSR",
    "Brief": "Reset lowest set bit of source operand",
    "Description": "\nCopies all bits from the source operand to the destination operand and resets (=0) the bit position in the destination operand that corresponds to the lowest set bit of the source operand. If the source operand is zero, BLSR sets CF.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode, operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nThe operation works as follows:\n1. Create a temporary value by performing (SRC-1) bitwise AND with SRC\n2. Set SF flag based on the most significant bit of the temporary value\n3. Set ZF flag if the temporary value is zero\n4. Set CF if the source is zero\n5. Write the temporary value to the destination\n\nFlags affected:\n- ZF and SF flags are updated based on the result\n- CF is set if the source is zero\n- OF flag is cleared\n- AF and PF flags are undefined\n",
    "Alias": []
  },
  {
    "Name": "BNDCL",
    "Brief": "Check Lower Bound",
    "Description": "\nCompare the address in the second operand with the lower bound in bnd. The second operand can be either a register or memory operand. If the address is lower than the lower bound in bnd.LB, it will set BNDSTATUS to 01H and signal a #BR exception.\n\nThis instruction is part of the Memory Protection Extensions (MPX) and does not cause any memory access, and does not read or write any flags. It is used to perform bounds checking on memory addresses.\n\nWhen used with a register operand, the instruction checks if the register value is lower than the lower bound of the specified bound register (bnd). When used with a memory operand, the instruction first calculates the effective address of the memory operand using LEA (Load Effective Address) and then compares it with the lower bound.\n\nIf the address is lower than the lower bound, the instruction sets the BNDSTATUS register to 01H and raises a #BR (Bounds Range) exception.\n",
    "Alias": []
  },
  {
    "Name": "BNDCU",
    "Brief": "Check Upper Bound with 1's complement",
    "Description": "\nCompare the address in the second operand with the upper bound in bnd. The second operand can be either a register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to 01H and signal a #BR exception.\n\nBNDCU performs 1's complement operation on the upper bound of bnd first before proceeding with address comparison. BNDCN performs address comparison directly using the upper bound in bnd that is already reverted out of 1's complement form.\n\nThis instruction does not cause any memory access, and does not read or write any flags.\n\nEffective address computation of m32/64 has identical behavior to LEA. The instructions are part of the Memory Protection Extensions (MPX) feature set.\n\nIf the address in the second operand is higher than the upper bound:\n1. BNDSTATUS is set to 01H\n2. A #BR (Bound Range) exception is generated\n\nThe key difference between BNDCU and BNDCN is the handling of the upper bound:\n- BNDCU: Applies 1's complement to the upper bound before comparison\n- BNDCN: Uses the upper bound directly without 1's complement\n",
    "Alias": []
  },
  {
    "Name": "BNDCN",
    "Brief": "Check Upper Bound without 1's complement",
    "Description": "\nCompare the address in the second operand with the upper bound in bnd. The second operand can be either a register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to 01H and signal a #BR exception.\n\nBNDCU performs 1's complement operation on the upper bound of bnd first before proceeding with address comparison. BNDCN performs address comparison directly using the upper bound in bnd that is already reverted out of 1's complement form.\n\nThis instruction does not cause any memory access, and does not read or write any flags.\n\nEffective address computation of m32/64 has identical behavior to LEA. The instructions are part of the Memory Protection Extensions (MPX) feature set.\n\nIf the address in the second operand is higher than the upper bound:\n1. BNDSTATUS is set to 01H\n2. A #BR (Bound Range) exception is generated\n\nThe key difference between BNDCU and BNDCN is the handling of the upper bound:\n- BNDCU: Applies 1's complement to the upper bound before comparison\n- BNDCN: Uses the upper bound directly without 1's complement\n",
    "Alias": []
  },
  {
    "Name": "BNDLDX",
    "Brief": "Load Extended Bounds Using Address Translation",
    "Description": "\nBNDLDX uses the linear address constructed from the base register and displacement of the SIB-addressing form of the memory operand (mib) to perform address translation to access a bound table entry and conditionally load the bounds in the BTE to the destination.\n\nThe destination register is updated with the bounds in the BTE, if the content of the index register of mib matches the pointer value stored in the BTE. If the pointer value comparison fails, the destination is updated with INIT bounds (lb = 0x0, ub = 0x0).\n\nKey characteristics of the instruction:\n- Does not cause memory access to the linear address of mib or the effective address referenced by the base\n- Does not read or write any flags\n- Segment overrides apply to the linear address computation with the base of mib\n- Base of mib is not checked for canonical address violation\n- Scale field of the SIB byte is ignored\n- Bound register may be partially updated on memory faults\n\nThe instruction supports both 32-bit and 64-bit modes, with slight variations in address translation and memory access mechanisms between the two modes.\n",
    "Alias": []
  },
  {
    "Name": "BNDMK",
    "Brief": "Make bounds from a memory operand and store them in a bound register",
    "Description": "\nMakes bounds from the second operand and stores the lower and upper bounds in the bound register bnd. The second operand must be a memory operand. The content of the base register from the memory operand is stored in the lower bound bnd.LB. The 1's complement of the effective address of m32/m64 is stored in the upper bound b.UB. Computation of m32/m64 has identical behavior to LEA.\n\nThis instruction does not cause any memory access, and does not read or write any flags.\n\nIf the instruction did not specify a base register, the lower bound will be zero. The reg-reg form of this instruction retains legacy behavior (NOP).\n\nThe instruction causes an invalid-opcode exception (#UD) if executed in 64-bit mode with RIP-relative addressing.\n",
    "Alias": []
  },
  {
    "Name": "BNDMOV",
    "Brief": "Move bounds register to/from memory or between bounds registers",
    "Description": "\nBNDMOV moves a pair of lower and upper bound values from the source operand (the second operand) to the destination (the first operand). Each operation is a 128-bit move. The exceptions are the same as the MOV instruction.\n\nWhen moving from memory:\n- In 64-bit mode: \n  * Lower bound (LB) is loaded from the first 64 bits\n  * Upper bound (UB) is loaded from the next 64 bits\n- In 32-bit mode:\n  * Lower bound (LB) is loaded from the first 32 bits, zero-extended\n  * Upper bound (UB) is loaded from the next 32 bits, zero-extended\n\nWhen moving to memory:\n- In 64-bit mode:\n  * Lower bound is stored in the first 64 bits\n  * Upper bound is stored in the next 64 bits\n- In 32-bit mode:\n  * Lower bound is stored in the first 32 bits\n  * Upper bound is stored in the next 32 bits\n\nThis instruction is part of the Memory Protection Extensions (MPX) and does not change any flags.\n",
    "Alias": []
  },
  {
    "Name": "BNDSTX",
    "Brief": "Store Extended Bounds Using Address Translation",
    "Description": "\nBNDSTX uses the linear address constructed from the displacement and base register of the SIB-addressing form of the memory operand (mib) to perform address translation to store to a bound table entry. The bounds in the source operand bnd are written to the lower and upper bounds in the BTE. The content of the index register of mib is written to the pointer value field in the BTE.\n\nThis instruction does not cause memory access to the linear address of mib nor the effective address referenced by the base, and does not read or write any flags.\n\nSegment overrides apply to the linear address computation with the base of mib, and are used during address translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be linear address. There are no segmentation checks performed on the base of mib.\n\nThe base of mib will not be checked for canonical address violation as it does not access memory.\n\nAny encoding of this instruction that does not specify base or index register will treat those registers as zero (constant). The reg-reg form of this instruction will remain a NOP.\n\nThe scale field of the SIB byte has no effect on these instructions and is ignored.\n\nThe bound register may be partially updated on memory faults. The order in which memory operands are loaded is implementation specific.\n",
    "Alias": []
  },
  {
    "Name": "BOUND",
    "Brief": "Check if an array index is within specified bounds",
    "Description": "\nBOUND determines if the first operand (array index) is within the bounds of an array specified by the second operand (bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory location that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed word-integers (when the operand-size attribute is 16).\n\nThe first doubleword (or word) is the lower bound of the array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index is not within bounds, a BOUND range exceeded exception (#BR) is signaled.\n\nThe bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of the array.\n\nThis instruction executes in compatibility mode and legacy mode. It is not valid in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "BSF",
    "Brief": "Bit Scan Forward",
    "Description": "\nSearches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content of the source operand is 0, the content of the destination operand is undefined.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe instruction sets the ZF flag to 1 if the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF flags are undefined.\n",
    "Alias": []
  },
  {
    "Name": "BSR",
    "Brief": "Bit Scan Reverse searches the source operand for the most significant set bit",
    "Description": "\nSearches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe instruction sets the ZF flag to 1 if the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF flags are undefined.\n",
    "Alias": []
  },
  {
    "Name": "BSWAP",
    "Brief": "Reverses the byte order of a 32-bit or 64-bit register",
    "Description": "\nReverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting little-endian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe BSWAP instruction is not supported on IA-32 processors earlier than the Intel486™ processor family. For compatibility with this instruction, software should include functionally equivalent code for execution on Intel processors earlier than the Intel486 processor family.\n",
    "Alias": []
  },
  {
    "Name": "BT",
    "Brief": "Bit Test - Store selected bit in CF flag",
    "Description": "\nSelects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:\n\n- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode).\n\n- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be referenced by the offset operand depends on the operand size.\n\nWhen accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit operand size, or 2 bytes starting from the memory address for a 16-bit operand, even when only a single byte needs to be accessed to reach the given bit.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands.\n",
    "Alias": []
  },
  {
    "Name": "BTC",
    "Brief": "Bit Test and Complement",
    "Description": "\nSelects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:\n\n- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode). This allows any bit position to be selected.\n\n- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be referenced by the offset operand depends on the operand size.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe operation of the instruction is to store the selected bit's value in the CF flag and then complement the selected bit.\n",
    "Alias": []
  },
  {
    "Name": "BTR",
    "Brief": "Bit Test and Reset",
    "Description": "\nSelects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:\n\n- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode). This allows any bit position to be selected.\n\n- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be referenced by the offset operand depends on the operand size.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "BTS",
    "Brief": "Bit Test and Set",
    "Description": "\nSelects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:\n\n- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode). This allows any bit position to be selected.\n\n- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be referenced by the offset operand depends on the operand size.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "BZHI",
    "Brief": "Zero high bits starting with specified bit position",
    "Description": "\nBZHI copies the bits of the first source operand (the second operand) into the destination operand (the first operand) and clears the higher bits in the destination according to the INDEX value specified by the second source operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand is greater than OperandSize -1.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nThe instruction has two variants:\n1. 32-bit version: VEX.LZ.0F38.W0 F5 /r BZHI r32a, r/m32, r32b\n2. 64-bit version: VEX.LZ.0F38.W1 F5 /r BZHI r64a, r/m64, r64b\n\nFlags affected:\n- ZF and SF flags are updated based on the result\n- CF flag is set if the index is greater than OperandSize - 1\n- OF flag is cleared\n- AF and PF flags are undefined\n",
    "Alias": []
  },
  {
    "Name": "CALL",
    "Brief": "Call Procedure",
    "Description": "\nSaves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an immediate value, a general-purpose register, or a memory location.\n\nThis instruction can be used to execute four types of calls:\n1. Near Call: A call to a procedure in the current code segment.\n2. Far Call: A call to a procedure located in a different segment than the current code segment.\n3. Inter-privilege-level far call: A far call to a procedure in a segment at a different privilege level.\n4. Task switch: A call to a procedure located in a different task.\n\nThe latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode.\n\nNear Call Operation:\n- Pushes the return address (next instruction's address) onto the stack\n- Branches to the specified address in the current code segment\n- The target operand can be an absolute or relative offset\n- In 64-bit mode, the operand size is always 64 bits\n\nFar Call Operation:\n- Supports calls in real-address, virtual-8086, protected, and 64-bit modes\n- Pushes current CS and EIP/RIP onto the stack\n- Can invoke calls at the same or different privilege levels\n- Can use call gates for inter-segment and inter-privilege-level calls\n- Supports task switches (in protected mode)\n\nThe specific behavior varies depending on the processor mode (real, protected, compatibility, or 64-bit) and the type of call being performed.\n",
    "Alias": []
  },
  {
    "Name": "CBW",
    "Brief": "Convert byte to word by sign extension",
    "Description": "\nDouble the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.\n\nCBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.\n\nIn 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX.\n",
    "Alias": []
  },
  {
    "Name": "CWDE",
    "Brief": "Convert word to doubleword by sign extension",
    "Description": "\nDouble the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.\n\nCBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.\n\nIn 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX.\n",
    "Alias": []
  },
  {
    "Name": "CDQE",
    "Brief": "Convert doubleword to quadword by sign extension",
    "Description": "\nDouble the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.\n\nCBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.\n\nIn 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX.\n",
    "Alias": []
  },
  {
    "Name": "CWD",
    "Brief": "Sign-extend AX to DX:AX",
    "Description": "\nDoubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively.\n\nThe CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruction (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.\n\nThese instructions are typically used to prepare for signed division operations:\n- CWD can be used to produce a doubleword dividend from a word before word division\n- CDQ can be used to produce a quadword dividend from a doubleword before doubleword division\n- CQO can be used to produce a double quadword dividend from a quadword before quadword division\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ.\n",
    "Alias": []
  },
  {
    "Name": "CDQ",
    "Brief": "Sign-extend EAX to EDX:EAX",
    "Description": "\nDoubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively.\n\nThe CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruction (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.\n\nThese instructions are typically used to prepare for signed division operations:\n- CWD can be used to produce a doubleword dividend from a word before word division\n- CDQ can be used to produce a quadword dividend from a doubleword before doubleword division\n- CQO can be used to produce a double quadword dividend from a quadword before quadword division\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ.\n",
    "Alias": []
  },
  {
    "Name": "CQO",
    "Brief": "Sign-extend RAX to RDX:RAX",
    "Description": "\nDoubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively.\n\nThe CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruction (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.\n\nThese instructions are typically used to prepare for signed division operations:\n- CWD can be used to produce a doubleword dividend from a word before word division\n- CDQ can be used to produce a quadword dividend from a doubleword before doubleword division\n- CQO can be used to produce a double quadword dividend from a quadword before quadword division\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ.\n",
    "Alias": []
  },
  {
    "Name": "CLAC",
    "Brief": "Clear AC Flag in EFLAGS Register",
    "Description": "\nClears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute CLAC when CPL > 0 cause #UD.\n\nKey characteristics:\n- Clears the AC (Alignment Check) flag in the EFLAGS register\n- Requires CPL (Current Privilege Level) to be 0\n- Requires SMAP (Supervisor Mode Access Prevention) feature to be supported\n- Generates an Undefined Instruction (#UD) exception if:\n  1. LOCK prefix is used\n  2. CPL > 0\n  3. SMAP feature is not supported\n",
    "Alias": []
  },
  {
    "Name": "CLC",
    "Brief": "Clear Carry Flag",
    "Description": "\nClears the CF (Carry Flag) flag in the EFLAGS register. The operation is the same in all modes.\n\nWhen executed, the instruction sets the Carry Flag (CF) to 0, while leaving other flags (OF, ZF, SF, AF, and PF) unaffected.\n",
    "Alias": []
  },
  {
    "Name": "CLD",
    "Brief": "Clear Direction Flag",
    "Description": "\nClears the DF (Direction) flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI). \n\nThe operation is the same in all modes. Clearing the DF flag means that subsequent string operations (such as MOVS, SCAS, STOS) will automatically increment the source (ESI) and/or destination (EDI) index registers after each operation, moving from lower to higher memory addresses.\n\nThis instruction affects only the Direction Flag (DF). Other flags like Carry Flag (CF), Overflow Flag (OF), Zero Flag (ZF), Sign Flag (SF), Auxiliary Carry Flag (AF), and Parity Flag (PF) remain unaffected.\n",
    "Alias": []
  },
  {
    "Name": "CLDEMOTE",
    "Brief": "Hint to hardware to move the cache line to a more distant level of the cache",
    "Description": "\nHints to hardware that the cache line that contains the linear address specified with the memory operand should be moved (\"demoted\") from the cache(s) closest to the processor core to a level more distant from the processor core. This may accelerate subsequent accesses to the line by other cores in the same coherence domain, especially if the line was written by the core that demotes the line.\n\nMoving the line in such a manner is a performance optimization, i.e., it is a hint which does not modify architectural state. Hardware may choose which level in the cache hierarchy to retain the line (e.g., L3 in typical server designs). The source operand is a byte memory location.\n\nKey characteristics of CLDEMOTE:\n- Availability is indicated by the CPUID feature flag CLDEMOTE\n- Treated as a NOP on processors that do not support it\n- Ordered with respect to stores to the same cache line\n- Not guaranteed to write back modified data to memory\n- Can be used at all privilege levels\n- May be ignored by hardware in certain cases\n- If the line is not found in the cache, it will be treated as a NOP\n\nThe instruction provides a hint to potentially improve cache performance by suggesting cache line movement.\n",
    "Alias": []
  },
  {
    "Name": "CLFLUSH",
    "Brief": "Flush Cache Line",
    "Description": "\nInvalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand. If that cache line contains modified data at any level of the cache hierarchy, that data is written back to memory. The source operand is a byte memory location.\n\nThe availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH (CPUID.01H:EDX[bit 19]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).\n\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. Processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCH instructions can be used to provide the processor with hints for this speculative behavior.\n\nExecutions of the CLFLUSH instruction are ordered with respect to each other and with respect to writes, locked read-modify-write instructions, and fence instructions. They are not ordered with respect to executions of CLFLUSHOPT and CLWB. Software can use the SFENCE instruction to order an execution of CLFLUSH relative to one of those operations.\n\nThe CLFLUSH instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load. Like a load, the CLFLUSH instruction sets the A bit but not the D bit in the page tables.\n\nIn some implementations, the CLFLUSH instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX).\n",
    "Alias": []
  },
  {
    "Name": "CLFLUSHOPT",
    "Brief": "Invalidate cache line optimized",
    "Description": "\nInvalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand. If that cache line contains modified data at any level of the cache hierarchy, that data is written back to memory. The source operand is a byte memory location.\n\nThe availability of CLFLUSHOPT is indicated by the presence of the CPUID feature flag CLFLUSHOPT (CPUID.(EAX=07H,ECX=0H):EBX[bit 23]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).\n\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. Processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads.\n\nExecutions of the CLFLUSHOPT instruction are ordered with respect to fence instructions and to locked read-modify-write instructions; they are also ordered with respect to older writes to the cache line being invalidated. They are not ordered with respect to other executions of CLFLUSHOPT, to executions of CLFLUSH and CLWB, or to younger writes to the cache line being invalidated. Software can use the SFENCE instruction to order an execution of CLFLUSHOPT relative to one of those operations.\n\nThe CLFLUSHOPT instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load. Like a load, the CLFLUSHOPT instruction sets the A bit but not the D bit in the page tables.\n\nIn some implementations, the CLFLUSHOPT instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX).\n",
    "Alias": []
  },
  {
    "Name": "CLI",
    "Brief": "Clear Interrupt Flag",
    "Description": "\nIn most cases, CLI clears the IF flag in the EFLAGS register and no other flags are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the CLI and STI instruction have no effect on the generation of exceptions and NMI interrupts.\n\nOperation is different in two modes defined as follows:\n- PVI mode (protected-mode virtual interrupts): CR0.PE = 1, EFLAGS.VM = 0, CPL = 3, and CR4.PVI = 1\n- VME mode (virtual-8086 mode extensions): CR0.PE = 1, EFLAGS.VM = 1, and CR4.VME = 1\n\nIf IOPL < 3 and either VME mode or PVI mode is active, CLI clears the VIF flag in the EFLAGS register, leaving IF unaffected.\n\nThe behavior of CLI depends on the processor operating mode, IOPL, and CPL:\n- In real-address mode, it always clears the IF flag\n- In protected mode:\n  * If IOPL ≥ CPL, it clears the IF flag\n  * If IOPL < CPL and PVI mode is not active, it generates a #GP fault\n- In virtual-8086 mode:\n  * If IOPL = 3, it clears the IF flag\n  * If IOPL < 3 and VME mode is not active, it generates a #GP fault\n",
    "Alias": []
  },
  {
    "Name": "CLRSSBSY",
    "Brief": "Clear Busy Flag in a Supervisor Shadow Stack Token",
    "Description": "\nClear busy flag in supervisor shadow stack token referenced by m64. Subsequent to marking the shadow stack as not busy, the SSP (Shadow Stack Pointer) is loaded with value 0.\n\nThe instruction performs the following key operations:\n1. Checks if Control Register 4 (CR4) has CET (Control Flow Enforcement Technology) enabled\n2. Checks if Shadow Stack is enabled\n3. Ensures the Current Privilege Level (CPL) is 0\n4. Validates the memory operand address alignment\n5. Clears the busy bit in the shadow stack token\n6. Sets the Carry Flag (CF) if an invalid token is detected\n7. Sets the Shadow Stack Pointer (SSP) to 0\n\nThe instruction is only valid in protected mode and 64-bit mode, and requires specific control register and privilege level conditions to be met.\n",
    "Alias": []
  },
  {
    "Name": "CLTS",
    "Brief": "Clear Task-Switched Flag in CR0",
    "Description": "\nClears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-address mode to allow initialization for protected mode.\n\nThe processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU context in multitasking applications. See the description of the TS flag in the section titled \"Control Registers\" in Chapter 2 of the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for more information about this flag.\n\nCLTS operation is the same in non-64-bit modes and 64-bit mode.\n\nSee Chapter 26, \"VMX Non-Root Operation,\" of the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.\n",
    "Alias": []
  },
  {
    "Name": "CLUI",
    "Brief": "Clear User Interrupt Flag",
    "Description": "\nCLUI clears the user interrupt flag (UIF). Its effect takes place immediately: a user interrupt cannot be delivered on the instruction boundary following CLUI.\n\nAn execution of CLUI inside a transactional region causes a transactional abort; the abort loads EAX as it would have been caused due to an execution of CLI.\n\nThe instruction is only valid in 64-bit mode when:\n- CR4.UINTR is set to 1\n- CPUID.07H.0H:EDX.UINTR[bit 5] is set to 1\n- Not executed inside an enclave\n- No LOCK prefix is used\n\nWhen executed in other modes (protected, real-address, virtual-8086, compatibility), the instruction will generate an Undefined Opcode (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "CLWB",
    "Brief": "Cache Line Write Back",
    "Description": "\nWrites back to memory the cache line (if modified) that contains the linear address specified with the memory operand from any level of the cache hierarchy in the cache coherence domain. The line may be retained in the cache hierarchy in non-modified state. Retaining the line in the cache hierarchy is a performance optimization (treated as a hint by hardware) to reduce the possibility of cache miss on a subsequent access.\n\nThe availability of CLWB instruction is indicated by the presence of the CPUID feature flag CLWB (bit 24 of the EBX register). The aligned cache line size affected is also indicated with the CPUID instruction.\n\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. Processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type allowing for speculative reads.\n\nExecutions of the CLWB instruction are ordered with respect to fence instructions and to locked read-modify-write instructions; they are also ordered with respect to older writes to the cache line being written back. They are not ordered with respect to other executions of CLWB, to executions of CLFLUSH and CLFLUSHOPT, or to younger writes to the cache line being written back.\n\nFor usages that require only writing back modified data from cache lines to memory (do not require the line to be invalidated), and expect to subsequently access the data, software is recommended to use CLWB (with appropriate fencing) instead of CLFLUSH or CLFLUSHOPT for improved performance.\n\nThe CLWB instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load. Like a load, the CLWB instruction sets the accessed flag but not the dirty flag in the page tables.\n",
    "Alias": []
  },
  {
    "Name": "CMC",
    "Brief": "Complement Carry Flag",
    "Description": "\nComplements the CF flag in the EFLAGS register. CMC operation is the same in non-64-bit modes and 64-bit mode.\n\nThis instruction simply inverts the current value of the Carry Flag (CF). If the flag was set (1), it becomes cleared (0), and if it was cleared (0), it becomes set (1).\n\nThe operation is performed using a bitwise NOT operation on the CF flag:\nEFLAGS.CF[bit 0] := NOT EFLAGS.CF[bit 0]\n\nOther flags (OF, ZF, SF, AF, and PF) are unaffected by this instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVcc",
    "Brief": "Perform conditional move based on status flags",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVA/CMOVNBE",
    "Brief": "Move if above (unsigned)",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVAE/CMOVNB",
    "Brief": "Move if above or equal (unsigned)",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVB/CMOVC",
    "Brief": "Move if below (unsigned)",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVBE/CMOVNA",
    "Brief": "Move if below or equal (unsigned)",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVE/CMOVZ",
    "Brief": "Move if equal/zero",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVNE/CMOVNZ",
    "Brief": "Move if not equal/not zero",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVG/CMOVNLE",
    "Brief": "Move if greater (signed)",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVGE/CMOVNL",
    "Brief": "Move if greater or equal (signed)",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVL/CMOVNGE",
    "Brief": "Move if less (signed)",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVLE/CMOVNG",
    "Brief": "Move if less or equal (signed)",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVO",
    "Brief": "Move if overflow",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVNO",
    "Brief": "Move if not overflow",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVS",
    "Brief": "Move if sign",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVNS",
    "Brief": "Move if not sign",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVP/CMOVPE",
    "Brief": "Move if parity/parity even",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMOVNP/CMOVPO",
    "Brief": "Move if not parity/parity odd",
    "Description": "\nEach of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\n\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers and the terms \"above\" and \"below\" are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the same opcode.\n\nThe CMOVcc instructions were introduced in P6 family processors and may not be supported by all IA-32 processors. Software can determine support by checking the processor's feature information with the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "CMP",
    "Brief": "Compare two operands and set status flags",
    "Description": "\nCompares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as an operand, it is sign-extended to the length of the first operand.\n\nThe condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction. Appendix B, \"EFLAGS Condition Codes,\" in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the relationship of the status flags and the condition codes.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nThe operation performs a subtraction (temp := SRC1 − SignExtend(SRC2)) and modifies the status flags accordingly. The CF, OF, SF, ZF, AF, and PF flags are set based on the result of the comparison.\n",
    "Alias": []
  },
  {
    "Name": "CMPPD",
    "Brief": "Compare packed double precision floating-point values",
    "Description": "\nPerforms a SIMD compare of the packed double precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands.\n\nEVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is an opmask register. Comparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).\n\nVEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Four comparisons are performed with results written to the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\n\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Two comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\n\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. Two comparisons are performed with results written to bits 127:0 of the destination operand.\n\nThe comparison predicate operand is an 8-bit immediate that defines the type of comparison to be performed. The instruction supports 32 different comparison predicates, including equal, less than, unordered, and various combinations of these comparisons with signaling and non-signaling options.\n\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\n",
    "Alias": []
  },
  {
    "Name": "CMPPS",
    "Brief": "Compare packed single precision floating-point values",
    "Description": "\nPerforms a SIMD compare of the packed single precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each of the pairs of packed values.\n\nEVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is an opmask register. Comparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).\n\nVEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Eight comparisons are performed with results written to the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\n\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Four comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\n\nThe comparison predicate operand is an 8-bit immediate that defines the type of comparison to be performed. The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\n",
    "Alias": []
  },
  {
    "Name": "CMPS",
    "Brief": "Compare string operands",
    "Description": "\nCompares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.\n\nBoth source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the two source operands to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the CMPS instructions.\n\nAfter the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations, and 8 for quadword operations.\n\nThe CMPS instructions can be preceded by the REP prefix for block comparisons, and are often used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made.\n\nIn 64-bit mode, the instruction's default address size is 64 bits, with 32-bit address size supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "CMPSB",
    "Brief": "Compare byte string operands",
    "Description": "\nCompares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.\n\nBoth source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the two source operands to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the CMPS instructions.\n\nAfter the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations, and 8 for quadword operations.\n\nThe CMPS instructions can be preceded by the REP prefix for block comparisons, and are often used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made.\n\nIn 64-bit mode, the instruction's default address size is 64 bits, with 32-bit address size supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "CMPSW",
    "Brief": "Compare word string operands",
    "Description": "\nCompares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.\n\nBoth source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the two source operands to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the CMPS instructions.\n\nAfter the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations, and 8 for quadword operations.\n\nThe CMPS instructions can be preceded by the REP prefix for block comparisons, and are often used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made.\n\nIn 64-bit mode, the instruction's default address size is 64 bits, with 32-bit address size supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "CMPSD",
    "Brief": "Compare doubleword string operands",
    "Description": "\nCompares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.\n\nBoth source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the two source operands to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the CMPS instructions.\n\nAfter the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations, and 8 for quadword operations.\n\nThe CMPS instructions can be preceded by the REP prefix for block comparisons, and are often used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made.\n\nIn 64-bit mode, the instruction's default address size is 64 bits, with 32-bit address size supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "CMPSQ",
    "Brief": "Compare quadword string operands",
    "Description": "\nCompares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.\n\nBoth source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the two source operands to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the CMPS instructions.\n\nAfter the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations, and 8 for quadword operations.\n\nThe CMPS instructions can be preceded by the REP prefix for block comparisons, and are often used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made.\n\nIn 64-bit mode, the instruction's default address size is 64 bits, with 32-bit address size supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "CMPSS",
    "Brief": "Compare Scalar Single Precision Floating-Point Value",
    "Description": "\nCompares the low single precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (immediate operand) specifies the type of comparison performed.\n\n128-bit Legacy SSE version: The first source and destination operand is an XMM register. The second source operand can be an XMM register or 32-bit memory location. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand can be an XMM register or a 32-bit memory location. The result is stored in the low 32 bits of the destination operand; bits 127:32 of the destination operand are copied from the first source operand.\n\nEVEX encoded version: The first source operand is an XMM register. The second source operand can be a XMM register or a 32-bit memory location. The destination operand is an opmask register. The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).\n\nThe comparison predicate operand is an 8-bit immediate that defines the type of comparison to be performed. The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\n\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\n",
    "Alias": []
  },
  {
    "Name": "CMPXCHG",
    "Brief": "Compare and Exchange values atomically",
    "Description": "\nCompares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nThis instruction is not supported on Intel processors earlier than the Intel486 processors.\n",
    "Alias": []
  },
  {
    "Name": "CMPXCHG8B",
    "Brief": "Compare and exchange 64-bit value",
    "Description": "\nCompares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX).\n\nThe destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64 bits of a 128-bit value.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination.\n\nIn 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned.\n",
    "Alias": []
  },
  {
    "Name": "CMPXCHG16B",
    "Brief": "Compare and exchange 128-bit value",
    "Description": "\nCompares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX).\n\nThe destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64 bits of a 128-bit value.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination.\n\nIn 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned.\n",
    "Alias": []
  },
  {
    "Name": "COMISD",
    "Brief": "Compare scalar ordered double precision floating-point values and set EFLAGS",
    "Description": "\nCompares the double precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\n\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory location. The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid operation exception only if a source operand is an SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\n\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n\nSoftware should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "COMISS",
    "Brief": "Compare scalar ordered single precision floating-point values and set EFLAGS",
    "Description": "\nCompares the single precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\n\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.\n\nThe COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid operation exception only if a source operand is an SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\n\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n\nSoftware should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "CPUID",
    "Brief": "CPU Identification Instruction",
    "Description": "\nThe CPUID instruction is used to query information about the processor's capabilities, features, and characteristics. When executed, it returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.\n\nKey capabilities of the CPUID instruction include:\n\n1. Returning the maximum input value for basic processor information\n2. Providing vendor identification string\n3. Reporting processor model, family, and stepping information\n4. Enumerating processor features and capabilities\n5. Returning cache and TLB information\n6. Providing processor brand string\n7. Reporting extended topology information\n8. Enumerating various processor technologies like SSE, AVX, SGX, etc.\n\nThe instruction operates differently based on the value loaded in the EAX register:\n- EAX = 0: Returns highest basic input value and vendor identification string\n- EAX = 1: Returns processor version information and feature flags\n- EAX = 2-20H: Returns various detailed processor information\n- EAX = 80000000H: Returns highest extended function input value\n- EAX = 80000002H-80000004H: Returns processor brand string\n\nSoftware should always check feature flags returned by CPUID before using specific processor features to ensure compatibility and proper support.\n",
    "Alias": []
  },
  {
    "Name": "CRC32",
    "Brief": "Accumulate CRC32 Value",
    "Description": "\nStarting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial 11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. \n\nThe source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If the destination is an r64 register, then the 32-bit result is stored in the least significant double word and 00000000H is stored in the most significant double word of the r64 register.\n\nThe initial value supplied in the destination operand is a double word integer stored in the r32 register or the least significant double word of the r64 register. To incrementally accumulate a CRC32 value, software retains the result of the previous CRC32 operation in the destination operand, then executes the CRC32 instruction again with new input data in the source operand.\n\nData contained in the source operand is processed in reflected bit order. This means that the most significant bit of the source operand is treated as the least significant bit of the quotient, and so on, for all the bits of the source operand. Likewise, the result of the CRC operation is stored in the destination operand in reflected bit order. This means that the most significant bit of the resulting CRC (bit 31) is stored in the least significant bit of the destination operand (bit 0), and so on, for all the bits of the CRC.\n",
    "Alias": []
  },
  {
    "Name": "CVTDQ2PD",
    "Brief": "Convert packed doubleword integers to packed double precision floating-point values",
    "Description": "\nConverts two, four or eight packed signed doubleword integers in the source operand (the second operand) to two, four or eight packed double precision floating-point values in the destination operand (the first operand).\n\nEVEX encoded versions: The source operand can be a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. Attempt to encode this instruction with EVEX embedded rounding is ignored.\n\nVEX.256 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is a YMM register.\n\nVEX.128 encoded version: The source operand is an XMM register or 64-bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The source operand is an XMM register or 64-bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "CVTDQ2PS",
    "Brief": "Convert packed signed doubleword integers to packed single precision floating-point values",
    "Description": "\nConverts four, eight or sixteen packed signed doubleword integers in the source operand to four, eight or sixteen packed single precision floating-point values in the destination operand.\n\nEVEX encoded versions: The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The source operand is a YMM register or 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding register destination are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\n\n128-bit Legacy SSE version: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "CVTPD2DQ",
    "Brief": "Convert packed double precision floating-point values to packed doubleword integers",
    "Description": "\nConverts packed double precision floating-point values in the source operand (second operand) to packed signed doubleword integers in the destination operand (first operand).\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2^w-1, where w represents the number of bits in the destination format) is returned.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.\n\nVEX.256 encoded version: The source operand is a YMM register or 256-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "CVTPD2PI",
    "Brief": "Convert packed double precision floating-point values to packed doubleword integers",
    "Description": "\nConverts two packed double precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).\n\nThe source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "CVTPD2PS",
    "Brief": "Convert packed double precision floating-point values to packed single precision floating-point values",
    "Description": "\nConverts two, four or eight packed double precision floating-point values in the source operand (second operand) to two, four or eight packed single precision floating-point values in the destination operand (first operand).\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64-bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.\n\nVEX.256 encoded version: The source operand is a YMM register or 256-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "CVTPI2PD",
    "Brief": "Convert packed signed doubleword integers to packed double precision floating-point values",
    "Description": "\nConverts two packed signed doubleword integers in the source operand (second operand) to two packed double precision floating-point values in the destination operand (first operand).\n\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. \n\nThere are two different behavior scenarios:\n1. For operands xmm, mm: \n   - Causes a transition from x87 FPU to MMX technology operation\n   - Sets the x87 FPU top-of-stack pointer to 0\n   - Sets the x87 FPU tag word to all 0s (valid)\n   - If an x87 FPU floating-point exception is pending, it is handled before the instruction is executed\n\n2. For operands xmm, m64:\n   - Does not cause a transition to MMX technology\n   - Does not take x87 FPU exceptions\n\nIn 64-bit mode, the REX.R prefix can be used to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "CVTPI2PS",
    "Brief": "Convert packed signed doubleword integers to packed single precision floating-point values",
    "Description": "\nConverts two packed signed doubleword integers in the source operand (second operand) to two packed single precision floating-point values in the destination operand (first operand).\n\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. The results are stored in the low quadword of the destination operand, and the high quadword remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "CVTPS2DQ",
    "Brief": "Convert packed single precision floating-point values to packed signed doubleword integer values",
    "Description": "\nConverts four, eight or sixteen packed single precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2^w-1, where w represents the number of bits in the destination format) is returned.\n\nEVEX encoded versions: The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The source operand is a YMM register or 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "CVTPS2PD",
    "Brief": "Convert packed single precision floating-point values to packed double precision floating-point values",
    "Description": "\nConverts two, four or eight packed single precision floating-point values in the source operand (second operand) to two, four or eight packed double precision floating-point values in the destination operand (first operand).\n\nEVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or 64-bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The source operand is an XMM register or 64-bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "CVTPS2PI",
    "Brief": "Convert packed single precision floating-point values to packed signed doubleword integers",
    "Description": "\nConverts two packed single precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).\n\nThe source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single precision floating-point values are contained in the low quadword of the register. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\n\nCVTPS2PI causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPS2PI instruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "CVTSD2SI",
    "Brief": "Convert scalar double precision floating-point value to doubleword or quadword integer",
    "Description": "\nConverts a double precision floating-point value in the source operand (the second operand) to a signed double-word or quadword integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double precision floating-point value is contained in the low quadword of the register.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n\nIf a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\n\nIf a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.\n\nLegacy SSE instruction: Use of the REX.W prefix promotes the instruction to produce 64-bit data in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "CVTSD2SS",
    "Brief": "Convert scalar double precision floating-point value to scalar single precision floating-point value",
    "Description": "\nConverts a double precision floating-point value in the \"convert-from\" source operand to a single precision floating-point value in the destination operand.\n\nWhen the \"convert-from\" operand is an XMM register, the double precision floating-point value is contained in the low quadword of the register. The result is stored in the low doubleword of the destination operand. When the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n\n128-bit Legacy SSE version: The \"convert-from\" source operand is an XMM register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged. The destination operand is an XMM register.\n\nVEX.128 and EVEX encoded versions: The \"convert-from\" source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX encoded version: the converted result is written to the low doubleword element of the destination under the writemask.\n\nSoftware should ensure VCVTSD2SS is encoded with VEX.L=0. Encoding VCVTSD2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "CVTSI2SD",
    "Brief": "Convert signed integer to scalar double precision floating-point value",
    "Description": "\nConverts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the \"convert-from\" source operand to a double precision floating-point value in the destination operand. The result is stored in the low quadword of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n\nThe second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: Use of the REX.W prefix promotes the instruction to 64-bit operands. The \"convert-from\" source operand (the second operand) is a general-purpose register or memory location. The destination is an XMM register. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX encoded versions: The \"convert-from\" source operand (the third operand) can be a general-purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored.\n\nVEX.W1 and EVEX.W1 versions: promotes the instruction to use 64-bit input value in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "CVTSI2SS",
    "Brief": "Convert signed integer to scalar single precision floating-point value",
    "Description": "\nConverts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the \"convert-from\" source operand to a single precision floating-point value in the destination operand (first operand). The \"convert-from\" source operand can be a general-purpose register or a memory location. The destination operand is an XMM register.\n\nThe result is stored in the low doubleword of the destination operand, and the upper three doublewords are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.\n\n128-bit Legacy SSE version: In 64-bit mode, use of the REX.W prefix promotes the instruction to use 64-bit input value. The \"convert-from\" source operand (the second operand) is a general-purpose register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX encoded versions: The \"convert-from\" source operand (the third operand) can be a general-purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX encoded version: the converted result is written to the low doubleword element of the destination under the writemask.\n",
    "Alias": []
  },
  {
    "Name": "CVTSS2SD",
    "Brief": "Convert scalar single precision floating-point value to scalar double precision floating-point value",
    "Description": "\nConverts a single precision floating-point value in the \"convert-from\" source operand to a double precision floating-point value in the destination operand. When the \"convert-from\" source operand is an XMM register, the single precision floating-point value is contained in the low doubleword of the register. The result is stored in the low quadword of the destination operand.\n\n128-bit Legacy SSE version: The \"convert-from\" source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged. The destination operand is an XMM register.\n\nVEX.128 and EVEX encoded versions: The \"convert-from\" source operand (the third operand) can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nSoftware should ensure VCVTSS2SD is encoded with VEX.L=0. Encoding VCVTSS2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "CVTSS2SI",
    "Brief": "Convert scalar single precision floating-point value to signed doubleword or quadword integer",
    "Description": "\nConverts a single precision floating-point value in the source operand to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand. The source operand can be an XMM register or a memory location, with the single precision floating-point value contained in the low doubleword of the register.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2^w-1, where w represents the number of bits in the destination format) is returned.\n\nIn 64-bit mode, use of the REX.W prefix or VEX.W1/EVEX.W1 promotes the instruction to produce 64-bit data. \n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD. Software should ensure VCVTSS2SI is encoded with VEX.L=0 to avoid unpredictable behavior.\n",
    "Alias": []
  },
  {
    "Name": "CVTTPD2DQ",
    "Brief": "Convert with truncation packed double precision floating-point values to packed doubleword integers",
    "Description": "\nConverts two, four, or eight packed double precision floating-point values in the source operand to packed signed doubleword integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\n\nVEX.256 encoded version: The source operand is a YMM register or 256-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "CVTTPD2PI",
    "Brief": "Convert two packed double precision floating-point values to two packed signed doubleword integers using truncation",
    "Description": "\nConverts two packed double precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.\n\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "CVTTPS2DQ",
    "Brief": "Convert packed single precision floating-point values to packed signed doubleword integer values with truncation",
    "Description": "\nConverts four, eight or sixteen packed single precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The source operand is a YMM register or 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "CVTTPS2PI",
    "Brief": "Convert packed single precision floating-point values to packed doubleword signed integers using truncation",
    "Description": "\nConverts two packed single precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single precision floating-point values are contained in the low quadword of the register.\n\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "CVTTSD2SI",
    "Brief": "Convert scalar double precision floating-point value to signed integer with truncation",
    "Description": "\nConverts a double precision floating-point value in the source operand (the second operand) to a signed double-word integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the double precision floating-point value is contained in the low quadword of the register.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n\nIf a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\n\nIf a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.\n\nLegacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "CVTTSS2SI",
    "Brief": "Convert Scalar Single Precision Floating-Point Value to Integer with Truncation",
    "Description": "\nConverts a single precision floating-point value in the source operand to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the single precision floating-point value is contained in the low doubleword of the register.\n\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked, the indefinite integer value (80000000H or 80000000_00000000H if operand size is 64 bits) is returned.\n\nIn 64-bit mode, use of the REX.W prefix or VEX.W1/EVEX.W1 promotes the instruction to 64-bit operation. Note that VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise the instruction will cause an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "DAA",
    "Brief": "Decimal Adjust AL After Addition",
    "Description": "\nAdjusts the sum of two packed BCD (Binary Coded Decimal) values to create a packed BCD result. The AL register is the implied source and destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two 2-digit, packed BCD values and stores a byte result in the AL register.\n\nThe instruction adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the CF and AF flags are set accordingly.\n\nThis instruction is only valid in compatibility mode and legacy mode. It is not valid in 64-bit mode.\n\nThe adjustment process involves:\n1. Checking if the lower 4 bits of AL are greater than 9 or if the auxiliary carry flag (AF) is set\n2. If true, add 6 to AL and set the carry and auxiliary carry flags\n3. Checking if the entire AL value is greater than 99H or if the initial carry flag was set\n4. If true, add 60H to AL and set the carry flag\n\nThe CF and AF flags are set if the adjustment results in a decimal carry in either digit of the result. The SF, ZF, and PF flags are set according to the result, and the OF flag is undefined.\n",
    "Alias": []
  },
  {
    "Name": "DAS",
    "Brief": "Decimal Adjust AL After Subtraction",
    "Description": "\nAdjusts the result of the subtraction of two packed BCD (Binary Coded Decimal) values to create a packed BCD result. The AL register is the implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register.\n\nThe instruction adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal borrow is detected, the CF and AF flags are set accordingly.\n\nThis instruction executes only in compatibility mode and legacy mode. It is not valid in 64-bit mode.\n\nThe adjustment process involves:\n1. Checking if the lower nibble of AL is greater than 9 or if the auxiliary carry flag (AF) is set\n2. Subtracting 6 from AL if condition 1 is true\n3. Checking if the entire AL value is greater than 99H or if the carry flag was originally set\n4. Subtracting 60H from AL if condition 3 is true\n\nThe CF and AF flags are set if the adjustment of the value results in a decimal borrow in either digit of the result. The SF, ZF, and PF flags are set according to the result, and the OF flag is undefined.\n",
    "Alias": []
  },
  {
    "Name": "DEC",
    "Brief": "Decrement operand by 1 without affecting the carry flag",
    "Description": "\nSubtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes). Otherwise, the instruction's 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nThe instruction supports decrementing 8-bit, 16-bit, 32-bit, and 64-bit operands in registers or memory locations.\n",
    "Alias": []
  },
  {
    "Name": "DIV",
    "Brief": "Unsigned divide the value in the accumulator by the source operand",
    "Description": "\nDivides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.\n\nNon-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the unsigned value in RDX:RAX by the source operand and stores the quotient in RAX, the remainder in RDX.\n\nThe instruction supports different operand sizes:\n- 8-bit: Dividend in AX, Divisor is r/m8, Quotient in AL, Remainder in AH\n- 16-bit: Dividend in DX:AX, Divisor is r/m16, Quotient in AX, Remainder in DX\n- 32-bit: Dividend in EDX:EAX, Divisor is r/m32, Quotient in EAX, Remainder in EDX\n- 64-bit: Dividend in RDX:RAX, Divisor is r/m64, Quotient in RAX, Remainder in RDX\n",
    "Alias": []
  },
  {
    "Name": "DIVPD",
    "Brief": "Divide packed double precision floating-point values",
    "Description": "\nPerforms a SIMD divide of the double precision floating-point values in the first source operand by the floating-point values in the second source operand. Results are written to the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination are zeroed.\n\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The destination is the same as the first source operand. The upper bits (MAXVL-1:128) of the corresponding destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VDIVPD",
    "Brief": "Vector divide packed double precision floating-point values",
    "Description": "\nPerforms a SIMD divide of the double precision floating-point values in the first source operand by the floating-point values in the second source operand. Results are written to the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination are zeroed.\n\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The destination is the same as the first source operand. The upper bits (MAXVL-1:128) of the corresponding destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "DIVPS",
    "Brief": "Divide packed single precision floating-point values",
    "Description": "\nPerforms a SIMD divide of the four, eight or sixteen packed single precision floating-point values in the first source operand (the second operand) by the four, eight or sixteen packed single precision floating-point values in the second source operand (the third operand). Results are written to the destination operand (the first operand).\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "DIVSD",
    "Brief": "Divide low double precision floating-point value",
    "Description": "\nDivides the low double precision floating-point value in the first source operand by the low double precision floating-point value in the second source operand, and stores the double precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination are XMM registers.\n\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding ZMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The quadword at bits 127:64 of the destination operand is copied from the corresponding quadword of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The quadword element of the destination operand at bits 127:64 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX version: The low quadword element of the destination is updated according to the writemask.\n\nSoftware should ensure VDIVSD is encoded with VEX.L=0. Encoding VDIVSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "DIVSS",
    "Brief": "Divide low single precision floating-point values",
    "Description": "\nDivides the low single precision floating-point value in the first source operand by the low single precision floating-point value in the second source operand, and stores the single precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location.\n\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The doubleword elements of the destination operand at bits 127:32 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX version: The low doubleword element of the destination is updated according to the writemask.\n\nSoftware should ensure VDIVSS is encoded with VEX.L=0. Encoding VDIVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "DPPD",
    "Brief": "Dot Product of Packed Double Precision Floating-Point Values",
    "Description": "\nConditionally multiplies the packed double precision floating-point values in the destination operand with the packed double precision floating-point values in the source depending on a mask extracted from bits [5:4] of the immediate operand. If a condition mask bit is zero, the corresponding multiplication is replaced by a value of 0.0.\n\nThe two resulting double precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.\n\nIf a broadcast mask bit is \"1\", the intermediate result is copied to the corresponding qword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.\n\nDPPD follows the NaN forwarding rules, with horizontal propagation of NaNs being implementation dependent. At least one NaN from the input sources or computationally generated will be propagated to the destination.\n\nThe 128-bit Legacy SSE version allows the second source to be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits of the corresponding YMM register are unmodified.\n\nThe VEX.128 encoded version zeros the upper bits of the corresponding YMM register destination.\n",
    "Alias": []
  },
  {
    "Name": "VDPPD",
    "Brief": "Vector Dot Product of Packed Double Precision Floating-Point Values",
    "Description": "\nConditionally multiplies the packed double precision floating-point values in the destination operand with the packed double precision floating-point values in the source depending on a mask extracted from bits [5:4] of the immediate operand. If a condition mask bit is zero, the corresponding multiplication is replaced by a value of 0.0.\n\nThe two resulting double precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.\n\nIf a broadcast mask bit is \"1\", the intermediate result is copied to the corresponding qword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.\n\nDPPD follows the NaN forwarding rules, with horizontal propagation of NaNs being implementation dependent. At least one NaN from the input sources or computationally generated will be propagated to the destination.\n\nThe 128-bit Legacy SSE version allows the second source to be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits of the corresponding YMM register are unmodified.\n\nThe VEX.128 encoded version zeros the upper bits of the corresponding YMM register destination.\n",
    "Alias": []
  },
  {
    "Name": "DPPS",
    "Brief": "Dot Product of Packed Single Precision Floating-Point Values",
    "Description": "\nConditionally multiplies the packed single precision floating-point values in the destination operand (first operand) with the packed single precision floats in the source (second operand) depending on a mask extracted from the high 4 bits of the immediate byte. If a condition mask bit is zero, the corresponding multiplication is replaced by a value of 0.0.\n\nThe four resulting single precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the immediate byte:\n- If a broadcast mask bit is \"1\", the intermediate result is copied to the corresponding dword element in the destination operand\n- If a broadcast mask bit is zero, the corresponding element in the destination is set to zero\n\nThe instruction follows NaN forwarding rules, with horizontal propagation of NaNs being implementation dependent.\n\nVariations:\n- 128-bit Legacy SSE version: Source can be an XMM register or 128-bit memory location\n- VEX.128 version: First source is an XMM register or 128-bit memory location, upper bits of destination are zeroed\n- VEX.256 version: First source is a YMM register, second source can be a YMM register or 256-bit memory location\n\nFloating-point exceptions can occur for each add and multiply operation, with unmasked exceptions leaving destination operands unchanged.\n",
    "Alias": []
  },
  {
    "Name": "EMMS",
    "Brief": "Empty MMX Technology State",
    "Description": "\nSets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instructions.\n\nThe EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions. If a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will result in an x87 floating-point exception or incorrect result.\n\nAll other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s). The EMMS operation is the same in non-64-bit modes and 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "ENCODEKEY128",
    "Brief": "Wrap a 128-bit AES key into a key handle",
    "Description": "\nThe ENCODEKEY128 instruction wraps a 128-bit AES key from the implicit operand XMM0 into a key handle that is then stored in the implicit destination operands XMM0-2.\n\nThe explicit source operand specifies handle restrictions, if any. The explicit destination operand is populated with information on the source of the key and its attributes. XMM4 through XMM6 are reserved for future usages and software should not rely upon them being zeroed.\n\nKey details:\n- Uses the WrapKey128 algorithm to generate a key handle\n- Inputs include the input key, key metadata, integrity key, and encryption key\n- Outputs include:\n  1. NoBackup flag\n  2. KeySource\n  3. AAD (Additional Authenticated Data)\n  4. Integrity Tag\n  5. CipherText\n\nThe instruction is part of the Key Locker technology and requires specific CPUID feature flags to be supported.\n",
    "Alias": []
  },
  {
    "Name": "ENCODEKEY256",
    "Brief": "Wrap a 256-bit AES key into a key handle",
    "Description": "\nThe ENCODEKEY256 instruction wraps a 256-bit AES key from the implicit operand XMM1:XMM0 into a key handle that is then stored in the implicit destination operands XMM0-3.\n\nThe explicit source operand is a general-purpose register and specifies what handle restrictions should be built into the handle. These restrictions can include:\n- No-decrypt restriction\n- No-encrypt restriction\n- CPL0-only restriction\n\nThe explicit destination operand is populated with information on the source of the key and its attributes. The key metadata includes:\n- Key type (AES-256)\n- No-backup flag\n- Key source\n\nXMM4 through XMM6 are reserved for future usage and should not be relied upon.\n\nThe instruction uses the WrapKey256 function to create the key handle, which involves:\n- Input key from XMM1:XMM0\n- Key metadata as AAD (Additional Authenticated Data)\n- Integrity and Encryption keys from the Internal Wrapping Key (IWKey)\n\nAll arithmetic flags (OF, SF, ZF, AF, PF, CF) are cleared to 0 after the operation.\n",
    "Alias": []
  },
  {
    "Name": "ENDBR32",
    "Brief": "Terminate an indirect branch in 32-bit and compatibility mode",
    "Description": "\nTerminate an indirect branch in 32-bit and compatibility mode.\n\nWhen the branch tracking is enabled and the conditions are met (such as being in 32-bit or compatibility mode), the instruction sets the Control-flow Enforcement Technology (CET) tracker to IDLE and clears the suppress flag.\n\nIf executed at privilege level 3 (user mode), it sets the user-mode CET tracker to IDLE and clears the user-mode suppress flag. If executed at other privilege levels, it sets the supervisor-mode CET tracker to IDLE and clears the supervisor-mode suppress flag.\n\nThe instruction is part of the Control-flow Enforcement Technology (CET) and helps prevent certain types of control-flow hijacking attacks by validating indirect branches.\n",
    "Alias": []
  },
  {
    "Name": "ENDBR64",
    "Brief": "Terminate an indirect branch in 64-bit mode",
    "Description": "\nTerminate an indirect branch in 64 bit mode. \n\nWhen the branch is enabled and the processor is in 64-bit long mode (IA32_EFER.LMA = 1 and CS.L = 1), this instruction performs the following actions:\n\n- If executed at privilege level 3 (user mode):\n  * Sets the user mode CET (Control-flow Enforcement Technology) tracker to IDLE\n  * Clears the user mode CET suppress flag\n\n- If executed at a privilege level other than 3 (kernel/supervisor mode):\n  * Sets the supervisor mode CET tracker to IDLE\n  * Clears the supervisor mode CET suppress flag\n\nThis instruction is part of the Control-flow Enforcement Technology (CET) feature, which helps prevent certain types of control-flow hijacking attacks by tracking and validating indirect branches.\n",
    "Alias": []
  },
  {
    "Name": "ENQCMD",
    "Brief": "Atomically enqueue 64-byte user command to a device's enqueue register",
    "Description": "\nThe ENQCMD instruction allows software to write commands to enqueue registers, which are special device registers accessed using memory-mapped I/O (MMIO).\n\nEnqueue registers expect writes to have a specific 64-byte format:\n- Bits 19:0: Process Address Space Identifier (PASID)\n- Bit 31: Privilege identification (0 = user; 1 = supervisor)\n- Upper 60 bytes: Device-specific command\n\nThe instruction performs these key steps:\n1. Read 64 bytes of command data from the source memory operand\n2. Format the command data with specific rules:\n   - Command[19:0] get IA32_PASID[19:0]\n   - Command[30:20] are zero\n   - Command[31] is set to 0 (user mode)\n   - Command[511:32] get bits 511:32 from the source operand\n\n3. Perform an enqueue store to write the command to the destination operand (specified as an offset in the ES segment)\n\nThe instruction returns a status via the Zero Flag (ZF):\n- ZF = 0 (success): 64-byte command was written and accepted by the device\n- ZF = 1 (retry): Command was not accepted, either due to device capacity or an invalid destination\n\nThe enqueue store has special properties:\n- Not ordered with other stores\n- Does not write to cache hierarchy\n- Command data is never combined with other stores\n",
    "Alias": []
  },
  {
    "Name": "ENQCMDS",
    "Brief": "Enqueue Command Supervisor for writing commands to enqueue registers",
    "Description": "\nThe ENQCMDS instruction allows system software to write commands to enqueue registers, which are special device registers accessed using memory-mapped I/O (MMIO).\n\nThe instruction begins by reading 64 bytes of command data from its source memory operand. The source operand need not be aligned, and bits 30:20 of the source operand must be zero.\n\nENQCMDS formats the source data into command data as follows:\n- Command[19:0] get bits 19:0 of the source operand (process address-space identifier or PASID)\n- Command[30:20] are zero\n- Command[511:31] get bits 511:31 of the source operand (with bit 31 communicating privilege identification)\n\nThe destination address is specified in a general-purpose register as an offset into the ES segment, and must be 64-byte aligned. An enqueue store does not write data into the cache hierarchy and returns a status:\n- ZF = 0 (success): 64-byte command data was written atomically and accepted by the device\n- ZF = 1 (retry): Command data was not accepted due to capacity or other temporal reasons\n\nThe ENQCMDS instruction may only be executed at privilege level 0 (CPL = 0) and requires the ENQCMD CPUID feature flag.\n",
    "Alias": []
  },
  {
    "Name": "ENTER",
    "Brief": "Make stack frame for procedure parameters",
    "Description": "\nCreates a stack frame (comprising of space for dynamic storage and 1-32 frame pointer storage) for a procedure. The first operand (imm16) specifies the size of the dynamic storage in the stack frame (that is, the number of bytes of dynamically allocated on the stack for the procedure). The second operand (imm8) gives the lexical nesting level (0 to 31) of the procedure.\n\nThe nesting level determines the number of frame pointers that are copied into the \"display area\" of the new stack frame from the preceding frame. The default size of the frame pointer is the StackAddrSize attribute, but can be overridden using the 66H prefix.\n\nThe ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to release the stack frame.\n\nIf the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack, copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of 1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer.\n\nIn 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded. Use of 66H prefix changes frame pointer operand size to 16 bits.\n",
    "Alias": []
  },
  {
    "Name": "EXTRACTPS",
    "Brief": "Extract a single precision floating-point value from a source XMM register",
    "Description": "\nExtracts a single precision floating-point value from the source operand (second operand) at the 32-bit offset specified from the immediate byte (imm8). Immediate bits higher than the most significant offset for the vector length are ignored.\n\nThe extracted single precision floating-point value is stored in the low 32-bits of the destination operand.\n\nIn 64-bit mode, the destination register operand has a default operand size of 64 bits. The upper 32-bits of the register are filled with zero. REX.W is ignored.\n\nVEX.128 and EVEX encoded versions: When VEX.W1 or EVEX.W1 form is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.\n\nThe source register is an XMM register. The imm8[1:0] bits determine the starting DWORD offset from which to extract the 32-bit floating-point value.\n\nIf VEXTRACTPS is encoded with VEX.L = 1, an attempt to execute the instruction will cause an #UD exception.\n",
    "Alias": []
  },
  {
    "Name": "F2XM1",
    "Brief": "Compute 2^x - 1",
    "Description": "\nComputes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range –1.0 to +1.0. If the source value is outside this range, the result is undefined.\n\nThe instruction follows these result patterns:\n- For input between -1.0 to -0: Result is between -0.5 to -0\n- For -0: Result is -0\n- For +0: Result is +0\n- For +0 to +1.0: Result is between +0 to 1.0\n\nValues other than 2 can be exponentiated using the formula:\nx^y := 2^(y * log2(x))\n\nThis instruction's operation is the same in both non-64-bit and 64-bit modes.\n",
    "Alias": []
  },
  {
    "Name": "FABS",
    "Brief": "Replace ST with its absolute value",
    "Description": "\nClears the sign bit of ST(0) to create the absolute value of the operand. \n\nThe instruction works by removing the sign from the floating-point value in ST(0), effectively converting negative numbers to their positive counterparts. The results are as follows:\n- Negative infinity becomes positive infinity\n- Negative finite numbers become positive finite numbers\n- Negative zero becomes positive zero\n- Positive zero remains positive zero\n- Positive finite numbers remain unchanged\n- Positive infinity remains unchanged\n- NaN values remain unchanged\n\nThis instruction operates identically in both non-64-bit and 64-bit modes, and it affects only the sign of the value in the ST(0) register.\n",
    "Alias": []
  },
  {
    "Name": "FADD",
    "Brief": "Adds the destination and source operands and stores the sum in the destination location",
    "Description": "\nAdds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:\n\nFADD ST(0), ST(0);\n\nThe FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)\n\nThe FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.\n\nThe table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.\n\nWhen the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FADDP",
    "Brief": "Adds the destination and source operands, and pop the register stack",
    "Description": "\nAdds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:\n\nFADD ST(0), ST(0);\n\nThe FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)\n\nThe FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.\n\nThe table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.\n\nWhen the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FIADD",
    "Brief": "Adds the destination and source operands, and convert the source operand to double extended-precision floating-point format before performing the addition",
    "Description": "\nAdds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:\n\nFADD ST(0), ST(0);\n\nThe FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)\n\nThe FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.\n\nThe table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.\n\nWhen the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FBLD",
    "Brief": "Convert BCD value to floating-point and push onto the FPU stack",
    "Description": "\nConverts the BCD source operand into double extended-precision floating-point format and pushes the value onto the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved, including that of −0.\n\nThe packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits (AH through FH). Attempting to load an invalid encoding produces an undefined result.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "FBSTP",
    "Brief": "Store BCD Integer and Pop",
    "Description": "\nConverts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value, according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe destination operand specifies the address where the first byte destination value is to be stored. The BCD value (including its sign bit) requires 10 bytes of space in memory.\n\nIf the converted value is too large for the destination format, or if the source operand is an ∞, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory.\n",
    "Alias": []
  },
  {
    "Name": "FCHS",
    "Brief": "Complements the sign bit of ST(0)",
    "Description": "\nComplements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magnitude or vice versa.\n\nThe instruction affects various classes of numbers in the following way:\n- Negative infinity becomes positive infinity\n- Negative finite values become positive finite values\n- Negative zero becomes positive zero\n- Positive zero becomes negative zero\n- Positive finite values become negative finite values\n- Positive infinity becomes negative infinity\n- NaN remains unchanged\n\nThe sign bit is simply flipped, maintaining the value's magnitude while changing its sign.\n\nThis instruction's operation is consistent across different processor modes (non-64-bit and 64-bit modes).\n",
    "Alias": []
  },
  {
    "Name": "FCLEX",
    "Brief": "Clear floating-point exception flags after checking for pending unmasked floating-point exceptions",
    "Description": "\nClears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. \n\nThe FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags, while the FNCLEX instruction does not. \n\nThe assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\n\nThis instruction affects only the x87 FPU floating-point exception flags. It does not affect the SIMD floating-point exception flags in the MXCSR register.\n\nWhen operating on older processors like Pentium or Intel486 in MS-DOS compatibility mode, there were potential interruption scenarios for the FNCLEX instruction, though this is not an issue on later Intel processors (except for the Intel Quark X1000 processor).\n",
    "Alias": []
  },
  {
    "Name": "FNCLEX",
    "Brief": "Clear floating-point exception flags without checking for pending unmasked floating-point exceptions",
    "Description": "\nClears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. \n\nThe FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags, while the FNCLEX instruction does not. \n\nThe assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\n\nThis instruction affects only the x87 FPU floating-point exception flags. It does not affect the SIMD floating-point exception flags in the MXCSR register.\n\nWhen operating on older processors like Pentium or Intel486 in MS-DOS compatibility mode, there were potential interruption scenarios for the FNCLEX instruction, though this is not an issue on later Intel processors (except for the Intel Quark X1000 processor).\n",
    "Alias": []
  },
  {
    "Name": "FCMOVB",
    "Brief": "Move if below (CF=1)",
    "Description": "\nTests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Description column and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\n\nThese instructions were introduced in the P6 family processors and are not available in earlier IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "FCMOVE",
    "Brief": "Move if equal (ZF=1)",
    "Description": "\nTests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Description column and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\n\nThese instructions were introduced in the P6 family processors and are not available in earlier IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "FCMOVBE",
    "Brief": "Move if below or equal (CF=1 or ZF=1)",
    "Description": "\nTests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Description column and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\n\nThese instructions were introduced in the P6 family processors and are not available in earlier IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "FCMOVU",
    "Brief": "Move if unordered (PF=1)",
    "Description": "\nTests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Description column and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\n\nThese instructions were introduced in the P6 family processors and are not available in earlier IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "FCMOVNB",
    "Brief": "Move if not below (CF=0)",
    "Description": "\nTests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Description column and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\n\nThese instructions were introduced in the P6 family processors and are not available in earlier IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "FCMOVNE",
    "Brief": "Move if not equal (ZF=0)",
    "Description": "\nTests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Description column and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\n\nThese instructions were introduced in the P6 family processors and are not available in earlier IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "FCMOVNBE",
    "Brief": "Move if not below or equal (CF=0 and ZF=0)",
    "Description": "\nTests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Description column and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\n\nThese instructions were introduced in the P6 family processors and are not available in earlier IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "FCMOVNU",
    "Brief": "Move if not unordered (PF=0)",
    "Description": "\nTests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Description column and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\n\nThese instructions were introduced in the P6 family processors and are not available in earlier IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "FCOM",
    "Brief": "Compare ST(0) with source value and set condition code flags",
    "Description": "\nCompares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results. The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0.\n\nThe instruction checks the class of the numbers being compared. If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised and, if the exception is masked, the condition flags are set to \"unordered.\" If the invalid-arithmetic-operand exception is unmasked, the condition code flags are not set.\n\nThe FCOMP instruction pops the register stack following the comparison operation, and the FCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FCOM instructions perform the same operation as the FUCOM instructions, with the key difference being how they handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or both of the operands is a NaN value or is in an unsupported format.\n",
    "Alias": []
  },
  {
    "Name": "FCOMP",
    "Brief": "Compare ST(0) with source value, set condition code flags, and pop register stack",
    "Description": "\nCompares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results. The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0.\n\nThe instruction checks the class of the numbers being compared. If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised and, if the exception is masked, the condition flags are set to \"unordered.\" If the invalid-arithmetic-operand exception is unmasked, the condition code flags are not set.\n\nThe FCOMP instruction pops the register stack following the comparison operation, and the FCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FCOM instructions perform the same operation as the FUCOM instructions, with the key difference being how they handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or both of the operands is a NaN value or is in an unsupported format.\n",
    "Alias": []
  },
  {
    "Name": "FCOMPP",
    "Brief": "Compare ST(0) with ST(1), set condition code flags, and pop register stack twice",
    "Description": "\nCompares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results. The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0.\n\nThe instruction checks the class of the numbers being compared. If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised and, if the exception is masked, the condition flags are set to \"unordered.\" If the invalid-arithmetic-operand exception is unmasked, the condition code flags are not set.\n\nThe FCOMP instruction pops the register stack following the comparison operation, and the FCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FCOM instructions perform the same operation as the FUCOM instructions, with the key difference being how they handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or both of the operands is a NaN value or is in an unsupported format.\n",
    "Alias": []
  },
  {
    "Name": "FCOMI",
    "Brief": "Compare ST(0) with ST(i) and set status flags",
    "Description": "\nPerforms an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results. The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.\n\nAn unordered comparison checks the class of the numbers being compared. The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions with a key difference in NaN handling:\n\n- FUCOMI/FUCOMIP raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format\n- QNaNs cause the condition code flags to be set to unordered, but do not cause an exception\n- FCOMI/FCOMIP raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format\n\nIf the operation results in an invalid-arithmetic-operand exception, the status flags in the EFLAGS register are set only if the exception is masked.\n\nThe FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation by marking the ST(0) register as empty and incrementing the stack pointer (TOP) by 1.\n",
    "Alias": []
  },
  {
    "Name": "FCOMIP",
    "Brief": "Compare ST(0) with ST(i), set status flags, and pop register stack",
    "Description": "\nPerforms an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results. The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.\n\nAn unordered comparison checks the class of the numbers being compared. The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions with a key difference in NaN handling:\n\n- FUCOMI/FUCOMIP raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format\n- QNaNs cause the condition code flags to be set to unordered, but do not cause an exception\n- FCOMI/FCOMIP raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format\n\nIf the operation results in an invalid-arithmetic-operand exception, the status flags in the EFLAGS register are set only if the exception is masked.\n\nThe FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation by marking the ST(0) register as empty and incrementing the stack pointer (TOP) by 1.\n",
    "Alias": []
  },
  {
    "Name": "FUCOMI",
    "Brief": "Compare ST(0) with ST(i), check for ordered values, and set status flags",
    "Description": "\nPerforms an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results. The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.\n\nAn unordered comparison checks the class of the numbers being compared. The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions with a key difference in NaN handling:\n\n- FUCOMI/FUCOMIP raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format\n- QNaNs cause the condition code flags to be set to unordered, but do not cause an exception\n- FCOMI/FCOMIP raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format\n\nIf the operation results in an invalid-arithmetic-operand exception, the status flags in the EFLAGS register are set only if the exception is masked.\n\nThe FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation by marking the ST(0) register as empty and incrementing the stack pointer (TOP) by 1.\n",
    "Alias": []
  },
  {
    "Name": "FUCOMIP",
    "Brief": "Compare ST(0) with ST(i), check for ordered values, set status flags, and pop register stack",
    "Description": "\nPerforms an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results. The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.\n\nAn unordered comparison checks the class of the numbers being compared. The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions with a key difference in NaN handling:\n\n- FUCOMI/FUCOMIP raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format\n- QNaNs cause the condition code flags to be set to unordered, but do not cause an exception\n- FCOMI/FCOMIP raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format\n\nIf the operation results in an invalid-arithmetic-operand exception, the status flags in the EFLAGS register are set only if the exception is masked.\n\nThe FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation by marking the ST(0) register as empty and incrementing the stack pointer (TOP) by 1.\n",
    "Alias": []
  },
  {
    "Name": "FCOS",
    "Brief": "Compute the approximate cosine of the source operand",
    "Description": "\nComputes the approximate cosine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −2^63 to +2^63.\n\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions.\n\nSource values outside the range −2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π. However, even within the range -2^63 to +2^63, inaccurate results can occur because the finite approximation of π used internally for argument reduction is not sufficient in all cases.\n\nFor accurate results, it is safe to apply FCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3π/8.\n",
    "Alias": []
  },
  {
    "Name": "FDECSTP",
    "Brief": "Decrement Stack-Top Pointer",
    "Description": "\nSubtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected.\n\nWhen the TOP (Top of Stack) is 0, it wraps around to 7, effectively rotating the stack. This operation does not modify the actual data in the FPU registers, only changes the pointer that indicates which register is currently at the top of the stack.\n\nThe instruction sets the C1 flag to 0, and leaves the C0, C2, and C3 flags undefined. No floating-point exceptions are generated by this instruction.\n",
    "Alias": []
  },
  {
    "Name": "FDIV",
    "Brief": "Divides the destination operand by the source operand and stores the result in the destination location",
    "Description": "\nDivides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format, word or doubleword integer format.\n\nThe no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.\n\nThe FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.\n\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.\n\nThe table shows various division scenarios, covering different combinations of infinities, finite values, zeros, and NaN, with special handling for different input types.\n",
    "Alias": []
  },
  {
    "Name": "FDIVP",
    "Brief": "Divides the destination operand by the source operand, stores the result, and pops the register stack",
    "Description": "\nDivides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format, word or doubleword integer format.\n\nThe no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.\n\nThe FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.\n\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.\n\nThe table shows various division scenarios, covering different combinations of infinities, finite values, zeros, and NaN, with special handling for different input types.\n",
    "Alias": []
  },
  {
    "Name": "FIDIV",
    "Brief": "Divides the destination operand by an integer source operand converted to double extended-precision floating-point format",
    "Description": "\nDivides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format, word or doubleword integer format.\n\nThe no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.\n\nThe FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.\n\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.\n\nThe table shows various division scenarios, covering different combinations of infinities, finite values, zeros, and NaN, with special handling for different input types.\n",
    "Alias": []
  },
  {
    "Name": "FDIVR",
    "Brief": "Divides the source operand by the destination operand and stores the result in the destination location",
    "Description": "\nDivides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format, word or doubleword integer format.\n\nThese instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.\n\nThe no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.\n\nThe FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.\n\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.\n\nWhen the source operand is an integer 0, it is treated as a +0.\n",
    "Alias": []
  },
  {
    "Name": "FDIVRP",
    "Brief": "Divides the source operand by the destination operand, stores the result, and pops the register stack",
    "Description": "\nDivides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format, word or doubleword integer format.\n\nThese instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.\n\nThe no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.\n\nThe FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.\n\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.\n\nWhen the source operand is an integer 0, it is treated as a +0.\n",
    "Alias": []
  },
  {
    "Name": "FIDIVR",
    "Brief": "Divides the source operand by the destination operand, converting the source to double extended-precision floating-point format",
    "Description": "\nDivides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format, word or doubleword integer format.\n\nThese instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.\n\nThe no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.\n\nThe FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.\n\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.\n\nWhen the source operand is an integer 0, it is treated as a +0.\n",
    "Alias": []
  },
  {
    "Name": "FFREE",
    "Brief": "Free Floating-Point Register",
    "Description": "\nSets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected.\n\nThis instruction sets the tag for a specific floating-point register to empty, effectively marking it as available for future use without modifying its actual contents or changing the stack pointer. This allows for manual management of the FPU register stack.\n",
    "Alias": []
  },
  {
    "Name": "FICOM",
    "Brief": "Compare ST(0) with an integer source operand",
    "Description": "\nCompares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results. The integer value is converted to double extended-precision floating-point format before the comparison is made.\n\nThese instructions perform an \"unordered comparison.\" An unordered comparison also checks the class of the numbers being compared. If either operand is a NaN or is in an undefined format, the condition flags are set to \"unordered.\"\n\nThe sign of zero is ignored, so that –0.0 := +0.0.\n\nThe FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor marks the ST(0) register empty and increments the stack pointer (TOP) by 1.\n\nThe comparison results are as follows:\n- ST(0) > SRC: C3, C2, C0 = 000\n- ST(0) < SRC: C3, C2, C0 = 001\n- ST(0) = SRC: C3, C2, C0 = 100\n- Unordered: C3, C2, C0 = 111\n",
    "Alias": []
  },
  {
    "Name": "FICOMP",
    "Brief": "Compare ST(0) with an integer source operand and pop the register stack",
    "Description": "\nCompares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results. The integer value is converted to double extended-precision floating-point format before the comparison is made.\n\nThese instructions perform an \"unordered comparison.\" An unordered comparison also checks the class of the numbers being compared. If either operand is a NaN or is in an undefined format, the condition flags are set to \"unordered.\"\n\nThe sign of zero is ignored, so that –0.0 := +0.0.\n\nThe FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor marks the ST(0) register empty and increments the stack pointer (TOP) by 1.\n\nThe comparison results are as follows:\n- ST(0) > SRC: C3, C2, C0 = 000\n- ST(0) < SRC: C3, C2, C0 = 001\n- ST(0) = SRC: C3, C2, C0 = 100\n- Unordered: C3, C2, C0 = 111\n",
    "Alias": []
  },
  {
    "Name": "FILD",
    "Brief": "Load signed integer onto the FPU register stack",
    "Description": "\nConverts the signed-integer source operand into double extended-precision floating-point format and pushes the value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded without rounding errors. The sign of the source operand is preserved.\n\nThe instruction supports three variants:\n1. FILD m16int: Push 16-bit signed integer onto the FPU register stack\n2. FILD m32int: Push 32-bit signed integer onto the FPU register stack\n3. FILD m64int: Push 64-bit signed integer onto the FPU register stack\n\nWhen executed, the instruction decrements the top of stack (TOP) pointer and stores the converted floating-point value at ST(0).\n\nThis instruction's operation is consistent across non-64-bit and 64-bit modes.\n",
    "Alias": []
  },
  {
    "Name": "FMUL",
    "Brief": "Multiplies the destination and source operands and stores the product in the destination location",
    "Description": "\nMultiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value) and stores the product in the ST(0) register. The two-operand version multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).\n\nThe FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped.\n\nThe FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.\n\nThe sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or ∞. When the source operand is an integer 0, it is treated as a +0.\n",
    "Alias": []
  },
  {
    "Name": "FMULP",
    "Brief": "Multiplies the destination and source operands, stores the product, and pops the register stack",
    "Description": "\nMultiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value) and stores the product in the ST(0) register. The two-operand version multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).\n\nThe FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped.\n\nThe FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.\n\nThe sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or ∞. When the source operand is an integer 0, it is treated as a +0.\n",
    "Alias": []
  },
  {
    "Name": "FIMUL",
    "Brief": "Multiplies the destination and source operands after converting the source operand to double extended-precision floating-point format",
    "Description": "\nMultiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value) and stores the product in the ST(0) register. The two-operand version multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).\n\nThe FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped.\n\nThe FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.\n\nThe sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or ∞. When the source operand is an integer 0, it is treated as a +0.\n",
    "Alias": []
  },
  {
    "Name": "FINCSTP",
    "Brief": "Increment the Stack-Top Pointer in the FPU status register",
    "Description": "\nAdds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a 7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag for the previous top-of-stack register is not marked empty.\n\nThe instruction works by:\n- If TOP is currently 7, reset TOP to 0\n- Otherwise, increment TOP by 1\n\nThe instruction does not modify the contents of the FPU data registers or tag register, it simply rotates the stack pointer.\n",
    "Alias": []
  },
  {
    "Name": "FINIT",
    "Brief": "Initialize FPU after checking for pending unmasked floating-point exceptions",
    "Description": "\nSets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared.\n\nThe FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.\n\nThe assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\n\nThis instruction affects only the x87 FPU. It does not affect the XMM and MXCSR registers.\n\nKey points:\n- Sets FPU control word to 037FH\n- Clears status word\n- Tags all data registers as empty\n- Clears instruction and data pointers\n- FINIT checks for pending exceptions, FNINIT does not\n",
    "Alias": []
  },
  {
    "Name": "FNINIT",
    "Brief": "Initialize FPU without checking for pending unmasked floating-point exceptions",
    "Description": "\nSets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared.\n\nThe FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.\n\nThe assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\n\nThis instruction affects only the x87 FPU. It does not affect the XMM and MXCSR registers.\n\nKey points:\n- Sets FPU control word to 037FH\n- Clears status word\n- Tags all data registers as empty\n- Clears instruction and data pointers\n- FINIT checks for pending exceptions, FNINIT does not\n",
    "Alias": []
  },
  {
    "Name": "FIST",
    "Brief": "Convert value in ST(0) to signed integer and store in destination operand",
    "Description": "\nThe FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand. Values can be stored in word or doubleword integer format. The destination operand specifies the address where the first byte of the destination value is to be stored.\n\nThe FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FISTP instruction also stores values in quadword integer format.\n\nIf the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode specified by the RC field of the FPU control word.\n\nIf the converted value is too large for the destination format, or if the source operand is an ∞, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the integer indefinite value is stored in memory.\n",
    "Alias": []
  },
  {
    "Name": "FISTP",
    "Brief": "Convert value in ST(0) to signed integer, store in destination operand, and pop register stack",
    "Description": "\nThe FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand. Values can be stored in word or doubleword integer format. The destination operand specifies the address where the first byte of the destination value is to be stored.\n\nThe FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FISTP instruction also stores values in quadword integer format.\n\nIf the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode specified by the RC field of the FPU control word.\n\nIf the converted value is too large for the destination format, or if the source operand is an ∞, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the integer indefinite value is stored in memory.\n",
    "Alias": []
  },
  {
    "Name": "FISTTP",
    "Brief": "Store Integer With Truncation",
    "Description": "\nFISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.\n\nThe instruction can store ST(0) in different integer formats:\n- FISTTP m16int: Store ST(0) in 16-bit integer\n- FISTTP m32int: Store ST(0) in 32-bit integer\n- FISTTP m64int: Store ST(0) in 64-bit integer\n\nThe conversion follows these rules:\n- For values less than or equal to -1, it stores the nearest integer less than or equal to the value\n- For values between -1 and +1 (exclusive), it stores 0\n- For values greater than or equal to +1, it stores the nearest integer greater than or equal to the value\n- For infinity or values too large for the destination format, it generates an invalid-operation exception\n- For NaN, it generates an invalid-operation exception\n\nThe instruction always pops the FPU stack after storing the result.\n",
    "Alias": []
  },
  {
    "Name": "FSUB",
    "Brief": "Subtract the source operand from the destination operand and store the difference in the destination location",
    "Description": "\nSubtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.\n\nThe FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped.\n\nThe FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\n\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FSUBP",
    "Brief": "Subtract the source operand from the destination operand, store the difference, and pop the register stack",
    "Description": "\nSubtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.\n\nThe FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped.\n\nThe FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\n\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FISUB",
    "Brief": "Subtract the source integer operand from the destination operand, convert the source to double extended-precision floating-point format first",
    "Description": "\nSubtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThe no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.\n\nThe FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped.\n\nThe FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\n\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FSUBR",
    "Brief": "Subtract destination operand from source operand and store the difference in the destination location",
    "Description": "\nSubtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThese instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.\n\nThe no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.\n\nThe FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\n\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FSUBRP",
    "Brief": "Subtract destination operand from source operand, store the difference, and pop the register stack",
    "Description": "\nSubtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThese instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.\n\nThe no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.\n\nThe FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\n\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FISUBR",
    "Brief": "Subtract destination operand from source operand (after converting source to double extended-precision floating-point format)",
    "Description": "\nSubtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\n\nThese instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.\n\nThe no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.\n\nThe FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n\nThe FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\n\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.\n\nWhen one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-operation exception is generated.\n",
    "Alias": []
  },
  {
    "Name": "FLD",
    "Brief": "Load Floating-Point Value onto the FPU register stack",
    "Description": "\nPushes the source operand onto the FPU register stack. The source operand can be in single precision, double precision, or double extended-precision floating-point format. If the source operand is in single precision or double precision floating-point format, it is automatically converted to the double extended-precision floating-point format before being pushed on the stack.\n\nThe FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.\n\nWhen the FLD instruction loads a denormal value and the DM bit in the CW is not masked, an exception is flagged but the value is still pushed onto the x87 stack.\n\nThis instruction supports loading from:\n- 32-bit floating-point memory locations (m32fp)\n- 64-bit floating-point memory locations (m64fp)\n- 80-bit floating-point memory locations (m80fp)\n- Other FPU registers (ST(i))\n\nThe instruction decrements the top of stack (TOP) and loads the converted or selected value into ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FLD1",
    "Brief": "Push +1.0 onto the FPU register stack",
    "Description": "\nPush one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), π, log10(2), and log(e)2. \n\nFor each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\n\nWhen the RC field is set to round-to-nearest, the FPU produces the same constants that are produced by the Intel 8087 and Intel 287 math coprocessors.\n\nThe operation for each instruction is to decrement the TOP (top of stack) pointer and load the specific constant into ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FLDL2T",
    "Brief": "Push log2(10) onto the FPU register stack",
    "Description": "\nPush one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), π, log10(2), and log(e)2. \n\nFor each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\n\nWhen the RC field is set to round-to-nearest, the FPU produces the same constants that are produced by the Intel 8087 and Intel 287 math coprocessors.\n\nThe operation for each instruction is to decrement the TOP (top of stack) pointer and load the specific constant into ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FLDL2E",
    "Brief": "Push log2(e) onto the FPU register stack",
    "Description": "\nPush one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), π, log10(2), and log(e)2. \n\nFor each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\n\nWhen the RC field is set to round-to-nearest, the FPU produces the same constants that are produced by the Intel 8087 and Intel 287 math coprocessors.\n\nThe operation for each instruction is to decrement the TOP (top of stack) pointer and load the specific constant into ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FLDPI",
    "Brief": "Push π onto the FPU register stack",
    "Description": "\nPush one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), π, log10(2), and log(e)2. \n\nFor each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\n\nWhen the RC field is set to round-to-nearest, the FPU produces the same constants that are produced by the Intel 8087 and Intel 287 math coprocessors.\n\nThe operation for each instruction is to decrement the TOP (top of stack) pointer and load the specific constant into ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FLDLG2",
    "Brief": "Push log10(2) onto the FPU register stack",
    "Description": "\nPush one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), π, log10(2), and log(e)2. \n\nFor each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\n\nWhen the RC field is set to round-to-nearest, the FPU produces the same constants that are produced by the Intel 8087 and Intel 287 math coprocessors.\n\nThe operation for each instruction is to decrement the TOP (top of stack) pointer and load the specific constant into ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FLDLN2",
    "Brief": "Push log(e)2 onto the FPU register stack",
    "Description": "\nPush one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), π, log10(2), and log(e)2. \n\nFor each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\n\nWhen the RC field is set to round-to-nearest, the FPU produces the same constants that are produced by the Intel 8087 and Intel 287 math coprocessors.\n\nThe operation for each instruction is to decrement the TOP (top of stack) pointer and load the specific constant into ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FLDZ",
    "Brief": "Push +0.0 onto the FPU register stack",
    "Description": "\nPush one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), π, log10(2), and log(e)2. \n\nFor each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\n\nWhen the RC field is set to round-to-nearest, the FPU produces the same constants that are produced by the Intel 8087 and Intel 287 math coprocessors.\n\nThe operation for each instruction is to decrement the TOP (top of stack) pointer and load the specific constant into ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FLDCW",
    "Brief": "Load x87 FPU Control Word",
    "Description": "\nLoads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruction is typically used to establish or change the FPU's mode of operation.\n\nIf one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions).\n\nTo avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using the FCLEX or FNCLEX instruction) before loading the new control word.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "FLDENV",
    "Brief": "Load x87 FPU Environment from memory",
    "Description": "\nLoads the complete x87 FPU operating environment from memory into the FPU registers. The source operand specifies the first byte of the operating-environment data in memory. This data is typically written to the specified memory location by a FSTENV or FNSTENV instruction.\n\nThe FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. The layout in memory depends on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit).\n\nThe FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction.\n\nIf one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions).\n\nIf a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by the fault handler may be different than the state being loaded from memory. In such situations, the fault handler should ignore the status of the x87 FPU registers, handle the fault, and return.\n",
    "Alias": []
  },
  {
    "Name": "FNOP",
    "Brief": "No operation on the FPU",
    "Description": "\nPerforms no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or machine context, except the EIP register and the FPU Instruction Pointer.\n\nThe instruction simply advances the instruction pointer without performing any actual operation on the FPU. It does not modify any FPU registers, flags, or state. It is essentially a \"do nothing\" instruction for the x87 Floating-Point Unit.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "FSAVE",
    "Brief": "Store FPU state with checking for pending unmasked floating-point exceptions",
    "Description": "\nStores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. \n\nThe FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state, while the FNSAVE instruction does not.\n\nThe FPU operating environment consists of:\n- FPU control word\n- Status word\n- Tag word\n- Instruction pointer\n- Data pointer\n- Last opcode\n\nThe contents of the FPU register stack are stored in the 80 bytes immediately following the operating environment image.\n\nThe saved image reflects the state of the FPU after all preceding floating-point instructions in the instruction stream have been executed.\n\nAfter saving the FPU state, the FPU is reset to the same default values as with the FINIT/FNINIT instructions.\n\nThese instructions are typically used in scenarios such as:\n- Operating system context switching\n- Exception handlers needing to use the FPU\n- Passing a \"clean\" FPU to a procedure\n\nFor the FSAVE instruction, the assembler issues two instructions: an FWAIT instruction followed by an FNSAVE instruction, which are executed separately.\n",
    "Alias": []
  },
  {
    "Name": "FNSAVE",
    "Brief": "Store FPU state without checking for pending unmasked floating-point exceptions",
    "Description": "\nStores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. \n\nThe FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state, while the FNSAVE instruction does not.\n\nThe FPU operating environment consists of:\n- FPU control word\n- Status word\n- Tag word\n- Instruction pointer\n- Data pointer\n- Last opcode\n\nThe contents of the FPU register stack are stored in the 80 bytes immediately following the operating environment image.\n\nThe saved image reflects the state of the FPU after all preceding floating-point instructions in the instruction stream have been executed.\n\nAfter saving the FPU state, the FPU is reset to the same default values as with the FINIT/FNINIT instructions.\n\nThese instructions are typically used in scenarios such as:\n- Operating system context switching\n- Exception handlers needing to use the FPU\n- Passing a \"clean\" FPU to a procedure\n\nFor the FSAVE instruction, the assembler issues two instructions: an FWAIT instruction followed by an FNSAVE instruction, which are executed separately.\n",
    "Alias": []
  },
  {
    "Name": "FSTCW",
    "Brief": "Store FPU control word after checking for pending unmasked floating-point exceptions",
    "Description": "\nStores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.\n\nThe assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\n\nWhen operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNSTCW instruction to be interrupted prior to being executed to handle a pending FPU exception. This behavior is specific to older processors and the Intel Quark X1000 processor. Later Intel processors do not exhibit this characteristic.\n",
    "Alias": []
  },
  {
    "Name": "FNSTCW",
    "Brief": "Store FPU control word without checking for pending unmasked floating-point exceptions",
    "Description": "\nStores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.\n\nThe assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\n\nWhen operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNSTCW instruction to be interrupted prior to being executed to handle a pending FPU exception. This behavior is specific to older processors and the Intel Quark X1000 processor. Later Intel processors do not exhibit this characteristic.\n",
    "Alias": []
  },
  {
    "Name": "FSTENV",
    "Brief": "Store FPU environment to memory after checking for pending unmasked floating-point exceptions",
    "Description": "\nSaves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode.\n\nThe FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been executed.\n\nThese instructions are often used by exception handlers because they provide access to the FPU instruction and data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment prevents floating-point exceptions from interrupting the exception handler.\n\nThe assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\n",
    "Alias": []
  },
  {
    "Name": "FNSTENV",
    "Brief": "Store FPU environment to memory without checking for pending unmasked floating-point exceptions",
    "Description": "\nSaves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode.\n\nThe FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been executed.\n\nThese instructions are often used by exception handlers because they provide access to the FPU instruction and data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment prevents floating-point exceptions from interrupting the exception handler.\n\nThe assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\n",
    "Alias": []
  },
  {
    "Name": "FSTSW",
    "Brief": "Store x87 FPU status word after checking for pending unmasked floating-point exceptions",
    "Description": "\nStores the current value of the x87 FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. \n\nThe FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word, while the FNSTSW instruction does not.\n\nThe FNSTSW AX form of the instruction is primarily used in conditional branching (such as after an FPU comparison instruction or FPREM, FPREM1, or FXAM instruction), where the branch direction depends on the FPU condition code flags. It can also be used to invoke exception handlers by examining the exception flags in environments that do not use interrupts.\n\nWhen the FNSTSW AX instruction is executed, the AX register is updated before the processor executes any further instructions, guaranteeing that the status stored in the AX register is from the completion of the prior FPU instruction.\n\nThe assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW instruction), and the processor executes each of these instructions separately.\n",
    "Alias": []
  },
  {
    "Name": "FNSTSW",
    "Brief": "Store x87 FPU status word without checking for pending unmasked floating-point exceptions",
    "Description": "\nStores the current value of the x87 FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. \n\nThe FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word, while the FNSTSW instruction does not.\n\nThe FNSTSW AX form of the instruction is primarily used in conditional branching (such as after an FPU comparison instruction or FPREM, FPREM1, or FXAM instruction), where the branch direction depends on the FPU condition code flags. It can also be used to invoke exception handlers by examining the exception flags in environments that do not use interrupts.\n\nWhen the FNSTSW AX instruction is executed, the AX register is updated before the processor executes any further instructions, guaranteeing that the status stored in the AX register is from the completion of the prior FPU instruction.\n\nThe assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW instruction), and the processor executes each of these instructions separately.\n",
    "Alias": []
  },
  {
    "Name": "FPATAN",
    "Brief": "Compute partial arctangent of ST(1)/ST(0)",
    "Description": "\nComputes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0), stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the source operand ST(1) and a magnitude less than +π.\n\nThe FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently, not just on the sign of the ratio Y/X. This is because:\n- A point (−X,Y) is in the second quadrant, resulting in an angle between π/2 and π\n- A point (X,−Y) is in the fourth quadrant, resulting in an angle between 0 and −π/2\n- A point (−X,−Y) is in the third quadrant, giving an angle between −π/2 and −π\n\nThere is no restriction on the range of source operands that FPATAN can accept.\n\nThe instruction performs the operation:\nST(1) := arctan(ST(1) / ST(0))\nPopRegisterStack;\n",
    "Alias": []
  },
  {
    "Name": "FPREM",
    "Brief": "Compute partial remainder of ST(0) divided by ST(1)",
    "Description": "\nComputes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:\n\nRemainder := ST(0) − (Q ∗ ST(1))\n\nHere, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)] toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is less than that of the modulus, unless a partial remainder was computed.\n\nThe FPREM instruction does not compute the remainder specified in IEEE Std 754. The IEEE specified remainder can be computed with the FPREM1 instruction. The FPREM instruction is provided for compatibility with the Intel 8087 and Intel287 math coprocessors.\n\nThe instruction gets its name \"partial remainder\" because it can reduce the exponent of ST(0) by no more than 63 in one execution. If the instruction does not complete the remainder computation, the C2 flag is set, and the result is a partial remainder. Software can re-execute the instruction until C2 is cleared.\n\nAn important use of FPREM is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU status word, which is useful for locating the original angle in the correct sector of the unit circle.\n",
    "Alias": []
  },
  {
    "Name": "FPREM1",
    "Brief": "Compute IEEE remainder by rounding the quotient to the nearest integer",
    "Description": "\nComputes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:\n\nRemainder := ST(0) − (Q ∗ ST(1))\n\nHere, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)] toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the modulus, unless a partial remainder was computed.\n\nThis instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control has no effect. \n\nThe FPREM1 instruction computes the remainder specified in IEEE Standard 754. This instruction operates differently from the FPREM instruction in the way that it rounds the quotient of ST(0) divided by ST(1) to an integer.\n\nThe instruction can reduce the exponent of ST(0) by no more than 63 in one execution. If the remainder is less than one half the modulus, the operation is complete and the C2 flag is cleared. Otherwise, C2 is set, and the result is a partial remainder. Software can re-execute the instruction until C2 is cleared.\n\nAn important use of FPREM1 is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU status word, which is useful for locating the original angle in the unit circle.\n",
    "Alias": []
  },
  {
    "Name": "FPTAN",
    "Brief": "Compute the approximate tangent of the source operand and push 1.0 onto the FPU stack",
    "Description": "\nComputes the approximate tangent of the source operand in register ST(0), stores the result in ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than ±2^63.\n\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions.\n\nSource values outside the range −2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π. However, even within the range -2^63 to +2^63, inaccurate results can occur because the finite approximation of π used internally for argument reduction is not sufficient in all cases.\n\nThe value 1.0 is pushed onto the register stack after the tangent has been computed to maintain compatibility with the Intel 8087 and Intel287 math coprocessors. This operation also simplifies the calculation of other trigonometric functions, such as computing the cotangent by executing a FDIVR instruction after the FPTAN instruction.\n",
    "Alias": []
  },
  {
    "Name": "FRNDINT",
    "Brief": "Round ST(0) to the nearest integral value",
    "Description": "\nRounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding mode (setting of the RC field of the FPU control word), and stores the result in ST(0).\n\nIf the source value is ∞, the value is not changed. If the source value is not an integral value, the floating-point inexact-result exception (#P) is generated.\n\nThe rounding is performed based on the current rounding control (RC) field in the FPU control word, which can specify different rounding modes such as:\n- Round to nearest (even)\n- Round down (toward -∞)\n- Round up (toward +∞)\n- Round toward zero\n\nThis instruction operates the same way in both non-64-bit and 64-bit modes.\n",
    "Alias": []
  },
  {
    "Name": "FRSTOR",
    "Brief": "Load FPU state from memory",
    "Description": "\nLoads the FPU state (operating environment and register stack) from the memory area specified with the source operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruction.\n\nThe FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately following the operating environment image.\n\nThe FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE instruction.\n\nIf one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions). To avoid raising exceptions when loading a new operating environment, clear all the exception flags in the FPU status word that is being loaded.\n",
    "Alias": []
  },
  {
    "Name": "FSCALE",
    "Brief": "Scale ST(0) by ST(1)",
    "Description": "\nTruncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of the destination operand. The destination and source operands are floating-point values located in registers ST(0) and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2.\n\nIn most cases, only the exponent is changed and the mantissa (significand) remains unchanged. However, when the value being scaled in ST(0) is a denormal value, the mantissa is also changed and the result may turn out to be a normalized number. Similarly, if overflow or underflow results from a scale operation, the resulting mantissa will differ from the source's mantissa.\n\nThe FSCALE instruction can also be used to reverse the action of the FXTRACT instruction. For example:\nFXTRACT;\nFSCALE;\nFSTP ST(1);\n\nIn this example, the FXTRACT instruction extracts the significand and exponent from the value in ST(0) and stores them in ST(0) and ST(1) respectively. The FSCALE then scales the significand in ST(0) by the exponent in ST(1), recreating the original value before the FXTRACT operation was performed.\n",
    "Alias": []
  },
  {
    "Name": "FSIN",
    "Brief": "Compute an approximation of the sine of the source operand",
    "Description": "\nComputes an approximation of the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −2^63 to +2^63.\n\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions.\n\nSource values outside the range −2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π. However, even within the range -2^63 to +2^63, inaccurate results can occur because the finite approximation of π used internally for argument reduction is not sufficient in all cases.\n\nFor accurate results, it is safe to apply FSIN only to arguments reduced accurately in software, to a value smaller in absolute value than 3π/4.\n\nThe following table shows the results obtained when taking the sine of various classes of numbers, assuming that underflow does not occur:\n- For finite floating-point values between -∞ and +∞, the result is between -1 and +1\n- For -0 and +0, the result is the same as the input\n- For ±∞, an invalid arithmetic operand (#IA) exception is generated\n- For NaN input, the result is NaN\n",
    "Alias": []
  },
  {
    "Name": "FSINCOS",
    "Brief": "Compute sine and cosine of ST(0)",
    "Description": "\nComputes both the approximate sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.)\n\nThe source operand must be given in radians and must be within the range −2^63 to +2^63. \n\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions.\n\nSource values outside the range −2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π. However, even within the range -2^63 to +2^63, inaccurate results can occur because the finite approximation of π used internally for argument reduction is not sufficient in all cases.\n\nFor accurate results, it is safe to apply FSINCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3π/8.\n",
    "Alias": []
  },
  {
    "Name": "FSQRT",
    "Brief": "Computes square root of ST(0) and stores the result in ST(0)",
    "Description": "\nComputes the square root of the source value in the ST(0) register and stores the result in ST(0).\n\nThe following rules apply when taking the square root of various classes of numbers:\n- Negative finite values (except -0) generate a floating-point invalid-arithmetic-operand (#IA) exception\n- -0 results in -0\n- +0 results in +0\n- Positive finite values result in their positive square root\n- +∞ results in +∞\n- NaN values result in NaN\n\nThis instruction operates identically in both non-64-bit and 64-bit modes.\n",
    "Alias": []
  },
  {
    "Name": "FST",
    "Brief": "Copy ST(0) to destination operand",
    "Description": "\nThe FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location or another register in the FPU register stack. When storing the value in memory, the value is converted to single precision or double precision floating-point format.\n\nThe FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FSTP instruction can also store values in memory in double extended-precision floating-point format.\n\nIf the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.\n\nIf the destination size is single precision or double precision, the significand of the value being stored is rounded to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored in the destination operand.\n\nIf the value being stored is ±0, ±∞, or a NaN, the least-significant bits of the significand and the exponent are truncated to fit the destination format. This operation preserves the value's identity as a 0, ∞, or NaN.\n\nIf the destination operand is a non-empty register, the invalid-operation exception is not generated.\n",
    "Alias": []
  },
  {
    "Name": "FSTP",
    "Brief": "Copy ST(0) to destination operand and pop register stack",
    "Description": "\nThe FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location or another register in the FPU register stack. When storing the value in memory, the value is converted to single precision or double precision floating-point format.\n\nThe FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FSTP instruction can also store values in memory in double extended-precision floating-point format.\n\nIf the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.\n\nIf the destination size is single precision or double precision, the significand of the value being stored is rounded to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored in the destination operand.\n\nIf the value being stored is ±0, ±∞, or a NaN, the least-significant bits of the significand and the exponent are truncated to fit the destination format. This operation preserves the value's identity as a 0, ∞, or NaN.\n\nIf the destination operand is a non-empty register, the invalid-operation exception is not generated.\n",
    "Alias": []
  },
  {
    "Name": "FTST",
    "Brief": "Compare ST(0) with 0.0 and set condition code flags",
    "Description": "\nCompares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results.\n\nThe comparison results are as follows:\n- If ST(0) > 0.0: C3, C2, C0 = 000\n- If ST(0) < 0.0: C3, C2, C0 = 001\n- If ST(0) = 0.0: C3, C2, C0 = 100\n- If Unordered (NaN or undefined format): C3, C2, C0 = 111\n\nThis instruction performs an \"unordered comparison\" which checks the class of the numbers being compared. If the value in ST(0) is a NaN or is in an undefined format, the condition flags are set to \"unordered\" and the invalid operation exception is generated.\n\nThe sign of zero is ignored, so that (-0.0 == +0.0).\n",
    "Alias": []
  },
  {
    "Name": "FUCOM",
    "Brief": "Unordered compare of ST(0) with ST(i)",
    "Description": "\nPerforms an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results. If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0.\n\nAn unordered comparison checks the class of the numbers being compared. The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. The key differences are:\n\n1. These instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format.\n2. QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated.\n3. FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception for any NaN value.\n\nIf the operation results in an invalid-arithmetic-operand exception being raised, the condition code flags are set only if the exception is masked.\n\nThe FUCOMP instruction pops the register stack once following the comparison operation, and the FUCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n",
    "Alias": []
  },
  {
    "Name": "FUCOMP",
    "Brief": "Unordered compare of ST(0) with ST(i) and pop register stack",
    "Description": "\nPerforms an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results. If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0.\n\nAn unordered comparison checks the class of the numbers being compared. The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. The key differences are:\n\n1. These instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format.\n2. QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated.\n3. FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception for any NaN value.\n\nIf the operation results in an invalid-arithmetic-operand exception being raised, the condition code flags are set only if the exception is masked.\n\nThe FUCOMP instruction pops the register stack once following the comparison operation, and the FUCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n",
    "Alias": []
  },
  {
    "Name": "FUCOMPP",
    "Brief": "Unordered compare of ST(0) with ST(1) and pop register stack twice",
    "Description": "\nPerforms an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results. If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0.\n\nAn unordered comparison checks the class of the numbers being compared. The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. The key differences are:\n\n1. These instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format.\n2. QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated.\n3. FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception for any NaN value.\n\nIf the operation results in an invalid-arithmetic-operand exception being raised, the condition code flags are set only if the exception is masked.\n\nThe FUCOMP instruction pops the register stack once following the comparison operation, and the FUCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\n",
    "Alias": []
  },
  {
    "Name": "WAIT",
    "Brief": "Check pending unmasked floating-point exceptions",
    "Description": "\nCauses the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for WAIT.)\n\nThis instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction ensures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction's results.\n\nThe instruction ensures that any pending, unmasked floating-point exceptions are checked and handled, providing a synchronization mechanism for floating-point operations. This helps prevent potential issues with exception handling and instruction results in critical code sections.\n",
    "Alias": []
  },
  {
    "Name": "FWAIT",
    "Brief": "Check pending unmasked floating-point exceptions (alternate mnemonic for WAIT)",
    "Description": "\nCauses the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for WAIT.)\n\nThis instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction ensures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction's results.\n\nThe instruction ensures that any pending, unmasked floating-point exceptions are checked and handled, providing a synchronization mechanism for floating-point operations. This helps prevent potential issues with exception handling and instruction results in critical code sections.\n",
    "Alias": []
  },
  {
    "Name": "FXAM",
    "Brief": "Examine and classify the value in ST(0)",
    "Description": "\nExamines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word to indicate the class of value or number in the register.\n\nThe possible classifications are:\n- Unsupported (C3=0, C2=0, C0=0)\n- NaN (C3=0, C2=0, C0=1)\n- Normal finite number (C3=0, C2=1, C0=0)\n- Infinity (C3=0, C2=1, C0=1)\n- Zero (C3=1, C2=0, C0=0)\n- Empty (C3=1, C2=0, C0=1)\n- Denormal number (C3=1, C2=1, C0=0)\n\nThe C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full (0 for positive, 1 for negative).\n\nThis instruction does not generate any floating-point exceptions and its operation is the same in both 32-bit and 64-bit modes.\n",
    "Alias": []
  },
  {
    "Name": "FXCH",
    "Brief": "Exchange the contents of two FPU registers",
    "Description": "\nExchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged.\n\nThis instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)], so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For example, the following instruction sequence takes the square root of the third register from the top of the register stack:\n\nFXCH ST(3);\nFSQRT;\nFXCH ST(3);\n\nThis allows manipulation of values in the FPU register stack by temporarily moving them to ST(0) for operations that require it.\n",
    "Alias": []
  },
  {
    "Name": "FXRSTOR",
    "Brief": "Restore x87 FPU, MMX, XMM, and MXCSR register state from memory",
    "Description": "\nReloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating modes.\n\nKey points about FXRSTOR:\n- The first byte of the data should be located on a 16-byte boundary\n- There are three distinct layouts of the FXSAVE state map:\n  1. Legacy and compatibility mode\n  2. 64-bit mode with REX.W=0\n  3. 64-bit mode with REX.W=1 (FXSAVE64/FXRSTOR64)\n\nThe state image must have been saved using an FXSAVE instruction or be in the same compatible format. Referencing an incompatible state image will result in incorrect state restoration.\n\nAdditional notes:\n- FXRSTOR does not flush pending x87 FPU exceptions\n- To check and raise exceptions, use an FWAIT instruction after FXRSTOR\n- If OSFXSR bit in CR4 is not set, XMM and MXCSR registers may not be restored\n- Bits 16-32 of MXCSR are reserved and must be set to 0\n- Bytes 464:511 of an FXSAVE image are available for software use and are ignored by FXRSTOR\n",
    "Alias": []
  },
  {
    "Name": "FXRSTOR64",
    "Brief": "Restore x87 FPU, MMX, XMM, and MXCSR register state from memory in 64-bit mode",
    "Description": "\nReloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating modes.\n\nKey points about FXRSTOR:\n- The first byte of the data should be located on a 16-byte boundary\n- There are three distinct layouts of the FXSAVE state map:\n  1. Legacy and compatibility mode\n  2. 64-bit mode with REX.W=0\n  3. 64-bit mode with REX.W=1 (FXSAVE64/FXRSTOR64)\n\nThe state image must have been saved using an FXSAVE instruction or be in the same compatible format. Referencing an incompatible state image will result in incorrect state restoration.\n\nAdditional notes:\n- FXRSTOR does not flush pending x87 FPU exceptions\n- To check and raise exceptions, use an FWAIT instruction after FXRSTOR\n- If OSFXSR bit in CR4 is not set, XMM and MXCSR registers may not be restored\n- Bits 16-32 of MXCSR are reserved and must be set to 0\n- Bytes 464:511 of an FXSAVE image are available for software use and are ignored by FXRSTOR\n",
    "Alias": []
  },
  {
    "Name": "FXSAVE",
    "Brief": "Save the x87 FPU, MMX, XMM, and MXCSR register state to memory",
    "Description": "\nSaves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location specified in the destination operand. The content layout of the 512 byte region depends on whether the processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.\n\nBytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.\n\nIn non-64-bit modes, the destination operand contains the first byte of the memory image, and it must be aligned on a 16-byte boundary. A misaligned destination operand will result in a general-protection (#GP) exception.\n\nThe FXSAVE instruction is used when an operating system needs to perform a context switch or when an exception handler needs to save and examine the current state of the x87 FPU, MMX technology, and/or XMM and MXCSR registers.\n\nIn 64-bit mode, there are two different layouts:\n1. FXSAVE64 (REX.W=1): 64-bit FPU IP and DP pointers\n2. FXSAVE (REX.W=0): 32-bit FPU IP and DP pointers\n\nThe instruction saves an abridged version of the x87 FPU tag word, saving only a single bit (1 for valid or 0 for empty) for each tag in physical register order.\n\nKey differences from FSAVE instruction:\n- Does not check for pending unmasked floating-point exceptions\n- Retains the contents of the registers after saving\n- Has a consistent memory image format across different modes\n",
    "Alias": []
  },
  {
    "Name": "FXSAVE64",
    "Brief": "Save the x87 FPU, MMX, XMM, and MXCSR register state to memory in 64-bit mode with 64-bit pointers",
    "Description": "\nSaves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location specified in the destination operand. The content layout of the 512 byte region depends on whether the processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.\n\nBytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.\n\nIn non-64-bit modes, the destination operand contains the first byte of the memory image, and it must be aligned on a 16-byte boundary. A misaligned destination operand will result in a general-protection (#GP) exception.\n\nThe FXSAVE instruction is used when an operating system needs to perform a context switch or when an exception handler needs to save and examine the current state of the x87 FPU, MMX technology, and/or XMM and MXCSR registers.\n\nIn 64-bit mode, there are two different layouts:\n1. FXSAVE64 (REX.W=1): 64-bit FPU IP and DP pointers\n2. FXSAVE (REX.W=0): 32-bit FPU IP and DP pointers\n\nThe instruction saves an abridged version of the x87 FPU tag word, saving only a single bit (1 for valid or 0 for empty) for each tag in physical register order.\n\nKey differences from FSAVE instruction:\n- Does not check for pending unmasked floating-point exceptions\n- Retains the contents of the registers after saving\n- Has a consistent memory image format across different modes\n",
    "Alias": []
  },
  {
    "Name": "FXTRACT",
    "Brief": "Extract exponent and significand from a floating-point value",
    "Description": "\nSeparates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0), and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0) contains the value of the original significand expressed as a floating-point value. The sign and significand of this value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true exponent of zero). The ST(1) register contains the value of the original operand's true (unbiased) exponent expressed as a floating-point value.\n\nThis instruction is useful for performing power and range scaling operations and for converting numbers in double extended-precision floating-point format to decimal representations (e.g., for printing or displaying).\n\nIf the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of –∞ is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).\n",
    "Alias": []
  },
  {
    "Name": "FYL2X",
    "Brief": "Compute y * log2(x)",
    "Description": "\nComputes (ST(1) * log2(ST(0))), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number.\n\nThe FYL2X instruction is designed with a built-in multiplication to optimize the calculation of logarithms with an arbitrary positive base (b):\n\nlog_b(x) := (log2(b))^-1 * log2(x)\n\nKey points:\n- Requires ST(0) to be a non-zero positive number\n- Multiplies ST(1) by the base-2 logarithm of ST(0)\n- Stores the result in ST(1)\n- Pops the register stack after computation\n\nSpecial cases:\n- If ST(0) is ±0, a divide-by-zero exception occurs\n- If ST(0) is a negative finite value, an invalid operation exception is generated\n- The result sign and behavior depend on the input values, as shown in the detailed result table\n\nThis instruction provides an efficient way to calculate logarithms of different bases by leveraging the built-in multiplication.\n",
    "Alias": []
  },
  {
    "Name": "FYL2XP1",
    "Brief": "Compute y * log2(x + 1)",
    "Description": "\nComputes (ST(1) * log2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be in the range −(1−(2/2)) to (1−(2/2)).\n\nThe source operand in ST(1) can range from −∞ to +∞. If the ST(0) operand is outside of its acceptable range, the result is undefined and software should not rely on an exception being generated.\n\nThis instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. For small epsilon (ε) values, more significant digits can be retained by using the FYL2XP1 instruction than by using (ε+1) as an argument to the FYL2X instruction.\n\nThe result can be converted into a value in another logarithm base by including a scale factor in the ST(1) source operand. The scale factor is calculated using the equation: scale factor := log_n(2), where n is the desired logarithm base.\n\nThe instruction's operation is the same in both non-64-bit and 64-bit modes.\n",
    "Alias": []
  },
  {
    "Name": "GF2P8AFFINEINVQB",
    "Brief": "Compute inverse affine transformation in the finite field GF(2^8)",
    "Description": "\nThe AFFINEINVB instruction computes an affine transformation in the Galois Field 2^8. For this instruction, an affine transformation is defined by A * inv(x) + b where \"A\" is an 8 by 8 bit matrix, and \"x\" and \"b\" are 8-bit vectors. The inverse of the bytes in x is defined with respect to the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n\nOne SIMD register (operand 1) holds \"x\" as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 \"A\" values, which are operated upon by the correspondingly aligned 8 \"x\" values in the first register. The \"b\" vector is constant for all calculations and contained in the immediate byte.\n\nThe EVEX encoded form of this instruction does not support memory fault suppression. The SSE encoded forms of the instruction require 16B alignment on their memory operations.\n\nThe instruction performs the following steps for each byte:\n1. Compute the inverse of the byte using a predefined lookup table\n2. Multiply the inverse with a matrix A\n3. Apply a constant vector b\n4. Return the resulting byte\n\nThe instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and can use write masks for selective computation.\n",
    "Alias": []
  },
  {
    "Name": "VGFP8AFFINEINVQB",
    "Brief": "Compute inverse affine transformation in the finite field GF(2^8) with vector registers",
    "Description": "\nThe AFFINEINVB instruction computes an affine transformation in the Galois Field 2^8. For this instruction, an affine transformation is defined by A * inv(x) + b where \"A\" is an 8 by 8 bit matrix, and \"x\" and \"b\" are 8-bit vectors. The inverse of the bytes in x is defined with respect to the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n\nOne SIMD register (operand 1) holds \"x\" as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 \"A\" values, which are operated upon by the correspondingly aligned 8 \"x\" values in the first register. The \"b\" vector is constant for all calculations and contained in the immediate byte.\n\nThe EVEX encoded form of this instruction does not support memory fault suppression. The SSE encoded forms of the instruction require 16B alignment on their memory operations.\n\nThe instruction performs the following steps for each byte:\n1. Compute the inverse of the byte using a predefined lookup table\n2. Multiply the inverse with a matrix A\n3. Apply a constant vector b\n4. Return the resulting byte\n\nThe instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and can use write masks for selective computation.\n",
    "Alias": []
  },
  {
    "Name": "GF2P8AFFINEQB",
    "Brief": "Compute an affine transformation in the Galois Field 2^8",
    "Description": "\nThe AFFINEB instruction computes an affine transformation in the Galois Field 2^8. For this instruction, an affine transformation is defined by A * x + b where \"A\" is an 8 by 8 bit matrix, and \"x\" and \"b\" are 8-bit vectors. One SIMD register (operand 1) holds \"x\" as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 \"A\" values, which are operated upon by the correspondingly aligned 8 \"x\" values in the first register. The \"b\" vector is constant for all calculations and contained in the immediate byte.\n\nThe computation involves:\n1. Performing parity checks on bitwise AND operations\n2. XORing the parity results with the immediate byte\n3. Generating a transformed 8-bit byte result\n\nThe EVEX encoded form of this instruction does not support memory fault suppression. The SSE encoded forms of the instruction require 16B alignment on their memory operations.\n\nVariants exist for different register sizes (XMM, YMM, ZMM) and support different encoding methods (SSE, VEX, EVEX) with optional masking and broadcasting capabilities.\n",
    "Alias": []
  },
  {
    "Name": "VGFP8AFFINEQB",
    "Brief": "Compute an affine transformation in the Galois Field 2^8 with vector support",
    "Description": "\nThe AFFINEB instruction computes an affine transformation in the Galois Field 2^8. For this instruction, an affine transformation is defined by A * x + b where \"A\" is an 8 by 8 bit matrix, and \"x\" and \"b\" are 8-bit vectors. One SIMD register (operand 1) holds \"x\" as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 \"A\" values, which are operated upon by the correspondingly aligned 8 \"x\" values in the first register. The \"b\" vector is constant for all calculations and contained in the immediate byte.\n\nThe computation involves:\n1. Performing parity checks on bitwise AND operations\n2. XORing the parity results with the immediate byte\n3. Generating a transformed 8-bit byte result\n\nThe EVEX encoded form of this instruction does not support memory fault suppression. The SSE encoded forms of the instruction require 16B alignment on their memory operations.\n\nVariants exist for different register sizes (XMM, YMM, ZMM) and support different encoding methods (SSE, VEX, EVEX) with optional masking and broadcasting capabilities.\n",
    "Alias": []
  },
  {
    "Name": "GF2P8MULB",
    "Brief": "Multiplies elements in the finite field GF(2^8)",
    "Description": "\nThe instruction multiplies elements in the finite field GF(2^8), operating on a byte (field element) in the first source operand and the corresponding byte in a second source operand. The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n\nThis instruction does not support broadcasting.\n\nThe EVEX encoded form of this instruction supports memory fault suppression. The SSE encoded forms of the instruction require 16B alignment on their memory operations.\n\nThe multiplication is performed byte by byte, where each byte is treated as an element in the Galois Field GF(2^8). The multiplication follows a specific algorithm that includes polynomial multiplication and reduction using the characteristic polynomial 0x11B (x^8 + x^4 + x^3 + x + 1).\n\nVariants of the instruction exist for different vector lengths:\n- SSE version operates on 128-bit registers\n- VEX versions support 128-bit and 256-bit registers\n- EVEX versions support 128-bit, 256-bit, and 512-bit registers, with optional write masking\n",
    "Alias": []
  },
  {
    "Name": "VGF2P8MULB",
    "Brief": "Multiplies elements in the finite field GF(2^8) with vector support",
    "Description": "\nThe instruction multiplies elements in the finite field GF(2^8), operating on a byte (field element) in the first source operand and the corresponding byte in a second source operand. The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n\nThis instruction does not support broadcasting.\n\nThe EVEX encoded form of this instruction supports memory fault suppression. The SSE encoded forms of the instruction require 16B alignment on their memory operations.\n\nThe multiplication is performed byte by byte, where each byte is treated as an element in the Galois Field GF(2^8). The multiplication follows a specific algorithm that includes polynomial multiplication and reduction using the characteristic polynomial 0x11B (x^8 + x^4 + x^3 + x + 1).\n\nVariants of the instruction exist for different vector lengths:\n- SSE version operates on 128-bit registers\n- VEX versions support 128-bit and 256-bit registers\n- EVEX versions support 128-bit, 256-bit, and 512-bit registers, with optional write masking\n",
    "Alias": []
  },
  {
    "Name": "HADDPD",
    "Brief": "Packed Double Precision Floating-Point Horizontal Add",
    "Description": "\nAdds the double precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand.\n\nAdds the double precision floating-point values in the high and low quadwords of the source operand and stores the result in the high quadword of the destination operand.\n\nIn the legacy SSE version (128-bit), the second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register, and the upper bits of the corresponding YMM register destination are unmodified.\n\nIn the VEX.128 encoded version, the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits of the corresponding YMM register destination are zeroed.\n\nIn the VEX.256 encoded version, the first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nThe instruction performs horizontal addition, meaning it adds adjacent pairs of floating-point values within the source operands and stores the results in the destination operand.\n",
    "Alias": []
  },
  {
    "Name": "VHADDPD",
    "Brief": "Packed Double Precision Floating-Point Horizontal Add (AVX version)",
    "Description": "\nAdds the double precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand.\n\nAdds the double precision floating-point values in the high and low quadwords of the source operand and stores the result in the high quadword of the destination operand.\n\nIn the legacy SSE version (128-bit), the second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register, and the upper bits of the corresponding YMM register destination are unmodified.\n\nIn the VEX.128 encoded version, the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits of the corresponding YMM register destination are zeroed.\n\nIn the VEX.256 encoded version, the first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nThe instruction performs horizontal addition, meaning it adds adjacent pairs of floating-point values within the source operands and stores the results in the destination operand.\n",
    "Alias": []
  },
  {
    "Name": "HADDPS",
    "Brief": "Packed Single Precision Floating-Point Horizontal Add",
    "Description": "\nAdds single precision floating-point values horizontally across packed registers. Specifically:\n\n1. Adds the first and second dwords of the destination operand and stores the result in the first dword of the destination operand.\n2. Adds the third and fourth dwords of the destination operand and stores the result in the second dword of the destination operand.\n3. Adds the first and second dwords of the source operand and stores the result in the third dword of the destination operand.\n4. Adds the third and fourth dwords of the source operand and stores the result in the fourth dword of the destination operand.\n\nThe instruction supports different versions:\n- 128-bit Legacy SSE version: The second source can be an XMM register or a 128-bit memory location.\n- VEX.128 encoded version: The first source is an XMM register or 128-bit memory location, and the upper bits of the destination are zeroed.\n- VEX.256 encoded version: Operates on 256-bit YMM registers, adding corresponding pairs of floating-point values.\n\nThe instruction can generate numeric exceptions such as overflow, underflow, invalid operation, precision, and denormal.\n",
    "Alias": []
  },
  {
    "Name": "HLT",
    "Brief": "Halt processor execution",
    "Description": "\nStops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer (CS:EIP) points to the instruction following the HLT instruction.\n\nWhen a HLT instruction is executed on an Intel 64 or IA-32 processor supporting Intel Hyper-Threading Technology, only the logical processor that executes the instruction is halted. The other logical processors in the physical processor remain active, unless they are each individually halted by executing a HLT instruction.\n\nThe HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode, the privilege level of a program or procedure must be 0 to execute the HLT instruction.\n",
    "Alias": []
  },
  {
    "Name": "HRESET",
    "Brief": "Selectively reset selected components of hardware history",
    "Description": "\nRequests the processor to selectively reset selected components of hardware history maintained by the current logical processor. HRESET operation is controlled by the implicit EAX operand. The value of the explicit imm8 operand is ignored. This instruction can only be executed at privilege level 0.\n\nThe HRESET instruction can be used to request reset of multiple components of hardware history. Prior to the execution of HRESET, the system software must take the following steps:\n\n1. Enumerate the HRESET capabilities via CPUID.20H.0H:EBX, which indicates what components of hardware history can be reset.\n\n2. Only the bits enumerated by CPUID.20H.0H:EBX can be set in the IA32_HRESET_ENABLE MSR.\n\nHRESET causes a general-protection exception (#GP) if EAX sets any bits that are not set in the IA32_HRESET_EN-ABLE MSR.\n\nAny attempt to execute the HRESET instruction inside a transactional region will result in a transaction abort.\n",
    "Alias": []
  },
  {
    "Name": "HSUBPD",
    "Brief": "Horizontal subtract packed double precision floating-point values",
    "Description": "\nThe HSUBPD instruction subtracts horizontally the packed double precision floating-point numbers of both operands.\n\nSubtracts the double precision floating-point value in the high quadword of the destination operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.\n\nSubtracts the double precision floating-point value in the high quadword of the source operand from the low quadword of the source operand and stores the result in the high quadword of the destination operand.\n\nIn 128-bit Legacy SSE version:\n- The second source can be an XMM register or a 128-bit memory location\n- The destination is not distinct from the first source XMM register\n- The upper bits of the corresponding YMM register destination are unmodified\n\nIn VEX.128 encoded version:\n- The first source operand is an XMM register or 128-bit memory location\n- The destination operand is an XMM register\n- The upper bits of the corresponding YMM register destination are zeroed\n\nIn VEX.256 encoded version:\n- The first source operand is a YMM register\n- The second source operand can be a YMM register or a 256-bit memory location\n- The destination operand is a YMM register\n\nThe instruction performs horizontal subtraction across the packed double precision floating-point values in the source operands.\n",
    "Alias": []
  },
  {
    "Name": "VHSUBPD",
    "Brief": "Horizontal subtract packed double precision floating-point values",
    "Description": "\nThe HSUBPD instruction subtracts horizontally the packed double precision floating-point numbers of both operands.\n\nSubtracts the double precision floating-point value in the high quadword of the destination operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.\n\nSubtracts the double precision floating-point value in the high quadword of the source operand from the low quadword of the source operand and stores the result in the high quadword of the destination operand.\n\nIn 128-bit Legacy SSE version:\n- The second source can be an XMM register or a 128-bit memory location\n- The destination is not distinct from the first source XMM register\n- The upper bits of the corresponding YMM register destination are unmodified\n\nIn VEX.128 encoded version:\n- The first source operand is an XMM register or 128-bit memory location\n- The destination operand is an XMM register\n- The upper bits of the corresponding YMM register destination are zeroed\n\nIn VEX.256 encoded version:\n- The first source operand is a YMM register\n- The second source operand can be a YMM register or a 256-bit memory location\n- The destination operand is a YMM register\n\nThe instruction performs horizontal subtraction across the packed double precision floating-point values in the source operands.\n",
    "Alias": []
  },
  {
    "Name": "HSUBPS",
    "Brief": "Packed Single Precision Floating-Point Horizontal Subtract",
    "Description": "\nThe HSUBPS and VHSUBPS instructions perform horizontal subtraction of packed single precision floating-point values. The instructions subtract adjacent pairs of floating-point values within the source operands and store the results in the destination operand.\n\nFor the 128-bit version:\n- DEST[31:0] = SRC1[31:0] - SRC1[63:32]\n- DEST[63:32] = SRC1[95:64] - SRC1[127:96]\n- DEST[95:64] = SRC2[31:0] - SRC2[63:32]\n- DEST[127:96] = SRC2[95:64] - SRC2[127:96]\n\nFor the 256-bit VEX version, the operation is extended to process additional 128-bit lanes, performing similar horizontal subtractions across the larger register.\n\nKey variations:\n- 128-bit Legacy SSE version leaves upper bits of the destination register unmodified\n- VEX.128 version zeros the upper bits of the destination register\n- VEX.256 version processes a full 256-bit register\n\nThe instruction can operate on XMM or YMM registers, with the second source operand potentially being a memory location. Alignment of memory operands is required (16-byte boundary).\n\nNumeric exceptions can include overflow, underflow, invalid operation, precision, and denormal conditions.\n",
    "Alias": []
  },
  {
    "Name": "VHSUBPS",
    "Brief": "Vector Packed Single Precision Floating-Point Horizontal Subtract",
    "Description": "\nThe HSUBPS and VHSUBPS instructions perform horizontal subtraction of packed single precision floating-point values. The instructions subtract adjacent pairs of floating-point values within the source operands and store the results in the destination operand.\n\nFor the 128-bit version:\n- DEST[31:0] = SRC1[31:0] - SRC1[63:32]\n- DEST[63:32] = SRC1[95:64] - SRC1[127:96]\n- DEST[95:64] = SRC2[31:0] - SRC2[63:32]\n- DEST[127:96] = SRC2[95:64] - SRC2[127:96]\n\nFor the 256-bit VEX version, the operation is extended to process additional 128-bit lanes, performing similar horizontal subtractions across the larger register.\n\nKey variations:\n- 128-bit Legacy SSE version leaves upper bits of the destination register unmodified\n- VEX.128 version zeros the upper bits of the destination register\n- VEX.256 version processes a full 256-bit register\n\nThe instruction can operate on XMM or YMM registers, with the second source operand potentially being a memory location. Alignment of memory operands is required (16-byte boundary).\n\nNumeric exceptions can include overflow, underflow, invalid operation, precision, and denormal conditions.\n",
    "Alias": []
  },
  {
    "Name": "IDIV",
    "Brief": "Signed Divide",
    "Description": "\nDivides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor).\n\nNon-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the signed value in RDX:RAX by the source operand. RAX contains a 64-bit quotient; RDX contains a 64-bit remainder.\n\nThe instruction supports various operand sizes:\n- 8-bit: Divides AX by r/m8, result in AL (quotient), AH (remainder)\n- 16-bit: Divides DX:AX by r/m16, result in AX (quotient), DX (remainder)\n- 32-bit: Divides EDX:EAX by r/m32, result in EAX (quotient), EDX (remainder)\n- 64-bit: Divides RDX:RAX by r/m64, result in RAX (quotient), RDX (remainder)\n",
    "Alias": []
  },
  {
    "Name": "IMUL",
    "Brief": "Performs a signed multiplication of two operands",
    "Description": "\nPerforms a signed multiplication of two operands. This instruction has three forms, depending on the number of operands:\n\n1. One-operand form: The source operand is multiplied by the value in the AL, AX, EAX, or RAX register (depending on the operand size). The product (twice the size of the input operand) is stored in the AX, DX:AX, EDX:EAX, or RDX:RAX registers, respectively.\n\n2. Two-operand form: The destination operand is multiplied by the source operand. The destination operand is a general-purpose register, and the source operand can be an immediate value, a general-purpose register, or a memory location. The intermediate product is truncated and stored in the destination operand location.\n\n3. Three-operand form: Requires a destination operand and two source operands. The first source operand is multiplied by the second source operand (an immediate value). The intermediate product is truncated and stored in the destination operand.\n\nWhen an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\n\nThe CF and OF flags are set when the signed integer value of the intermediate product differs from the sign-extended operand-size-truncated product, otherwise the flags are cleared.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.W prefix promotes the operation to 64 bits, modifying the instruction's behavior for each form.\n",
    "Alias": []
  },
  {
    "Name": "IN",
    "Brief": "Input From Port",
    "Description": "\nCopies the value from the I/O port specified with the second operand (source operand) to the destination operand (first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively).\n\nUsing the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte immediate allows I/O port addresses 0 to 255 to be accessed.\n\nWhen accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port, the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.\n\nThis instruction is only useful for accessing I/O ports located in the processor's I/O address space. The instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nIn protected mode with CPL > IOPL or virtual-8086 mode, the instruction checks I/O permission bits before allowing the I/O operation. In real mode or protected mode with CPL ≤ IOPL, the I/O operation is directly performed.\n",
    "Alias": []
  },
  {
    "Name": "INC",
    "Brief": "Increment destination operand by 1 without affecting the CF flag",
    "Description": "\nAdds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (Use an ADD instruction with an immediate operand of 1 to perform an increment operation that updates the CF flag.)\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes). Otherwise, the instruction's 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nThe instruction supports incrementation of:\n- 8-bit byte registers/memory locations\n- 16-bit word registers/memory locations\n- 32-bit doubleword registers/memory locations\n- 64-bit quadword registers/memory locations (in 64-bit mode with REX.W prefix)\n\nThe CF flag is not affected, but the OF, SF, ZF, AF, and PF flags are set according to the result.\n",
    "Alias": []
  },
  {
    "Name": "INCSSPD",
    "Brief": "Increment Shadow Stack Pointer (32-bit)",
    "Description": "\nThis instruction can be used to increment the current shadow stack pointer by the operand size of the instruction times the unsigned 8-bit value specified by bits 7:0 in the source operand. \n\nThe instruction performs a pop and discard of the first and last element on the shadow stack in the range specified by the unsigned 8-bit value in bits 7:0 of the source operand.\n\nFor the 32-bit version (INCSSPD), the shadow stack pointer is incremented by 4 * r32[7:0].\nFor the 64-bit version (INCSSPQ), the shadow stack pointer is incremented by 8 * r64[7:0].\n\nThe instruction can only be used when Control Flow Enforcement Technology (CET) Shadow Stack is enabled:\n- In user mode (CPL = 3), IA32_U_CET.SH_STK_EN must be set\n- In kernel/supervisor mode (CPL < 3), IA32_S_CET.SH_STK_EN must be set\n\nIf these conditions are not met, an Undefined Instruction (#UD) exception is raised.\n",
    "Alias": []
  },
  {
    "Name": "INCSSPQ",
    "Brief": "Increment Shadow Stack Pointer (64-bit)",
    "Description": "\nThis instruction can be used to increment the current shadow stack pointer by the operand size of the instruction times the unsigned 8-bit value specified by bits 7:0 in the source operand. \n\nThe instruction performs a pop and discard of the first and last element on the shadow stack in the range specified by the unsigned 8-bit value in bits 7:0 of the source operand.\n\nFor the 32-bit version (INCSSPD), the shadow stack pointer is incremented by 4 * r32[7:0].\nFor the 64-bit version (INCSSPQ), the shadow stack pointer is incremented by 8 * r64[7:0].\n\nThe instruction can only be used when Control Flow Enforcement Technology (CET) Shadow Stack is enabled:\n- In user mode (CPL = 3), IA32_U_CET.SH_STK_EN must be set\n- In kernel/supervisor mode (CPL < 3), IA32_S_CET.SH_STK_EN must be set\n\nIf these conditions are not met, an Undefined Instruction (#UD) exception is raised.\n",
    "Alias": []
  },
  {
    "Name": "INS",
    "Brief": "Input from I/O port to memory",
    "Description": "\nCopies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively).\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source and destination operands to be specified explicitly, with the source operand always being \"DX\". The no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the INS instructions.\n\nAfter the byte, word, or doubleword is transferred from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.)\n\nThe INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords.\n\nThese instructions are only useful for accessing I/O ports located in the processor's I/O address space. In 64-bit mode, default address size is 64 bits, and 32-bit address size is supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "INSB",
    "Brief": "Input byte from I/O port to memory",
    "Description": "\nCopies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively).\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source and destination operands to be specified explicitly, with the source operand always being \"DX\". The no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the INS instructions.\n\nAfter the byte, word, or doubleword is transferred from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.)\n\nThe INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords.\n\nThese instructions are only useful for accessing I/O ports located in the processor's I/O address space. In 64-bit mode, default address size is 64 bits, and 32-bit address size is supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "INSW",
    "Brief": "Input word from I/O port to memory",
    "Description": "\nCopies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively).\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source and destination operands to be specified explicitly, with the source operand always being \"DX\". The no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the INS instructions.\n\nAfter the byte, word, or doubleword is transferred from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.)\n\nThe INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords.\n\nThese instructions are only useful for accessing I/O ports located in the processor's I/O address space. In 64-bit mode, default address size is 64 bits, and 32-bit address size is supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "INSD",
    "Brief": "Input doubleword from I/O port to memory",
    "Description": "\nCopies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively).\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source and destination operands to be specified explicitly, with the source operand always being \"DX\". The no-operands form provides \"short forms\" of the byte, word, and doubleword versions of the INS instructions.\n\nAfter the byte, word, or doubleword is transferred from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.)\n\nThe INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords.\n\nThese instructions are only useful for accessing I/O ports located in the processor's I/O address space. In 64-bit mode, default address size is 64 bits, and 32-bit address size is supported using the prefix 67H.\n",
    "Alias": []
  },
  {
    "Name": "INSERTPS",
    "Brief": "Insert a single precision floating-point value into a 128-bit vector register",
    "Description": "\nCopy a single precision scalar floating-point element into a 128-bit vector register. The immediate operand has three fields:\n- ZMask bits specify which elements of the destination will be set to zero\n- Count_D bits specify which element of the destination will be overwritten with the scalar value\n- Count_S bits specify which element of the source will be copied (ignored for memory source)\n\nWhen used with a memory source, the instruction loads a floating-point element from a 32-bit memory location and inserts it into the first source at the location indicated by the Count_D bits of the immediate operand.\n\nFor 128-bit Legacy SSE version:\n- First source register is an XMM register\n- Second source is an XMM register or 32-bit memory location\n- Destination is not distinct from the first source\n- Upper bits are unmodified\n\nFor VEX.128 and EVEX encoded versions:\n- Destination and first source is an XMM register\n- Second source is an XMM register or 32-bit memory location\n- Upper bits are zeroed\n- VEX.L = 1 will cause a #UD exception\n",
    "Alias": []
  },
  {
    "Name": "INT",
    "Brief": "Generate software interrupt with specified vector",
    "Description": "\nThe INT n instruction generates a call to the interrupt or exception handler specified with the destination operand. The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the Interrupt Descriptor Table (IDT).\n\nThe INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling the overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)\n\nThe INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP). This one-byte form is useful because it can replace the first byte of any instruction at which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.\n\nThe INT1 instruction uses a one-byte opcode (F1) and generates a debug exception (#DB) without setting any bits in DR6. Hardware vendors may use the INT1 instruction for hardware debug. Intel recommends software vendors instead use the INT3 instruction for software breakpoints.\n\nThe action of the INT n instruction is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed onto the stack before the return address. Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.\n\nIn protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In real-address mode, the IDT is an array of 4-byte far pointers, each of which point directly to a procedure in the selected segment.\n",
    "Alias": []
  },
  {
    "Name": "INTO",
    "Brief": "Generate overflow trap if overflow flag is 1",
    "Description": "\nThe INT n instruction generates a call to the interrupt or exception handler specified with the destination operand. The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the Interrupt Descriptor Table (IDT).\n\nThe INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling the overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)\n\nThe INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP). This one-byte form is useful because it can replace the first byte of any instruction at which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.\n\nThe INT1 instruction uses a one-byte opcode (F1) and generates a debug exception (#DB) without setting any bits in DR6. Hardware vendors may use the INT1 instruction for hardware debug. Intel recommends software vendors instead use the INT3 instruction for software breakpoints.\n\nThe action of the INT n instruction is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed onto the stack before the return address. Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.\n\nIn protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In real-address mode, the IDT is an array of 4-byte far pointers, each of which point directly to a procedure in the selected segment.\n",
    "Alias": []
  },
  {
    "Name": "INT3",
    "Brief": "Generate breakpoint trap",
    "Description": "\nThe INT n instruction generates a call to the interrupt or exception handler specified with the destination operand. The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the Interrupt Descriptor Table (IDT).\n\nThe INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling the overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)\n\nThe INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP). This one-byte form is useful because it can replace the first byte of any instruction at which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.\n\nThe INT1 instruction uses a one-byte opcode (F1) and generates a debug exception (#DB) without setting any bits in DR6. Hardware vendors may use the INT1 instruction for hardware debug. Intel recommends software vendors instead use the INT3 instruction for software breakpoints.\n\nThe action of the INT n instruction is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed onto the stack before the return address. Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.\n\nIn protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In real-address mode, the IDT is an array of 4-byte far pointers, each of which point directly to a procedure in the selected segment.\n",
    "Alias": []
  },
  {
    "Name": "INT1",
    "Brief": "Generate debug trap",
    "Description": "\nThe INT n instruction generates a call to the interrupt or exception handler specified with the destination operand. The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the Interrupt Descriptor Table (IDT).\n\nThe INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling the overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)\n\nThe INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP). This one-byte form is useful because it can replace the first byte of any instruction at which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.\n\nThe INT1 instruction uses a one-byte opcode (F1) and generates a debug exception (#DB) without setting any bits in DR6. Hardware vendors may use the INT1 instruction for hardware debug. Intel recommends software vendors instead use the INT3 instruction for software breakpoints.\n\nThe action of the INT n instruction is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed onto the stack before the return address. Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.\n\nIn protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In real-address mode, the IDT is an array of 4-byte far pointers, each of which point directly to a procedure in the selected segment.\n",
    "Alias": []
  },
  {
    "Name": "INVD",
    "Brief": "Invalidate Internal Caches",
    "Description": "\nInvalidates (flushes) the processor's internal caches and issues a special-function bus cycle that directs external caches to also flush themselves. Data held in internal caches is not written back to main memory.\n\nAfter executing this instruction, the processor does not wait for the external caches to complete their flushing operation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal.\n\nThe INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction.\n\nThe INVD instruction may be used when the cache is used as temporary memory and the cache contents need to be invalidated rather than written back to memory. When the cache is used as temporary memory, no external device should be actively writing data to main memory.\n\nUse this instruction with care. Data cached internally and not written back to main memory will be lost. Note that any data from an external device to main memory (for example, via a PCIWrite) can be temporarily stored in the caches; these data can be lost when an INVD instruction is executed. Unless there is a specific requirement or benefit to flushing caches without writing back modified cache lines (for example, temporary memory, testing, or fault recovery where cache coherency with main memory is not a concern), software should instead use the WBINVD instruction.\n\nOn processors that support processor reserved memory, the INVD instruction cannot be executed when processor reserved memory protections are activated. Some processors prevent execution of INVD after BIOS execution is complete.\n",
    "Alias": []
  },
  {
    "Name": "INVLPG",
    "Brief": "Invalidate Translation Lookaside Buffer (TLB) Entries for a specific page",
    "Description": "\nInvalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes all TLB entries for that page.\n\nThe INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL must be 0 to execute this instruction.\n\nThe INVLPG instruction normally flushes TLB entries only for the specified page; however, in some cases, it may flush more entries, even the entire TLB. The instruction invalidates TLB entries associated with the current PCID and may or may not do so for TLB entries associated with other PCIDs. (If PCIDs are disabled — CR4.PCIDE = 0 — the current PCID is 000H.) The instruction also invalidates any global TLB entries for the specified page, regardless of PCID.\n\nThis instruction's operation is the same in all non-64-bit modes. It also operates the same in 64-bit mode, except if the memory address is in non-canonical form. In this case, INVLPG is the same as a NOP.\n\nThe INVLPG instruction is implementation dependent, and its function may be implemented differently on different families of Intel 64 or IA-32 processors. This instruction is not supported on IA-32 processors earlier than the Intel486 processor.\n",
    "Alias": []
  },
  {
    "Name": "INVPCID",
    "Brief": "Invalidate Process-Context Identifier",
    "Description": "\nInvalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on process-context identifier (PCID). Invalidation is based on the INVPCID type specified in the register operand and the INVPCID descriptor specified in the memory operand.\n\nThere are four INVPCID types currently defined:\n\n1. Individual-address invalidation (Type 0): Invalidates mappings—except global translations—for the linear address and PCID specified in the INVPCID descriptor.\n\n2. Single-context invalidation (Type 1): Invalidates all mappings—except global translations—associated with the specified PCID.\n\n3. All-context invalidation, including global translations (Type 2): Invalidates all mappings—including global translations—associated with any PCID.\n\n4. All-context invalidation (Type 3): Invalidates all mappings—except global translations—associated with any PCID.\n\nThe INVPCID descriptor comprises 128 bits and consists of a PCID and a linear address. For individual-address invalidation (Type 0), the processor uses the full 64 bits of the linear address even outside 64-bit mode.\n\nIf CR4.PCIDE = 0, a logical processor does not cache information for any PCID other than 000H, with specific restrictions on allowed INVPCID types and PCIDs.\n",
    "Alias": []
  },
  {
    "Name": "IRET",
    "Brief": "Interrupt return (16-bit operand size)",
    "Description": "\nReturns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task.\n\nIRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.\n\nIn Real-Address Mode, the IRET instruction performs a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.\n\nIn Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs different types of interrupt returns, such as:\n- Return from virtual-8086 mode\n- Return to virtual-8086 mode\n- Intra-privilege level return\n- Inter-privilege level return\n- Return from nested task (task switch)\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.W prefix promotes operation to 64 bits (IRETQ).\n\nIRET is a serializing instruction, meaning it ensures that all previous instructions are completed before the interrupt return is executed.\n",
    "Alias": []
  },
  {
    "Name": "IRETD",
    "Brief": "Interrupt return (32-bit operand size)",
    "Description": "\nReturns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task.\n\nIRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.\n\nIn Real-Address Mode, the IRET instruction performs a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.\n\nIn Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs different types of interrupt returns, such as:\n- Return from virtual-8086 mode\n- Return to virtual-8086 mode\n- Intra-privilege level return\n- Inter-privilege level return\n- Return from nested task (task switch)\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.W prefix promotes operation to 64 bits (IRETQ).\n\nIRET is a serializing instruction, meaning it ensures that all previous instructions are completed before the interrupt return is executed.\n",
    "Alias": []
  },
  {
    "Name": "IRETQ",
    "Brief": "Interrupt return (64-bit operand size)",
    "Description": "\nReturns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task.\n\nIRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.\n\nIn Real-Address Mode, the IRET instruction performs a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.\n\nIn Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs different types of interrupt returns, such as:\n- Return from virtual-8086 mode\n- Return to virtual-8086 mode\n- Intra-privilege level return\n- Inter-privilege level return\n- Return from nested task (task switch)\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.W prefix promotes operation to 64 bits (IRETQ).\n\nIRET is a serializing instruction, meaning it ensures that all previous instructions are completed before the interrupt return is executed.\n",
    "Alias": []
  },
  {
    "Name": "JMP",
    "Brief": "Transfer program control to a different point in the instruction stream",
    "Description": "\nTransfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.\n\nThis instruction can be used to execute four different types of jumps:\n1. Near jump - A jump to an instruction within the current code segment\n2. Short jump - A near jump where the jump range is limited to –128 to +127 from the current EIP value\n3. Far jump - A jump to an instruction located in a different segment than the current code segment\n4. Task switch - A jump to an instruction located in a different task\n\nNear and Short Jumps:\n- Jumps to an address within the current code segment\n- Can use relative or absolute offsets\n- The CS register is not changed\n\nFar Jumps:\n- Can be performed in real-address, virtual-8086, or protected mode\n- Can involve jumping to a different code segment\n- Can include task switching\n\nIn 64-bit mode:\n- Instruction operation size is fixed at 64 bits\n- If a selector points to a gate, RIP equals the 64-bit displacement from the gate\n- Otherwise, RIP equals the zero-extended offset from the far pointer\n\nSpecial considerations:\n- Can include speculative execution blocking\n- Supports various segment and privilege level checks\n- Can involve complex segment descriptor and gate handling\n",
    "Alias": []
  },
  {
    "Name": "JA",
    "Brief": "Jump short if above (CF=0 and ZF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JAE",
    "Brief": "Jump short if above or equal (CF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JB",
    "Brief": "Jump short if below (CF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JBE",
    "Brief": "Jump short if below or equal (CF=1 or ZF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JC",
    "Brief": "Jump short if carry (CF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JCXZ",
    "Brief": "Jump short if CX register is 0",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JECXZ",
    "Brief": "Jump short if ECX register is 0",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JRCXZ",
    "Brief": "Jump short if RCX register is 0",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JE",
    "Brief": "Jump short if equal (ZF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JG",
    "Brief": "Jump short if greater (ZF=0 and SF=OF)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JGE",
    "Brief": "Jump short if greater or equal (SF=OF)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JL",
    "Brief": "Jump short if less (SF≠ OF)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JLE",
    "Brief": "Jump short if less or equal (ZF=1 or SF≠ OF)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNA",
    "Brief": "Jump short if not above (CF=1 or ZF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNAE",
    "Brief": "Jump short if not above or equal (CF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNB",
    "Brief": "Jump short if not below (CF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNBE",
    "Brief": "Jump short if not below or equal (CF=0 and ZF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNC",
    "Brief": "Jump short if not carry (CF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNE",
    "Brief": "Jump short if not equal (ZF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNG",
    "Brief": "Jump short if not greater (ZF=1 or SF≠ OF)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNGE",
    "Brief": "Jump short if not greater or equal (SF≠ OF)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNL",
    "Brief": "Jump short if not less (SF=OF)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNLE",
    "Brief": "Jump short if not less or equal (ZF=0 and SF=OF)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNO",
    "Brief": "Jump short if not overflow (OF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNP",
    "Brief": "Jump short if not parity (PF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNS",
    "Brief": "Jump short if not sign (SF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JNZ",
    "Brief": "Jump short if not zero (ZF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JO",
    "Brief": "Jump short if overflow (OF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JP",
    "Brief": "Jump short if parity (PF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JPE",
    "Brief": "Jump short if parity even (PF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JPO",
    "Brief": "Jump short if parity odd (PF=0)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JS",
    "Brief": "Jump short if sign (SF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "JZ",
    "Brief": "Jump short if zero (ZF=1)",
    "Description": "\nConditional jump instructions check the state of one or more status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), perform a jump to the target instruction specified by the destination operand.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer). The conditions for each Jcc mnemonic are given in the \"Description\" column of the table. The terms \"less\" and \"greater\" are used for comparisons of signed integers, while \"above\" and \"below\" are used for unsigned integers.\n\nThe JRCXZ, JECXZ, and JCXZ instructions are unique as they check RCX, ECX, or CX for 0 instead of checking status flags. They are useful at the beginning of loops to prevent execution when the counter register is 0.\n\nIn 64-bit mode, the operand size is fixed at 64 bits, with short jumps using an 8-bit offset sign-extended to 64 bits, and near jumps using a 32-bit offset sign-extended to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "KADDW",
    "Brief": "Add 16-bit masks and place result in destination mask",
    "Description": "\nAdds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1. Each variant of the instruction operates on masks of different bit widths:\n\n- KADDW adds 16-bit masks\n- KADDB adds 8-bit masks\n- KADDQ adds 64-bit masks\n- KADDD adds 32-bit masks\n\nThe operation works by adding the source masks bitwise and storing the result in the destination mask. The higher bits of the destination mask are zeroed out after the addition.\n\nThese instructions are part of the AVX512 instruction set and are used for mask register manipulation. They are supported in both 32-bit and 64-bit modes and require specific CPUID feature flags (AVX512DQ or AVX512BW depending on the variant).\n",
    "Alias": []
  },
  {
    "Name": "KADDB",
    "Brief": "Add 8-bit masks and place result in destination mask",
    "Description": "\nAdds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1. Each variant of the instruction operates on masks of different bit widths:\n\n- KADDW adds 16-bit masks\n- KADDB adds 8-bit masks\n- KADDQ adds 64-bit masks\n- KADDD adds 32-bit masks\n\nThe operation works by adding the source masks bitwise and storing the result in the destination mask. The higher bits of the destination mask are zeroed out after the addition.\n\nThese instructions are part of the AVX512 instruction set and are used for mask register manipulation. They are supported in both 32-bit and 64-bit modes and require specific CPUID feature flags (AVX512DQ or AVX512BW depending on the variant).\n",
    "Alias": []
  },
  {
    "Name": "KADDQ",
    "Brief": "Add 64-bit masks and place result in destination mask",
    "Description": "\nAdds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1. Each variant of the instruction operates on masks of different bit widths:\n\n- KADDW adds 16-bit masks\n- KADDB adds 8-bit masks\n- KADDQ adds 64-bit masks\n- KADDD adds 32-bit masks\n\nThe operation works by adding the source masks bitwise and storing the result in the destination mask. The higher bits of the destination mask are zeroed out after the addition.\n\nThese instructions are part of the AVX512 instruction set and are used for mask register manipulation. They are supported in both 32-bit and 64-bit modes and require specific CPUID feature flags (AVX512DQ or AVX512BW depending on the variant).\n",
    "Alias": []
  },
  {
    "Name": "KADDD",
    "Brief": "Add 32-bit masks and place result in destination mask",
    "Description": "\nAdds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1. Each variant of the instruction operates on masks of different bit widths:\n\n- KADDW adds 16-bit masks\n- KADDB adds 8-bit masks\n- KADDQ adds 64-bit masks\n- KADDD adds 32-bit masks\n\nThe operation works by adding the source masks bitwise and storing the result in the destination mask. The higher bits of the destination mask are zeroed out after the addition.\n\nThese instructions are part of the AVX512 instruction set and are used for mask register manipulation. They are supported in both 32-bit and 64-bit modes and require specific CPUID feature flags (AVX512DQ or AVX512BW depending on the variant).\n",
    "Alias": []
  },
  {
    "Name": "KANDW",
    "Brief": "Bitwise AND 16-bit masks",
    "Description": "\nPerforms a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.\n\nEach instruction variant operates on a different mask size:\n- KANDW operates on 16-bit masks\n- KANDB operates on 8-bit masks\n- KANDQ operates on 64-bit masks\n- KANDD operates on 32-bit masks\n\nThe operation is performed by doing a bitwise AND between the source masks and storing the result in the destination mask. Any bits beyond the specified mask size are zeroed out.\n",
    "Alias": []
  },
  {
    "Name": "KANDB",
    "Brief": "Bitwise AND 8-bit masks",
    "Description": "\nPerforms a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.\n\nEach instruction variant operates on a different mask size:\n- KANDW operates on 16-bit masks\n- KANDB operates on 8-bit masks\n- KANDQ operates on 64-bit masks\n- KANDD operates on 32-bit masks\n\nThe operation is performed by doing a bitwise AND between the source masks and storing the result in the destination mask. Any bits beyond the specified mask size are zeroed out.\n",
    "Alias": []
  },
  {
    "Name": "KANDQ",
    "Brief": "Bitwise AND 64-bit masks",
    "Description": "\nPerforms a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.\n\nEach instruction variant operates on a different mask size:\n- KANDW operates on 16-bit masks\n- KANDB operates on 8-bit masks\n- KANDQ operates on 64-bit masks\n- KANDD operates on 32-bit masks\n\nThe operation is performed by doing a bitwise AND between the source masks and storing the result in the destination mask. Any bits beyond the specified mask size are zeroed out.\n",
    "Alias": []
  },
  {
    "Name": "KANDD",
    "Brief": "Bitwise AND 32-bit masks",
    "Description": "\nPerforms a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.\n\nEach instruction variant operates on a different mask size:\n- KANDW operates on 16-bit masks\n- KANDB operates on 8-bit masks\n- KANDQ operates on 64-bit masks\n- KANDD operates on 32-bit masks\n\nThe operation is performed by doing a bitwise AND between the source masks and storing the result in the destination mask. Any bits beyond the specified mask size are zeroed out.\n",
    "Alias": []
  },
  {
    "Name": "KANDNW",
    "Brief": "Bitwise AND NOT 16-bit masks",
    "Description": "\nPerforms a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.\n\nEach variant of the instruction operates on different bit widths:\n- KANDNW operates on 16-bit masks\n- KANDNB operates on 8-bit masks\n- KANDNQ operates on 64-bit masks\n- KANDND operates on 32-bit masks\n\nThe operation first performs a bitwise NOT on the first source mask (k2), then performs a bitwise AND with the second source mask (k3), and stores the result in the destination mask (k1). Any bits beyond the specified width are set to zero.\n\nThese instructions are part of the AVX512 instruction set and are used for manipulating mask registers in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KANDNB",
    "Brief": "Bitwise AND NOT 8-bit masks",
    "Description": "\nPerforms a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.\n\nEach variant of the instruction operates on different bit widths:\n- KANDNW operates on 16-bit masks\n- KANDNB operates on 8-bit masks\n- KANDNQ operates on 64-bit masks\n- KANDND operates on 32-bit masks\n\nThe operation first performs a bitwise NOT on the first source mask (k2), then performs a bitwise AND with the second source mask (k3), and stores the result in the destination mask (k1). Any bits beyond the specified width are set to zero.\n\nThese instructions are part of the AVX512 instruction set and are used for manipulating mask registers in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KANDNQ",
    "Brief": "Bitwise AND NOT 64-bit masks",
    "Description": "\nPerforms a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.\n\nEach variant of the instruction operates on different bit widths:\n- KANDNW operates on 16-bit masks\n- KANDNB operates on 8-bit masks\n- KANDNQ operates on 64-bit masks\n- KANDND operates on 32-bit masks\n\nThe operation first performs a bitwise NOT on the first source mask (k2), then performs a bitwise AND with the second source mask (k3), and stores the result in the destination mask (k1). Any bits beyond the specified width are set to zero.\n\nThese instructions are part of the AVX512 instruction set and are used for manipulating mask registers in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KANDND",
    "Brief": "Bitwise AND NOT 32-bit masks",
    "Description": "\nPerforms a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.\n\nEach variant of the instruction operates on different bit widths:\n- KANDNW operates on 16-bit masks\n- KANDNB operates on 8-bit masks\n- KANDNQ operates on 64-bit masks\n- KANDND operates on 32-bit masks\n\nThe operation first performs a bitwise NOT on the first source mask (k2), then performs a bitwise AND with the second source mask (k3), and stores the result in the destination mask (k1). Any bits beyond the specified width are set to zero.\n\nThese instructions are part of the AVX512 instruction set and are used for manipulating mask registers in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KMOVW",
    "Brief": "Move 16-bit mask between registers, memory, or general-purpose registers",
    "Description": "\nCopies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.\n\nWhen moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination's size is 32 bits. In 64-bit mode, the default GPR destination's size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.\n\nThe different variants (KMOVW, KMOVB, KMOVQ, KMOVD) support moving masks of different sizes:\n- KMOVW: 16-bit masks\n- KMOVB: 8-bit masks\n- KMOVQ: 64-bit masks\n- KMOVD: 32-bit masks\n\nEach variant follows a similar pattern of zero-extending the source to the destination when moving to a mask register or general-purpose register.\n",
    "Alias": []
  },
  {
    "Name": "KMOVB",
    "Brief": "Move 8-bit mask between registers, memory, or general-purpose registers",
    "Description": "\nCopies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.\n\nWhen moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination's size is 32 bits. In 64-bit mode, the default GPR destination's size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.\n\nThe different variants (KMOVW, KMOVB, KMOVQ, KMOVD) support moving masks of different sizes:\n- KMOVW: 16-bit masks\n- KMOVB: 8-bit masks\n- KMOVQ: 64-bit masks\n- KMOVD: 32-bit masks\n\nEach variant follows a similar pattern of zero-extending the source to the destination when moving to a mask register or general-purpose register.\n",
    "Alias": []
  },
  {
    "Name": "KMOVQ",
    "Brief": "Move 64-bit mask between registers, memory, or general-purpose registers",
    "Description": "\nCopies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.\n\nWhen moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination's size is 32 bits. In 64-bit mode, the default GPR destination's size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.\n\nThe different variants (KMOVW, KMOVB, KMOVQ, KMOVD) support moving masks of different sizes:\n- KMOVW: 16-bit masks\n- KMOVB: 8-bit masks\n- KMOVQ: 64-bit masks\n- KMOVD: 32-bit masks\n\nEach variant follows a similar pattern of zero-extending the source to the destination when moving to a mask register or general-purpose register.\n",
    "Alias": []
  },
  {
    "Name": "KMOVD",
    "Brief": "Move 32-bit mask between registers, memory, or general-purpose registers",
    "Description": "\nCopies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.\n\nWhen moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination's size is 32 bits. In 64-bit mode, the default GPR destination's size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.\n\nThe different variants (KMOVW, KMOVB, KMOVQ, KMOVD) support moving masks of different sizes:\n- KMOVW: 16-bit masks\n- KMOVB: 8-bit masks\n- KMOVQ: 64-bit masks\n- KMOVD: 32-bit masks\n\nEach variant follows a similar pattern of zero-extending the source to the destination when moving to a mask register or general-purpose register.\n",
    "Alias": []
  },
  {
    "Name": "KNOTW",
    "Brief": "Bitwise NOT of 16 bits mask",
    "Description": "\nPerforms a bitwise NOT of vector mask k2 and writes the result into vector mask k1.\n\nThe instructions differ in the size of the mask they operate on:\n- KNOTW operates on 16-bit masks\n- KNOTB operates on 8-bit masks\n- KNOTQ operates on 64-bit masks\n- KNOTD operates on 32-bit masks\n\nEach instruction performs a bitwise NOT operation on the source mask and stores the result in the destination mask. Any bits beyond the mask's specified width are set to zero.\n\nThese instructions are part of the AVX512 instruction set and are used for mask register manipulation in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KNOTB",
    "Brief": "Bitwise NOT of 8 bits mask",
    "Description": "\nPerforms a bitwise NOT of vector mask k2 and writes the result into vector mask k1.\n\nThe instructions differ in the size of the mask they operate on:\n- KNOTW operates on 16-bit masks\n- KNOTB operates on 8-bit masks\n- KNOTQ operates on 64-bit masks\n- KNOTD operates on 32-bit masks\n\nEach instruction performs a bitwise NOT operation on the source mask and stores the result in the destination mask. Any bits beyond the mask's specified width are set to zero.\n\nThese instructions are part of the AVX512 instruction set and are used for mask register manipulation in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KNOTQ",
    "Brief": "Bitwise NOT of 64 bits mask",
    "Description": "\nPerforms a bitwise NOT of vector mask k2 and writes the result into vector mask k1.\n\nThe instructions differ in the size of the mask they operate on:\n- KNOTW operates on 16-bit masks\n- KNOTB operates on 8-bit masks\n- KNOTQ operates on 64-bit masks\n- KNOTD operates on 32-bit masks\n\nEach instruction performs a bitwise NOT operation on the source mask and stores the result in the destination mask. Any bits beyond the mask's specified width are set to zero.\n\nThese instructions are part of the AVX512 instruction set and are used for mask register manipulation in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KNOTD",
    "Brief": "Bitwise NOT of 32 bits mask",
    "Description": "\nPerforms a bitwise NOT of vector mask k2 and writes the result into vector mask k1.\n\nThe instructions differ in the size of the mask they operate on:\n- KNOTW operates on 16-bit masks\n- KNOTB operates on 8-bit masks\n- KNOTQ operates on 64-bit masks\n- KNOTD operates on 32-bit masks\n\nEach instruction performs a bitwise NOT operation on the source mask and stores the result in the destination mask. Any bits beyond the mask's specified width are set to zero.\n\nThese instructions are part of the AVX512 instruction set and are used for mask register manipulation in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KORW",
    "Brief": "Bitwise OR 16-bit masks",
    "Description": "\nPerforms a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nEach variant of the instruction operates on different bit widths:\n- KORW: Performs bitwise OR on 16-bit masks\n- KORB: Performs bitwise OR on 8-bit masks\n- KORQ: Performs bitwise OR on 64-bit masks\n- KORD: Performs bitwise OR on 32-bit masks\n\nThe result is stored in the destination mask register, with any unused bits set to zero. These instructions are part of the AVX-512 instruction set and are used for manipulating mask registers in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KORB",
    "Brief": "Bitwise OR 8-bit masks",
    "Description": "\nPerforms a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nEach variant of the instruction operates on different bit widths:\n- KORW: Performs bitwise OR on 16-bit masks\n- KORB: Performs bitwise OR on 8-bit masks\n- KORQ: Performs bitwise OR on 64-bit masks\n- KORD: Performs bitwise OR on 32-bit masks\n\nThe result is stored in the destination mask register, with any unused bits set to zero. These instructions are part of the AVX-512 instruction set and are used for manipulating mask registers in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KORQ",
    "Brief": "Bitwise OR 64-bit masks",
    "Description": "\nPerforms a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nEach variant of the instruction operates on different bit widths:\n- KORW: Performs bitwise OR on 16-bit masks\n- KORB: Performs bitwise OR on 8-bit masks\n- KORQ: Performs bitwise OR on 64-bit masks\n- KORD: Performs bitwise OR on 32-bit masks\n\nThe result is stored in the destination mask register, with any unused bits set to zero. These instructions are part of the AVX-512 instruction set and are used for manipulating mask registers in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KORD",
    "Brief": "Bitwise OR 32-bit masks",
    "Description": "\nPerforms a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nEach variant of the instruction operates on different bit widths:\n- KORW: Performs bitwise OR on 16-bit masks\n- KORB: Performs bitwise OR on 8-bit masks\n- KORQ: Performs bitwise OR on 64-bit masks\n- KORD: Performs bitwise OR on 32-bit masks\n\nThe result is stored in the destination mask register, with any unused bits set to zero. These instructions are part of the AVX-512 instruction set and are used for manipulating mask registers in vector operations.\n",
    "Alias": []
  },
  {
    "Name": "KORTESTW",
    "Brief": "Bitwise OR 16-bit masks and update ZF and CF flags",
    "Description": "\nPerforms a bitwise OR between two vector mask registers and sets CF and ZF based on the operation result.\n\nThe ZF flag is set if both sources are 0x0. The CF flag is set if, after the OR operation is done, the operation result is all 1's.\n\nEach variant (W, B, Q, D) operates on different bit-width masks:\n- KORTESTW: 16-bit masks\n- KORTESTB: 8-bit masks\n- KORTESTQ: 64-bit masks\n- KORTESTD: 32-bit masks\n\nThe flags are set as follows:\n- ZF (Zero Flag): Set to 1 if the bitwise OR result is zero\n- CF (Carry Flag): Set to 1 if the bitwise OR result is all 1's\n- OF, SF, AF, and PF flags are set to 0\n\nThese instructions are primarily used for mask register operations in AVX-512 instructions.\n",
    "Alias": []
  },
  {
    "Name": "KORTESTB",
    "Brief": "Bitwise OR 8-bit masks and update ZF and CF flags",
    "Description": "\nPerforms a bitwise OR between two vector mask registers and sets CF and ZF based on the operation result.\n\nThe ZF flag is set if both sources are 0x0. The CF flag is set if, after the OR operation is done, the operation result is all 1's.\n\nEach variant (W, B, Q, D) operates on different bit-width masks:\n- KORTESTW: 16-bit masks\n- KORTESTB: 8-bit masks\n- KORTESTQ: 64-bit masks\n- KORTESTD: 32-bit masks\n\nThe flags are set as follows:\n- ZF (Zero Flag): Set to 1 if the bitwise OR result is zero\n- CF (Carry Flag): Set to 1 if the bitwise OR result is all 1's\n- OF, SF, AF, and PF flags are set to 0\n\nThese instructions are primarily used for mask register operations in AVX-512 instructions.\n",
    "Alias": []
  },
  {
    "Name": "KORTESTQ",
    "Brief": "Bitwise OR 64-bit masks and update ZF and CF flags",
    "Description": "\nPerforms a bitwise OR between two vector mask registers and sets CF and ZF based on the operation result.\n\nThe ZF flag is set if both sources are 0x0. The CF flag is set if, after the OR operation is done, the operation result is all 1's.\n\nEach variant (W, B, Q, D) operates on different bit-width masks:\n- KORTESTW: 16-bit masks\n- KORTESTB: 8-bit masks\n- KORTESTQ: 64-bit masks\n- KORTESTD: 32-bit masks\n\nThe flags are set as follows:\n- ZF (Zero Flag): Set to 1 if the bitwise OR result is zero\n- CF (Carry Flag): Set to 1 if the bitwise OR result is all 1's\n- OF, SF, AF, and PF flags are set to 0\n\nThese instructions are primarily used for mask register operations in AVX-512 instructions.\n",
    "Alias": []
  },
  {
    "Name": "KORTESTD",
    "Brief": "Bitwise OR 32-bit masks and update ZF and CF flags",
    "Description": "\nPerforms a bitwise OR between two vector mask registers and sets CF and ZF based on the operation result.\n\nThe ZF flag is set if both sources are 0x0. The CF flag is set if, after the OR operation is done, the operation result is all 1's.\n\nEach variant (W, B, Q, D) operates on different bit-width masks:\n- KORTESTW: 16-bit masks\n- KORTESTB: 8-bit masks\n- KORTESTQ: 64-bit masks\n- KORTESTD: 32-bit masks\n\nThe flags are set as follows:\n- ZF (Zero Flag): Set to 1 if the bitwise OR result is zero\n- CF (Carry Flag): Set to 1 if the bitwise OR result is all 1's\n- OF, SF, AF, and PF flags are set to 0\n\nThese instructions are primarily used for mask register operations in AVX-512 instructions.\n",
    "Alias": []
  },
  {
    "Name": "KSHIFTLW",
    "Brief": "Shift left 16 bits in k2 by immediate and write result in k1",
    "Description": "\nShifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).\n\nEach instruction variant operates on a different bit width:\n- KSHIFTLW: 16-bit shift\n- KSHIFTLB: 8-bit shift\n- KSHIFTLQ: 64-bit shift\n- KSHIFTLD: 32-bit shift\n\nThe operation follows a consistent pattern:\n1. Take the count from the immediate byte\n2. Zero out the destination register\n3. If the count is within the valid range, shift the source left by the specified count\n4. Store the result in the destination register\n",
    "Alias": []
  },
  {
    "Name": "KSHIFTLB",
    "Brief": "Shift left 8 bits in k2 by immediate and write result in k1",
    "Description": "\nShifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).\n\nEach instruction variant operates on a different bit width:\n- KSHIFTLW: 16-bit shift\n- KSHIFTLB: 8-bit shift\n- KSHIFTLQ: 64-bit shift\n- KSHIFTLD: 32-bit shift\n\nThe operation follows a consistent pattern:\n1. Take the count from the immediate byte\n2. Zero out the destination register\n3. If the count is within the valid range, shift the source left by the specified count\n4. Store the result in the destination register\n",
    "Alias": []
  },
  {
    "Name": "KSHIFTLQ",
    "Brief": "Shift left 64 bits in k2 by immediate and write result in k1",
    "Description": "\nShifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).\n\nEach instruction variant operates on a different bit width:\n- KSHIFTLW: 16-bit shift\n- KSHIFTLB: 8-bit shift\n- KSHIFTLQ: 64-bit shift\n- KSHIFTLD: 32-bit shift\n\nThe operation follows a consistent pattern:\n1. Take the count from the immediate byte\n2. Zero out the destination register\n3. If the count is within the valid range, shift the source left by the specified count\n4. Store the result in the destination register\n",
    "Alias": []
  },
  {
    "Name": "KSHIFTLD",
    "Brief": "Shift left 32 bits in k2 by immediate and write result in k1",
    "Description": "\nShifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).\n\nEach instruction variant operates on a different bit width:\n- KSHIFTLW: 16-bit shift\n- KSHIFTLB: 8-bit shift\n- KSHIFTLQ: 64-bit shift\n- KSHIFTLD: 32-bit shift\n\nThe operation follows a consistent pattern:\n1. Take the count from the immediate byte\n2. Zero out the destination register\n3. If the count is within the valid range, shift the source left by the specified count\n4. Store the result in the destination register\n",
    "Alias": []
  },
  {
    "Name": "KSHIFTRW",
    "Brief": "Shift right 16 bits in k2 by immediate and write result in k1",
    "Description": "\nShifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. \n\nThe destination is set to zero if the count value is:\n- Greater than 7 for byte shift\n- Greater than 15 for word shift\n- Greater than 31 for doubleword shift\n- Greater than 63 for quadword shift\n\nEach variant of the instruction operates on a different bit-width:\n- KSHIFTRW shifts 16-bit mask registers\n- KSHIFTRB shifts 8-bit mask registers\n- KSHIFTRQ shifts 64-bit mask registers\n- KSHIFTRD shifts 32-bit mask registers\n",
    "Alias": []
  },
  {
    "Name": "KSHIFTRB",
    "Brief": "Shift right 8 bits in k2 by immediate and write result in k1",
    "Description": "\nShifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. \n\nThe destination is set to zero if the count value is:\n- Greater than 7 for byte shift\n- Greater than 15 for word shift\n- Greater than 31 for doubleword shift\n- Greater than 63 for quadword shift\n\nEach variant of the instruction operates on a different bit-width:\n- KSHIFTRW shifts 16-bit mask registers\n- KSHIFTRB shifts 8-bit mask registers\n- KSHIFTRQ shifts 64-bit mask registers\n- KSHIFTRD shifts 32-bit mask registers\n",
    "Alias": []
  },
  {
    "Name": "KSHIFTRQ",
    "Brief": "Shift right 64 bits in k2 by immediate and write result in k1",
    "Description": "\nShifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. \n\nThe destination is set to zero if the count value is:\n- Greater than 7 for byte shift\n- Greater than 15 for word shift\n- Greater than 31 for doubleword shift\n- Greater than 63 for quadword shift\n\nEach variant of the instruction operates on a different bit-width:\n- KSHIFTRW shifts 16-bit mask registers\n- KSHIFTRB shifts 8-bit mask registers\n- KSHIFTRQ shifts 64-bit mask registers\n- KSHIFTRD shifts 32-bit mask registers\n",
    "Alias": []
  },
  {
    "Name": "KSHIFTRD",
    "Brief": "Shift right 32 bits in k2 by immediate and write result in k1",
    "Description": "\nShifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. \n\nThe destination is set to zero if the count value is:\n- Greater than 7 for byte shift\n- Greater than 15 for word shift\n- Greater than 31 for doubleword shift\n- Greater than 63 for quadword shift\n\nEach variant of the instruction operates on a different bit-width:\n- KSHIFTRW shifts 16-bit mask registers\n- KSHIFTRB shifts 8-bit mask registers\n- KSHIFTRQ shifts 64-bit mask registers\n- KSHIFTRD shifts 32-bit mask registers\n",
    "Alias": []
  },
  {
    "Name": "KTESTW",
    "Brief": "Packed bit test for 16-bit mask registers",
    "Description": "\nPerforms a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. \n\nIf the AND operation produces all zeros, the Zero Flag (ZF) is set; otherwise, the ZF is cleared. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros, the Carry Flag (CF) is set; otherwise, the CF is cleared. \n\nOnly the EFLAGS register is updated. The instructions differ in the bit width of the mask registers they operate on:\n- KTESTW works on 16-bit mask registers\n- KTESTB works on 8-bit mask registers\n- KTESTQ works on 64-bit mask registers\n- KTESTD works on 32-bit mask registers\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise the instruction will generate an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "KTESTB",
    "Brief": "Packed bit test for 8-bit mask registers",
    "Description": "\nPerforms a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. \n\nIf the AND operation produces all zeros, the Zero Flag (ZF) is set; otherwise, the ZF is cleared. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros, the Carry Flag (CF) is set; otherwise, the CF is cleared. \n\nOnly the EFLAGS register is updated. The instructions differ in the bit width of the mask registers they operate on:\n- KTESTW works on 16-bit mask registers\n- KTESTB works on 8-bit mask registers\n- KTESTQ works on 64-bit mask registers\n- KTESTD works on 32-bit mask registers\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise the instruction will generate an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "KTESTQ",
    "Brief": "Packed bit test for 64-bit mask registers",
    "Description": "\nPerforms a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. \n\nIf the AND operation produces all zeros, the Zero Flag (ZF) is set; otherwise, the ZF is cleared. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros, the Carry Flag (CF) is set; otherwise, the CF is cleared. \n\nOnly the EFLAGS register is updated. The instructions differ in the bit width of the mask registers they operate on:\n- KTESTW works on 16-bit mask registers\n- KTESTB works on 8-bit mask registers\n- KTESTQ works on 64-bit mask registers\n- KTESTD works on 32-bit mask registers\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise the instruction will generate an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "KTESTD",
    "Brief": "Packed bit test for 32-bit mask registers",
    "Description": "\nPerforms a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. \n\nIf the AND operation produces all zeros, the Zero Flag (ZF) is set; otherwise, the ZF is cleared. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros, the Carry Flag (CF) is set; otherwise, the CF is cleared. \n\nOnly the EFLAGS register is updated. The instructions differ in the bit width of the mask registers they operate on:\n- KTESTW works on 16-bit mask registers\n- KTESTB works on 8-bit mask registers\n- KTESTQ works on 64-bit mask registers\n- KTESTD works on 32-bit mask registers\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise the instruction will generate an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "KUNPCKBW",
    "Brief": "Unpack 8-bit masks and write word result",
    "Description": "\nUnpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.\n\nFor KUNPCKBW:\n- Destination [7:0] = Source2 [7:0]\n- Destination [15:8] = Source1 [7:0]\n- Destination [MAX_KL-1:16] = 0\n\nFor KUNPCKWD:\n- Destination [15:0] = Source2 [15:0]\n- Destination [31:16] = Source1 [15:0]\n- Destination [MAX_KL-1:32] = 0\n\nFor KUNPCKDQ:\n- Destination [31:0] = Source2 [31:0]\n- Destination [63:32] = Source1 [31:0]\n- Destination [MAX_KL-1:64] = 0\n\nThese instructions are part of the AVX512 instruction set and are used for manipulating mask registers by unpacking and combining their bits.\n",
    "Alias": []
  },
  {
    "Name": "KUNPCKWD",
    "Brief": "Unpack 16-bit masks and write doubleword result",
    "Description": "\nUnpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.\n\nFor KUNPCKBW:\n- Destination [7:0] = Source2 [7:0]\n- Destination [15:8] = Source1 [7:0]\n- Destination [MAX_KL-1:16] = 0\n\nFor KUNPCKWD:\n- Destination [15:0] = Source2 [15:0]\n- Destination [31:16] = Source1 [15:0]\n- Destination [MAX_KL-1:32] = 0\n\nFor KUNPCKDQ:\n- Destination [31:0] = Source2 [31:0]\n- Destination [63:32] = Source1 [31:0]\n- Destination [MAX_KL-1:64] = 0\n\nThese instructions are part of the AVX512 instruction set and are used for manipulating mask registers by unpacking and combining their bits.\n",
    "Alias": []
  },
  {
    "Name": "KUNPCKDQ",
    "Brief": "Unpack 32-bit masks and write quadword result",
    "Description": "\nUnpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.\n\nFor KUNPCKBW:\n- Destination [7:0] = Source2 [7:0]\n- Destination [15:8] = Source1 [7:0]\n- Destination [MAX_KL-1:16] = 0\n\nFor KUNPCKWD:\n- Destination [15:0] = Source2 [15:0]\n- Destination [31:16] = Source1 [15:0]\n- Destination [MAX_KL-1:32] = 0\n\nFor KUNPCKDQ:\n- Destination [31:0] = Source2 [31:0]\n- Destination [63:32] = Source1 [31:0]\n- Destination [MAX_KL-1:64] = 0\n\nThese instructions are part of the AVX512 instruction set and are used for manipulating mask registers by unpacking and combining their bits.\n",
    "Alias": []
  },
  {
    "Name": "KXNORW",
    "Brief": "Bitwise XNOR 16-bit masks",
    "Description": "\nPerforms a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nEach instruction operates on a different bit width:\n- KXNORW: 16-bit masks\n- KXNORB: 8-bit masks\n- KXNORQ: 64-bit masks\n- KXNORD: 32-bit masks\n\nThe operation performs a bitwise XNOR (exclusive NOR) between the source masks, which means it returns 1 for bits that are the same in both source masks, and 0 for bits that are different. The result is then stored in the destination mask.\n\nAfter the operation, any bits beyond the specified width are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "KXNORB",
    "Brief": "Bitwise XNOR 8-bit masks",
    "Description": "\nPerforms a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nEach instruction operates on a different bit width:\n- KXNORW: 16-bit masks\n- KXNORB: 8-bit masks\n- KXNORQ: 64-bit masks\n- KXNORD: 32-bit masks\n\nThe operation performs a bitwise XNOR (exclusive NOR) between the source masks, which means it returns 1 for bits that are the same in both source masks, and 0 for bits that are different. The result is then stored in the destination mask.\n\nAfter the operation, any bits beyond the specified width are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "KXNORQ",
    "Brief": "Bitwise XNOR 64-bit masks",
    "Description": "\nPerforms a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nEach instruction operates on a different bit width:\n- KXNORW: 16-bit masks\n- KXNORB: 8-bit masks\n- KXNORQ: 64-bit masks\n- KXNORD: 32-bit masks\n\nThe operation performs a bitwise XNOR (exclusive NOR) between the source masks, which means it returns 1 for bits that are the same in both source masks, and 0 for bits that are different. The result is then stored in the destination mask.\n\nAfter the operation, any bits beyond the specified width are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "KXNORD",
    "Brief": "Bitwise XNOR 32-bit masks",
    "Description": "\nPerforms a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nEach instruction operates on a different bit width:\n- KXNORW: 16-bit masks\n- KXNORB: 8-bit masks\n- KXNORQ: 64-bit masks\n- KXNORD: 32-bit masks\n\nThe operation performs a bitwise XNOR (exclusive NOR) between the source masks, which means it returns 1 for bits that are the same in both source masks, and 0 for bits that are different. The result is then stored in the destination mask.\n\nAfter the operation, any bits beyond the specified width are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "KXORW",
    "Brief": "Bitwise XOR 16-bit masks",
    "Description": "\nPerforms a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nThe different variants (KXORW, KXORB, KXORQ, KXORD) operate on different bit widths:\n- KXORW: 16-bit masks\n- KXORB: 8-bit masks\n- KXORQ: 64-bit masks\n- KXORD: 32-bit masks\n\nEach instruction performs a bitwise XOR operation on the source masks and stores the result in the destination mask. Any bits beyond the specific width are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "KXORB",
    "Brief": "Bitwise XOR 8-bit masks",
    "Description": "\nPerforms a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nThe different variants (KXORW, KXORB, KXORQ, KXORD) operate on different bit widths:\n- KXORW: 16-bit masks\n- KXORB: 8-bit masks\n- KXORQ: 64-bit masks\n- KXORD: 32-bit masks\n\nEach instruction performs a bitwise XOR operation on the source masks and stores the result in the destination mask. Any bits beyond the specific width are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "KXORQ",
    "Brief": "Bitwise XOR 64-bit masks",
    "Description": "\nPerforms a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nThe different variants (KXORW, KXORB, KXORQ, KXORD) operate on different bit widths:\n- KXORW: 16-bit masks\n- KXORB: 8-bit masks\n- KXORQ: 64-bit masks\n- KXORD: 32-bit masks\n\nEach instruction performs a bitwise XOR operation on the source masks and stores the result in the destination mask. Any bits beyond the specific width are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "KXORD",
    "Brief": "Bitwise XOR 32-bit masks",
    "Description": "\nPerforms a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).\n\nThe different variants (KXORW, KXORB, KXORQ, KXORD) operate on different bit widths:\n- KXORW: 16-bit masks\n- KXORB: 8-bit masks\n- KXORQ: 64-bit masks\n- KXORD: 32-bit masks\n\nEach instruction performs a bitwise XOR operation on the source masks and stores the result in the destination mask. Any bits beyond the specific width are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "LAHF",
    "Brief": "Load Status Flags Into AH Register",
    "Description": "\nThis instruction loads the AH register with selected status flags from the EFLAGS/RFLAGS register. Specifically, it copies the following flags into the AH register in this order:\n- SF (Sign Flag)\n- ZF (Zero Flag)\n- 0 (Reserved/Always 0)\n- AF (Auxiliary Carry Flag)\n- 0 (Reserved/Always 0)\n- PF (Parity Flag)\n- 1 (Reserved/Always 1)\n- CF (Carry Flag)\n\nIn 64-bit mode, the instruction is only valid if the LAHF-SAHF feature is supported (determined by CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1). If the feature is not supported, an Undefined Instruction (#UD) exception is raised.\n\nIn compatibility mode, legacy mode, real address mode, and virtual 8086 mode, the instruction always loads the AH register from the EFLAGS register.\n\nNo flags in the EFLAGS/RFLAGS register are affected by this instruction.\n",
    "Alias": []
  },
  {
    "Name": "LAR",
    "Brief": "Load Access Rights Byte from segment descriptor",
    "Description": "\nLoads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. If the source operand is a memory address, only 16 bits of data are accessed. The destination operand is a general-purpose register.\n\nThe processor performs access checks as part of the loading process. Once loaded in the destination register, software can perform additional checks on the access rights information.\n\nThe access rights for a segment descriptor include fields located in the second doubleword (bytes 4–7) of the segment descriptor. The instruction returns specific bits:\n- Bits 7:0 are returned as 0\n- Bits 11:8 return the segment type\n- Bit 12 returns the S flag\n- Bits 14:13 return the DPL\n- Bit 15 returns the P flag\n\nFor operand sizes greater than 16 bits, additional bits are returned, including:\n- Bit 20 for software-available bit\n- Bit 21 for L flag\n- Bit 22 for D/B flag\n- Bit 23 for G flag\n- Bits 31:24 are returned as 0\n\nThe instruction performs several checks before loading access rights:\n- Verifies the segment selector is not NULL\n- Checks that the segment selector points within the GDT or LDT limits\n- Validates the descriptor type\n- For non-conforming code segments, checks segment descriptor visibility at the current privilege level\n\nThe LAR instruction can only be executed in protected mode and IA-32e mode. If the segment descriptor cannot be accessed or is an invalid type, the ZF flag is cleared and no access rights are loaded.\n",
    "Alias": []
  },
  {
    "Name": "LDDQU",
    "Brief": "Load unaligned packed integer values from memory",
    "Description": "\nThe LDDQU instruction is functionally similar to MOVDQU for loading from memory. 32/16 bytes of data starting at an address specified by the source memory operand are fetched from memory and placed in a destination register. The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory, which is implementation dependent.\n\nThis instruction may improve performance relative to MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by LDDQU be modified and stored to the same location, use MOVDQU or MOVDQA instead of LDDQU.\n\nKey implementation notes:\n- If the source is aligned to a 32/16-byte boundary, the 32/16 bytes may be loaded more than once. Avoid using LDDQU with uncached or write-combining memory regions.\n- The instruction is a replacement for MOVDQU in situations where cache line splits significantly affect performance.\n- If the memory address is not aligned, some implementations may load up to 64/32 bytes and return 32/16 bytes in the destination.\n- Some processor implementations may issue multiple non-atomic loads to access the appropriate 32/16 bytes.\n\nIn 64-bit mode, the REX.R prefix allows access to additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "VLDDQU",
    "Brief": "Load unaligned packed integer values from memory (VEX-encoded)",
    "Description": "\nThe LDDQU instruction is functionally similar to MOVDQU for loading from memory. 32/16 bytes of data starting at an address specified by the source memory operand are fetched from memory and placed in a destination register. The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory, which is implementation dependent.\n\nThis instruction may improve performance relative to MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by LDDQU be modified and stored to the same location, use MOVDQU or MOVDQA instead of LDDQU.\n\nKey implementation notes:\n- If the source is aligned to a 32/16-byte boundary, the 32/16 bytes may be loaded more than once. Avoid using LDDQU with uncached or write-combining memory regions.\n- The instruction is a replacement for MOVDQU in situations where cache line splits significantly affect performance.\n- If the memory address is not aligned, some implementations may load up to 64/32 bytes and return 32/16 bytes in the destination.\n- Some processor implementations may issue multiple non-atomic loads to access the appropriate 32/16 bytes.\n\nIn 64-bit mode, the REX.R prefix allows access to additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "LDMXCSR",
    "Brief": "Load MXCSR Register from memory",
    "Description": "\nLoads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location. The MXCSR register contains control and status bits for SIMD floating-point operations.\n\nThe LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.\n\nThe default MXCSR value at reset is 1F80H.\n\nIf a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only upon the execution of the next instruction that:\n- operates on an XMM or YMM register operand, and\n- causes that particular SIMD floating-point exception to be reported.\n\nFor VEX-encoded versions (VLDMXCSR):\n- VEX.L must be 0, otherwise an #UD exception will be raised\n- VEX.vvvv must be 1111b, otherwise an #UD exception will be raised\n",
    "Alias": []
  },
  {
    "Name": "VLDMXCSR",
    "Brief": "Load MXCSR Register from memory using VEX encoding",
    "Description": "\nLoads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location. The MXCSR register contains control and status bits for SIMD floating-point operations.\n\nThe LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.\n\nThe default MXCSR value at reset is 1F80H.\n\nIf a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only upon the execution of the next instruction that:\n- operates on an XMM or YMM register operand, and\n- causes that particular SIMD floating-point exception to be reported.\n\nFor VEX-encoded versions (VLDMXCSR):\n- VEX.L must be 0, otherwise an #UD exception will be raised\n- VEX.vvvv must be 1111b, otherwise an #UD exception will be raised\n",
    "Alias": []
  },
  {
    "Name": "LDS",
    "Brief": "Load far pointer into DS segment register and destination register",
    "Description": "\nThese instructions load a far pointer (segment selector and offset) from the source operand into a segment register and a general-purpose register. The source operand specifies a 48-bit or 32-bit pointer in memory depending on the current setting of the operand-size attribute.\n\nThe 16-bit segment selector from the source operand is loaded into the specified segment register (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the destination register.\n\nIn protected mode, if one of these instructions is executed, additional information from the segment descriptor pointed to by the segment selector is loaded in the hidden part of the selected segment register.\n\nIn protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. However, any subsequent reference to a segment with a NULL selector will cause a general-protection exception.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX.W prefix allows specifying a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.\n",
    "Alias": []
  },
  {
    "Name": "LES",
    "Brief": "Load far pointer into ES segment register and destination register",
    "Description": "\nThese instructions load a far pointer (segment selector and offset) from the source operand into a segment register and a general-purpose register. The source operand specifies a 48-bit or 32-bit pointer in memory depending on the current setting of the operand-size attribute.\n\nThe 16-bit segment selector from the source operand is loaded into the specified segment register (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the destination register.\n\nIn protected mode, if one of these instructions is executed, additional information from the segment descriptor pointed to by the segment selector is loaded in the hidden part of the selected segment register.\n\nIn protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. However, any subsequent reference to a segment with a NULL selector will cause a general-protection exception.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX.W prefix allows specifying a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.\n",
    "Alias": []
  },
  {
    "Name": "LFS",
    "Brief": "Load far pointer into FS segment register and destination register",
    "Description": "\nThese instructions load a far pointer (segment selector and offset) from the source operand into a segment register and a general-purpose register. The source operand specifies a 48-bit or 32-bit pointer in memory depending on the current setting of the operand-size attribute.\n\nThe 16-bit segment selector from the source operand is loaded into the specified segment register (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the destination register.\n\nIn protected mode, if one of these instructions is executed, additional information from the segment descriptor pointed to by the segment selector is loaded in the hidden part of the selected segment register.\n\nIn protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. However, any subsequent reference to a segment with a NULL selector will cause a general-protection exception.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX.W prefix allows specifying a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.\n",
    "Alias": []
  },
  {
    "Name": "LGS",
    "Brief": "Load far pointer into GS segment register and destination register",
    "Description": "\nThese instructions load a far pointer (segment selector and offset) from the source operand into a segment register and a general-purpose register. The source operand specifies a 48-bit or 32-bit pointer in memory depending on the current setting of the operand-size attribute.\n\nThe 16-bit segment selector from the source operand is loaded into the specified segment register (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the destination register.\n\nIn protected mode, if one of these instructions is executed, additional information from the segment descriptor pointed to by the segment selector is loaded in the hidden part of the selected segment register.\n\nIn protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. However, any subsequent reference to a segment with a NULL selector will cause a general-protection exception.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX.W prefix allows specifying a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.\n",
    "Alias": []
  },
  {
    "Name": "LSS",
    "Brief": "Load far pointer into SS segment register and destination register",
    "Description": "\nThese instructions load a far pointer (segment selector and offset) from the source operand into a segment register and a general-purpose register. The source operand specifies a 48-bit or 32-bit pointer in memory depending on the current setting of the operand-size attribute.\n\nThe 16-bit segment selector from the source operand is loaded into the specified segment register (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the destination register.\n\nIn protected mode, if one of these instructions is executed, additional information from the segment descriptor pointed to by the segment selector is loaded in the hidden part of the selected segment register.\n\nIn protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. However, any subsequent reference to a segment with a NULL selector will cause a general-protection exception.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX.W prefix allows specifying a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.\n",
    "Alias": []
  },
  {
    "Name": "LDTILECFG",
    "Brief": "Load tile configuration",
    "Description": "\nThe LDTILECFG instruction takes an operand containing a pointer to a 64-byte memory location containing the description of the tiles to be supported. In order to configure the tiles, the AMX-TILE bit in CPUID must be set and the operating system has to have enabled the tiles architecture.\n\nThe memory area contains the palette and describes how many tiles are being used and defines each tile in terms of rows and column bytes. Requests must be compatible with the restrictions provided by CPUID.\n\nThe memory area is structured as follows:\n- Byte 0: palette (selects the supported configuration of tiles)\n- Byte 1: start_row (used for storing restart values for interrupted operations)\n- Bytes 2-15: reserved, must be zero\n- Bytes 16-31: tile column bytes (2 bytes per tile, 0-7)\n- Bytes 32-47: reserved, must be zero\n- Bytes 48-55: tile rows (1 byte per tile, 0-7)\n- Bytes 56-63: reserved, must be zero\n\nIf a tile row and column pair is not used, they must have the value zero. All enabled tiles must be configured. \n\nIf the palette_id is zero, it signifies the INIT state for both TILECFG and TILEDATA, where tiles are zeroed. The only legal non-INIT value for palette_id is 1.\n\nAny attempt to execute the LDTILECFG instruction inside an Intel TSX transaction will result in a transaction abort.\n",
    "Alias": []
  },
  {
    "Name": "LEA",
    "Brief": "Load Effective Address",
    "Description": "\nComputes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register.\n\nThe address-size and operand-size attributes affect the action performed by the instruction. The operand-size attribute is determined by the chosen register, and the address-size attribute is determined by the attribute of the code segment.\n\nIn non-64-bit modes, the instruction behaves differently based on the operand and address size:\n- 16-bit operand, 16-bit address: 16-bit effective address is calculated and stored\n- 16-bit operand, 32-bit address: 32-bit address calculated, lower 16 bits stored\n- 32-bit operand, 16-bit address: 16-bit address zero-extended to 32 bits\n- 32-bit operand, 32-bit address: 32-bit effective address calculated and stored\n\nIn 64-bit mode, the default operand size is 32 bits and the default address size is 64 bits. The instruction supports various combinations of operand and address sizes using prefixes, with different behaviors for storing the calculated address.\n\nDifferent assemblers may use different algorithms based on the size attribute and symbolic reference of the source operand.\n",
    "Alias": []
  },
  {
    "Name": "LEAVE",
    "Brief": "High Level Procedure Exit",
    "Description": "\nReleases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame. The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure's stack frame.\n\nA RET instruction is commonly executed following a LEAVE instruction to return program control to the calling procedure.\n\nIn different modes, the LEAVE instruction behaves slightly differently:\n- In 16-bit mode: SP is set to BP, then BP is popped\n- In 32-bit mode: ESP is set to EBP, then EBP is popped\n- In 64-bit mode: RSP is set to RBP, then RBP is popped\n\nIn 64-bit mode, the instruction's default operation size is 64 bits, and 32-bit operation cannot be encoded.\n",
    "Alias": []
  },
  {
    "Name": "LFENCE",
    "Brief": "Serializes load operations",
    "Description": "\nPerforms a serializing operation on all load-from-memory instructions that were issued prior to the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes. \n\nIn particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) \n\nInstructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute (even speculatively) until the LFENCE completes.\n\nWeakly ordered memory types can be used to achieve higher processor performance through techniques like out-of-order issue and speculative reads. The LFENCE instruction provides a performance-efficient way of ensuring load ordering between routines that produce weakly-ordered results and routines that consume that data.\n\nProcessors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution, so data can be brought into the caches speculatively just before, during, or after the execution of an LFENCE instruction.\n",
    "Alias": []
  },
  {
    "Name": "LGDT",
    "Brief": "Load Global Descriptor Table Register",
    "Description": "\nLoads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT).\n\nIf operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.\n\nThe LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.\n\nIn 64-bit mode, the instruction's operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit).\n",
    "Alias": []
  },
  {
    "Name": "LIDT",
    "Brief": "Load Interrupt Descriptor Table Register",
    "Description": "\nLoads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT).\n\nIf operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.\n\nThe LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.\n\nIn 64-bit mode, the instruction's operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit).\n",
    "Alias": []
  },
  {
    "Name": "LLDT",
    "Brief": "Load segment selector into Local Descriptor Table Register (LDTR)",
    "Description": "\nLoads the source operand into the segment selector field of the local descriptor table register (LDTR). The source operand (a general-purpose register or a memory location) contains a segment selector that points to a local descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit and base address for the LDT from the segment descriptor into the LDTR.\n\nIf bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT instruction completes silently. However, all subsequent references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions) cause a general protection exception (#GP).\n\nThe LLDT instruction is provided for use in operating-system software; it should not be used in application programs. This instruction can only be executed in protected mode or 64-bit mode.\n\nIn 64-bit mode, the operand size is fixed at 16 bits.\n",
    "Alias": []
  },
  {
    "Name": "LMSW",
    "Brief": "Load Machine Status Word",
    "Description": "\nLoads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operand-size attribute has no effect on this instruction.\n\nIf the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back to real-address mode.\n\nThe LMSW instruction is provided for use in operating-system software; it should not be used in application programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.\n\nThis instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to run on IA-32 and Intel 64 processors beginning with Intel386 processors should use the MOV (control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes.\n\nThis instruction is a serializing instruction and its operation is the same in non-64-bit modes and 64-bit mode, with the operand size fixed at 16 bits.\n",
    "Alias": []
  },
  {
    "Name": "LOADIWKEY",
    "Brief": "Load Internal Wrapping Key with Key Locker",
    "Description": "\nThe LOADIWKEY instruction writes the Key Locker internal wrapping key (IWKey), which is used by the ENCODEKEY* instructions to wrap keys into handles and by the AESENC/DEC*KL instructions to unwrap keys from handles and verify handle integrity. For security reasons, no instruction allows directly reading the IWKey value.\n\nIWKey includes two cryptographic keys and metadata:\n- A 256-bit encryption key loaded from two explicit operands\n- A 128-bit integrity key loaded from the implicit operand XMM0\n\nThe implicit operand EAX specifies the KeySource and backup permissions:\n- EAX[0]: When set, the wrapping key cannot be backed up to platform-scoped storage\n- EAX[4:1]: Specifies the KeySource type\n  - KeySource 0: Source registers are directly stored as internal wrapping keys\n  - KeySource 1: Random numbers from the on-chip random number generator are XORed with source registers\n\nThe instruction can only be executed in supervisor mode (ring 0) and has specific requirements for key generation and usage based on the KeySource and hardware capabilities.\n",
    "Alias": []
  },
  {
    "Name": "LOCK",
    "Brief": "Assert LOCK# Signal Prefix",
    "Description": "\nCauses the processor's LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the processor has exclusive use of any shared memory while the signal is asserted.\n\nIn most IA-32 and all Intel 64 processors, locking may occur without the LOCK# signal being asserted. \n\nThe LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of the LOCK prefix.\n\nThe LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory location in shared memory environment.\n\nThe integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed for arbitrarily misaligned fields.\n\nBeginning with the P6 family processors, when the LOCK prefix is prefixed to an instruction and the memory area being accessed is cached internally in the processor, the LOCK# signal is generally not asserted. Instead, only the processor's cache is locked. Here, the processor's cache coherency mechanism ensures that the operation is carried out atomically with regards to memory.\n",
    "Alias": []
  },
  {
    "Name": "LODS",
    "Brief": "Load a byte, word, or doubleword from memory into AL, AX, or EAX",
    "Description": "\nLoads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions.\n\nAfter the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nThe LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made.\n",
    "Alias": []
  },
  {
    "Name": "LODSB",
    "Brief": "Load a byte from memory into AL",
    "Description": "\nLoads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions.\n\nAfter the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nThe LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made.\n",
    "Alias": []
  },
  {
    "Name": "LODSW",
    "Brief": "Load a word from memory into AX",
    "Description": "\nLoads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions.\n\nAfter the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nThe LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made.\n",
    "Alias": []
  },
  {
    "Name": "LODSD",
    "Brief": "Load a doubleword from memory into EAX",
    "Description": "\nLoads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions.\n\nAfter the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nThe LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made.\n",
    "Alias": []
  },
  {
    "Name": "LODSQ",
    "Brief": "Load a quadword from memory into RAX",
    "Description": "\nLoads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the source operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, and doubleword versions.\n\nAfter the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nThe LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made.\n",
    "Alias": []
  },
  {
    "Name": "LOOP",
    "Brief": "Decrement count register and jump if count is not zero",
    "Description": "\nPerforms a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.\n\nEach time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of –128 to +127 are allowed with this instruction.\n\nSome forms of the loop instruction (LOOP<em>cc</em>) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (<em>cc</em>) is associated with each instruction to indicate the condition being tested for. Here, the LOOP<em>cc</em> instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.\n",
    "Alias": []
  },
  {
    "Name": "LOOPE",
    "Brief": "Decrement count register and jump if count is not zero and ZF is 1",
    "Description": "\nPerforms a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.\n\nEach time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of –128 to +127 are allowed with this instruction.\n\nSome forms of the loop instruction (LOOP<em>cc</em>) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (<em>cc</em>) is associated with each instruction to indicate the condition being tested for. Here, the LOOP<em>cc</em> instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.\n",
    "Alias": []
  },
  {
    "Name": "LOOPNE",
    "Brief": "Decrement count register and jump if count is not zero and ZF is 0",
    "Description": "\nPerforms a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.\n\nEach time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.\n\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of –128 to +127 are allowed with this instruction.\n\nSome forms of the loop instruction (LOOP<em>cc</em>) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (<em>cc</em>) is associated with each instruction to indicate the condition being tested for. Here, the LOOP<em>cc</em> instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.\n",
    "Alias": []
  },
  {
    "Name": "LSL",
    "Brief": "Load Segment Limit from segment descriptor into a register",
    "Description": "\nLoads the unscrambled segment limit from the segment descriptor specified with the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.\n\nThe processor performs access checks as part of the loading process. Once loaded in the destination register, software can compare the segment limit with the offset of a pointer.\n\nThe segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte 6 of the segment descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit before loading it into the destination operand. The translation is performed by shifting the 20-bit \"raw\" limit left 12 bits and filling the low-order 12 bits with 1s.\n\nWhen the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits are loaded into the destination operand.\n\nThe instruction performs several checks before loading the segment limit:\n- Checks that the segment selector is not NULL\n- Checks that the segment selector points to a descriptor within the limits of the GDT or LDT\n- Checks that the descriptor type is valid for this instruction\n- For non-conforming code segments, checks that the segment descriptor is visible at the current privilege level\n\nIf the segment descriptor cannot be accessed or is an invalid type, the ZF flag is cleared and no value is loaded in the destination operand.\n",
    "Alias": []
  },
  {
    "Name": "LTR",
    "Brief": "Load Task Register",
    "Description": "\nLoads the source operand into the segment selector field of the task register. The source operand (a general-purpose register or a memory location) contains a segment selector that points to a task state segment (TSS). After the segment selector is loaded in the task register, the processor uses the segment selector to locate the segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is marked busy, but a switch to the task does not occur.\n\nThe LTR instruction is provided for use in operating-system software; it should not be used in application programs. It can only be executed in protected mode when the CPL is 0. It is commonly used in initialization code to establish the first task to be executed.\n\nIn 64-bit mode, the operand size is still fixed at 16 bits. The instruction references a 16-byte descriptor to load the 64-bit base.\n",
    "Alias": []
  },
  {
    "Name": "LZCNT",
    "Brief": "Count the number of leading zero bits",
    "Description": "\nCounts the number of leading most significant zero bits in a source operand (second operand) returning the result into a destination (first operand).\n\nLZCNT differs from BSR. For example, LZCNT will produce the operand size when the input operand is zero. It should be noted that on processors that do not support LZCNT, the instruction byte encoding is executed as BSR.\n\nIn 64-bit mode 64-bit operand size requires REX.W=1.\n\nThe instruction has the following behavior:\n- Counts leading zero bits from the most significant bit\n- Returns the count in the destination operand\n- Sets the Zero Flag (ZF) to 1 if the result is zero\n- Sets the Carry Flag (CF) to 1 if the input was zero\n- OF, SF, PF, and AF flags are undefined\n\nThe instruction can be used with 16-bit, 32-bit, and 64-bit operands.\n",
    "Alias": []
  },
  {
    "Name": "MASKMOVDQU",
    "Brief": "Store selected bytes of double quadword using a mask",
    "Description": "\nStores selected bytes from the source operand (first operand) into a 128-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are XMM registers. The memory location is specified by the effective address in the DI/EDI/RDI register (default segment register is DS, but can be overridden).\n\nThe most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to memory:\n- 0 indicates no write\n- 1 indicates write\n\nThe instruction generates a non-temporal hint to minimize cache pollution using a write combining (WC) memory type protocol. Due to the weakly-ordered memory consistency model, a fencing operation with SFENCE or MFENCE is recommended when multiple processors might use different memory types.\n\nBehavior with a mask of all 0s includes:\n- No data will be written to memory\n- Breakpoint signaling is not guaranteed\n- Memory addressing and page fault exceptions may still be signaled\n- Enforcement of memory type semantics is implementation-specific\n\nThe instruction can improve performance of algorithms that need to merge data on a byte-by-byte basis. It should not cause a read for ownership to avoid unnecessary bandwidth usage.\n\nIn 64-bit mode, the REX.R prefix allows access to additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "MASKMOVQ",
    "Brief": "Selectively write bytes from mm1 to memory location using the byte mask in mm2",
    "Description": "\nStores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are MMX technology registers. The memory location is specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary.\n\nThe most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.\n\nThe MASKMOVQ instruction generates a non-temporal hint to the processor to minimize cache pollution. It uses a write combining (WC) memory type protocol. Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVQ instructions if multiple processors might use different memory types to read/write the destination memory locations.\n\nThis instruction causes a transition from x87 FPU to MMX technology state. When the mask is all 0s:\n- No data will be written to memory\n- Transition from x87 FPU to MMX technology state will occur\n- Memory addressing and page fault exceptions may still be signaled\n- Breakpoint signaling is not guaranteed\n- Memory type semantics enforcement is not guaranteed\n\nThe instruction can be used to improve performance for algorithms that need to merge data on a byte-by-byte basis. It should not cause a read for ownership to avoid unnecessary bandwidth usage.\n",
    "Alias": []
  },
  {
    "Name": "MAXPD",
    "Brief": "Maximum of Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms a SIMD compare of the packed double precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPD can be emulated using a sequence of instructions, such as a comparison followed by AND, ANDN, and OR.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "MAXPS",
    "Brief": "Maximum of Packed Single Precision Floating-Point Values",
    "Description": "\nPerforms a SIMD compare of the packed single precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "MAXSD",
    "Brief": "Return the maximum scalar double precision floating-point value",
    "Description": "\nCompares the low double precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low quadword of the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. When the second source operand is a memory operand, only 64 bits are accessed.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN of either source operand be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nIn the 128-bit Legacy SSE version, the destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\n\nIn the VEX.128 and EVEX encoded version, bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nIn the EVEX encoded version, the low quadword element of the destination operand is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VMAXSD",
    "Brief": "Return the maximum scalar double precision floating-point value with vector extensions",
    "Description": "\nCompares the low double precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low quadword of the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. When the second source operand is a memory operand, only 64 bits are accessed.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN of either source operand be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nIn the 128-bit Legacy SSE version, the destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\n\nIn the VEX.128 and EVEX encoded version, bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nIn the EVEX encoded version, the low quadword element of the destination operand is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "MAXSS",
    "Brief": "Return maximum scalar single precision floating-point value",
    "Description": "\nCompares the low single precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low doubleword of the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN from either source operand be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nThe second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL:128) of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.\n\nSoftware should ensure VMAXSS is encoded with VEX.L=0. Encoding VMAXSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "VMAXSS",
    "Brief": "Return maximum scalar single precision floating-point value",
    "Description": "\nCompares the low single precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low doubleword of the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN from either source operand be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nThe second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL:128) of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.\n\nSoftware should ensure VMAXSS is encoded with VEX.L=0. Encoding VMAXSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "MFENCE",
    "Brief": "Serializes load and store operations",
    "Description": "\nPerforms a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.\n\nThe MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream.\n\nWeakly ordered memory types can be used to achieve higher processor performance through techniques like out-of-order issue, speculative reads, write-combining, and write-collapsing. The MFENCE instruction provides a performance-efficient way of ensuring load and store ordering between routines that produce weakly-ordered results and routines that consume that data.\n\nProcessors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution, so it is not strictly ordered with respect to the MFENCE instruction.\n",
    "Alias": []
  },
  {
    "Name": "MINPD",
    "Brief": "Return the minimum of packed double precision floating-point values",
    "Description": "\nPerforms a SIMD compare of the packed double precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "MINPS",
    "Brief": "Returns the minimum single precision floating-point values between two operands",
    "Description": "\nPerforms a SIMD compare of the packed single precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX and SSE versions support similar operations on 128-bit and 256-bit register sizes with slight variations in behavior and register zeroing.\n",
    "Alias": []
  },
  {
    "Name": "MINSD",
    "Brief": "Return the minimum scalar double precision floating-point value",
    "Description": "\nCompares the low double precision floating-point values in the first source operand and the second source operand, and returns the minimum value to the low quadword of the destination operand. When the source operand is a memory operand, only the 64 bits are accessed.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, then SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second source) be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n\nIn the 128-bit Legacy SSE version, the destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\n\nIn the VEX.128 and EVEX encoded version, bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nIn the EVEX encoded version, the low quadword element of the destination operand is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "MINSS",
    "Brief": "Return minimum scalar single precision floating-point value",
    "Description": "\nCompares the low single precision floating-point values in the first source operand and the second source operand and returns the minimum value to the low doubleword of the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN in either source operand be returned, the action of MINSS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nThe second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.\n\nIn the 128-bit Legacy SSE version, the destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.\n\nIn the VEX.128 and EVEX encoded versions, the first source operand is an xmm register encoded by (E)VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nIn the EVEX encoded version, the low doubleword element of the destination operand is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "MONITOR",
    "Brief": "Set up a linear address range to be monitored by hardware",
    "Description": "\nThe MONITOR instruction arms address monitoring hardware using an address specified in EAX (the address range that the monitoring hardware checks for store operations can be determined by using CPUID). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by MWAIT.\n\nThe address is specified in RAX/EAX/AX and the size is based on the effective address size of the encoded instruction. By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used.\n\nECX and EDX are also used to communicate other information to MONITOR. ECX specifies optional extensions. EDX specifies optional hints; it does not change the architectural behavior of the instruction. For the Pentium 4 processor (family 15, model 3), no extensions or hints are defined. Undefined hints in EDX are ignored by the processor; undefined extensions in ECX raises a general protection fault.\n\nThe address range must use memory of the write-back type. Only write-back memory will correctly trigger the monitoring hardware. \n\nThe MONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, MONITOR sets the A-bit but not the D-bit in page tables.\n\nCPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set, MONITOR may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception).\n",
    "Alias": []
  },
  {
    "Name": "MOV",
    "Brief": "Copy source operand to destination operand",
    "Description": "\nCopies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, a doubleword, or a quadword.\n\nThe MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode exception (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.\n\nIf the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register.\n\nA NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a NULL value causes a general protection exception (#GP) and no memory reference occurs.\n\nLoading the SS register with a MOV instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary.\n\nWhen executing MOV Reg, Sreg, the processor copies the content of Sreg to the 16 least significant bits of the general-purpose register. The upper bits of the destination register are zero for most IA-32 processors and all Intel 64 processors.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "MOVAPD",
    "Brief": "Move aligned packed double precision floating-point values",
    "Description": "\nMoves 2, 4 or 8 double precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.\n\nWhen the source or destination operand is a memory operand, the operand must be aligned on a:\n- 16-byte boundary for 128-bit versions\n- 32-byte boundary for 256-bit versions\n- 64-byte boundary for 512-bit versions\n\nOtherwise, a general-protection exception (#GP) will be generated. To move double precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.\n\nThe instruction supports different versions:\n- Legacy SSE version (128-bit): Bits beyond 128 remain unchanged\n- VEX and EVEX versions: Bits beyond the operand size are zeroed\n- EVEX versions support write masking and multiple register sizes (XMM, YMM, ZMM)\n",
    "Alias": []
  },
  {
    "Name": "MOVAPS",
    "Brief": "Move Aligned Packed Single Precision Floating-Point Values",
    "Description": "\nMoves 4, 8 or 16 single precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to:\n- Load an XMM, YMM or ZMM register from a memory location\n- Store the contents of an XMM, YMM or ZMM register into a memory location\n- Move data between two XMM, two YMM or two ZMM registers\n\nKey characteristics:\n- When the source or destination operand is a memory operand, it must be aligned:\n  - 16-byte boundary for 128-bit version\n  - 32-byte boundary for 256-bit version\n  - 64-byte boundary for 512-bit version\n\n- For unaligned memory locations, use VMOVUPS instruction instead\n\n- VEX and EVEX versions have different behavior with upper bits of destination register:\n  - Legacy SSE version leaves upper bits unchanged\n  - VEX and EVEX versions zero out upper bits\n\n- EVEX versions support write masking, allowing conditional moves\n",
    "Alias": []
  },
  {
    "Name": "MOVBE",
    "Brief": "Move Data After Swapping Bytes",
    "Description": "\nPerforms a byte swap operation on the data copied from the second operand (source operand) and store the result in the first operand (destination operand). The source operand can be a general-purpose register, or memory location; the destination register can be a general-purpose register, or a memory location; however, both operands can not be registers, and only one operand can be a memory location. Both operands must be the same size, which can be a word, a doubleword or quadword.\n\nThe MOVBE instruction is provided for swapping the bytes on a read from memory or on a write to memory; thus providing support for converting little-endian values to big-endian format and vice versa.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nThe instruction performs byte swapping for 16-bit, 32-bit, and 64-bit operands, effectively reversing the byte order of the source operand before storing it in the destination operand.\n",
    "Alias": []
  },
  {
    "Name": "MOVD",
    "Brief": "Copies a doubleword from the source operand to the destination operand",
    "Description": "\nCopies a doubleword or quadword from the source operand to the destination operand. The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or memory locations.\n\nWhen the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword/quadword of the register, and the register is zero-extended to 128 bits.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nKey variations:\n- MOVD/MOVQ with XMM destination: Moves a dword/qword integer and stores it in the low 32/64-bits of the destination XMM register, with upper bits zeroed.\n- MOVD/MOVQ with 32/64 register/memory destination: Stores the low dword/qword of the source XMM register to a 32/64-bit memory location or general-purpose register.\n\nLegacy SSE, VEX, and EVEX versions have slightly different behaviors regarding upper register bits and require specific prefix usage for 64-bit operations.\n",
    "Alias": []
  },
  {
    "Name": "MOVQ",
    "Brief": "Copies a quadword from the source operand to the destination operand",
    "Description": "\nCopies a doubleword or quadword from the source operand to the destination operand. The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or memory locations.\n\nWhen the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword/quadword of the register, and the register is zero-extended to 128 bits.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nKey variations:\n- MOVD/MOVQ with XMM destination: Moves a dword/qword integer and stores it in the low 32/64-bits of the destination XMM register, with upper bits zeroed.\n- MOVD/MOVQ with 32/64 register/memory destination: Stores the low dword/qword of the source XMM register to a 32/64-bit memory location or general-purpose register.\n\nLegacy SSE, VEX, and EVEX versions have slightly different behaviors regarding upper register bits and require specific prefix usage for 64-bit operations.\n",
    "Alias": []
  },
  {
    "Name": "MOVDDUP",
    "Brief": "Replicate double precision floating-point values",
    "Description": "\nThis instruction duplicates double precision floating-point values from the source operand and stores them in the destination operand.\n\nFor 256-bit or higher versions: Duplicates even-indexed double precision floating-point values from the source operand (the second operand) and into adjacent pair and store to the destination operand (the first operand).\n\nFor 128-bit versions: Duplicates the low double precision floating-point value from the source operand (the second operand) and store to the destination operand (the first operand).\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register are unchanged. The source operand is XMM register or a 64-bit memory location.\n\nVEX.128 and EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. The source operand is XMM register or a 64-bit memory location. The destination is updated conditionally under the writemask for EVEX version.\n\nVEX.256 and EVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed. The source operand is YMM register or a 256-bit memory location. The destination is updated conditionally under the write-mask for EVEX version.\n\nEVEX.512 encoded version: The destination is updated according to the writemask. The source operand is ZMM register or a 512-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "MOVDIR64B",
    "Brief": "Move 64 Bytes as Direct Store",
    "Description": "\nMoves 64-bytes as direct-store with 64-byte write atomicity from source memory address to destination memory address. The source operand is a normal memory operand. The destination operand is a memory location specified in a general-purpose register. The register content is interpreted as an offset into ES segment without any segment override.\n\nThe instruction requires the destination address to be 64-byte aligned. No alignment restriction is enforced for the source operand. MOVDIR64B first reads 64-bytes from the source memory address and then performs a 64-byte direct-store operation to the destination address.\n\nThe direct-store is implemented using the write combining (WC) memory type protocol, which means:\n- The processor does not write the data into the cache hierarchy\n- It does not fetch the corresponding cache line from memory into the cache hierarchy\n- If the destination address is cached, the line is written-back (if modified) and invalidated from the cache\n\nKey characteristics of MOVDIR64B:\n- Always follows WC memory type protocol\n- Direct-stores are eligible for immediate eviction from the write-combining buffer\n- Not combined with younger stores to the same address\n- Weakly ordered relative to other stores\n- Provides 64-byte write-completion atomicity\n\nAvailability of the instruction is indicated by the CPUID feature flag MOVDIR64B.\n",
    "Alias": []
  },
  {
    "Name": "MOVDIRI",
    "Brief": "Move doubleword or quadword to memory using direct store",
    "Description": "\nMoves the doubleword or quadword integer in the source operand (second operand) to the destination operand (first operand) using a direct-store operation. The source operand is a general purpose register. The destination operand is a memory location.\n\nThe direct-store is implemented by using write combining (WC) memory type protocol for writing data. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. If the destination address is cached, the line is written-back (if modified) and invalidated from the cache, before the direct-store.\n\nUnlike WC stores and stores with non-temporal hint, direct-stores are eligible for immediate eviction from the write-combining buffer, and thus not combined with younger stores to the same address. Direct stores are weakly ordered relative to other stores. Software that desires stronger ordering should use a fencing instruction (MFENCE or SFENCE) before or after a direct store to enforce the ordering desired.\n\nDirect-stores issued by MOVDIRI to a destination aligned to a 4-byte boundary (8-byte boundary if used with REX.W prefix) guarantee 4-byte (8-byte with REX.W prefix) write-completion atomicity. If the destination is not aligned for the write size, the direct-stores are split and arrive at the destination in two parts.\n",
    "Alias": []
  },
  {
    "Name": "MOVDQ2Q",
    "Brief": "Move low quadword from XMM to MMX Technology Register",
    "Description": "\nMoves the low quadword from the source operand (second operand) to the destination operand (first operand). The source operand is an XMM register and the destination operand is an MMX technology register.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVDQ2Q instruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "MOVDQA",
    "Brief": "Move aligned packed integer values",
    "Description": "\nThese instructions move aligned packed integer values between registers and memory locations. There are several variants based on the vector length and specific encoding:\n\nMOVDQA (SSE2):\n- Moves 128 bits of packed integer values\n- Requires 16-byte memory alignment\n- Legacy SSE version keeps upper bits of destination register unchanged\n\nVMOVDQA (VEX-encoded):\n- 128-bit version moves 128 bits, zeroes upper bits of destination\n- 256-bit version moves 256 bits, zeroes upper bits of destination\n- Requires 32-byte memory alignment for 256-bit version\n\nVMOVDQA32/VMOVDQA64 (EVEX-encoded):\n- Move 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) packed integer values\n- Supports 128, 256, and 512-bit vector lengths\n- Uses writemask k1 for conditional moves\n- Supports merging and zeroing masking\n- Requires 16/32/64-byte memory alignment depending on vector length\n\nWhen used with memory operands, the memory location must be aligned, or a general-protection exception (#GP) will be generated. For unaligned memory moves, use VMOVDQU instead.\n",
    "Alias": []
  },
  {
    "Name": "VMOVDQA32",
    "Brief": "Move aligned packed doubleword integer values",
    "Description": "\nThese instructions move aligned packed integer values between registers and memory locations. There are several variants based on the vector length and specific encoding:\n\nMOVDQA (SSE2):\n- Moves 128 bits of packed integer values\n- Requires 16-byte memory alignment\n- Legacy SSE version keeps upper bits of destination register unchanged\n\nVMOVDQA (VEX-encoded):\n- 128-bit version moves 128 bits, zeroes upper bits of destination\n- 256-bit version moves 256 bits, zeroes upper bits of destination\n- Requires 32-byte memory alignment for 256-bit version\n\nVMOVDQA32/VMOVDQA64 (EVEX-encoded):\n- Move 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) packed integer values\n- Supports 128, 256, and 512-bit vector lengths\n- Uses writemask k1 for conditional moves\n- Supports merging and zeroing masking\n- Requires 16/32/64-byte memory alignment depending on vector length\n\nWhen used with memory operands, the memory location must be aligned, or a general-protection exception (#GP) will be generated. For unaligned memory moves, use VMOVDQU instead.\n",
    "Alias": []
  },
  {
    "Name": "VMOVDQA64",
    "Brief": "Move aligned packed quadword integer values",
    "Description": "\nThese instructions move aligned packed integer values between registers and memory locations. There are several variants based on the vector length and specific encoding:\n\nMOVDQA (SSE2):\n- Moves 128 bits of packed integer values\n- Requires 16-byte memory alignment\n- Legacy SSE version keeps upper bits of destination register unchanged\n\nVMOVDQA (VEX-encoded):\n- 128-bit version moves 128 bits, zeroes upper bits of destination\n- 256-bit version moves 256 bits, zeroes upper bits of destination\n- Requires 32-byte memory alignment for 256-bit version\n\nVMOVDQA32/VMOVDQA64 (EVEX-encoded):\n- Move 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) packed integer values\n- Supports 128, 256, and 512-bit vector lengths\n- Uses writemask k1 for conditional moves\n- Supports merging and zeroing masking\n- Requires 16/32/64-byte memory alignment depending on vector length\n\nWhen used with memory operands, the memory location must be aligned, or a general-protection exception (#GP) will be generated. For unaligned memory moves, use VMOVDQU instead.\n",
    "Alias": []
  },
  {
    "Name": "MOVDQU",
    "Brief": "Move unaligned packed integer values",
    "Description": "\nThese instructions move packed integer values between registers or between registers and memory locations. The key characteristics are:\n\n1. They can move unaligned data without causing a general-protection exception (#GP).\n\n2. EVEX encoded versions support:\n   - Moving 128, 256, or 512 bits of packed data\n   - Different integer sizes: byte (8-bit), word (16-bit), doubleword (32-bit), and quadword (64-bit)\n   - Writemask support for conditional moves\n   - Merging and zeroing masking options\n\n3. VEX encoded versions:\n   - Move 128 or 256 bits of packed integer values\n   - Zero out upper bits of the destination register\n\n4. Legacy SSE version (MOVDQU):\n   - Moves 128 bits of packed integer values\n   - Does not modify upper bits of the destination register\n\nThe instructions can be used to:\n- Load a vector register from a memory location\n- Store the contents of a vector register into a memory location\n- Move data between vector registers\n\nWhen using EVEX encoded versions, the destination operand is updated at the specified granularity (8, 16, 32, or 64 bits) according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VMOVDQU8",
    "Brief": "Move unaligned packed byte integer values",
    "Description": "\nThese instructions move packed integer values between registers or between registers and memory locations. The key characteristics are:\n\n1. They can move unaligned data without causing a general-protection exception (#GP).\n\n2. EVEX encoded versions support:\n   - Moving 128, 256, or 512 bits of packed data\n   - Different integer sizes: byte (8-bit), word (16-bit), doubleword (32-bit), and quadword (64-bit)\n   - Writemask support for conditional moves\n   - Merging and zeroing masking options\n\n3. VEX encoded versions:\n   - Move 128 or 256 bits of packed integer values\n   - Zero out upper bits of the destination register\n\n4. Legacy SSE version (MOVDQU):\n   - Moves 128 bits of packed integer values\n   - Does not modify upper bits of the destination register\n\nThe instructions can be used to:\n- Load a vector register from a memory location\n- Store the contents of a vector register into a memory location\n- Move data between vector registers\n\nWhen using EVEX encoded versions, the destination operand is updated at the specified granularity (8, 16, 32, or 64 bits) according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VMOVDQU16",
    "Brief": "Move unaligned packed word integer values",
    "Description": "\nThese instructions move packed integer values between registers or between registers and memory locations. The key characteristics are:\n\n1. They can move unaligned data without causing a general-protection exception (#GP).\n\n2. EVEX encoded versions support:\n   - Moving 128, 256, or 512 bits of packed data\n   - Different integer sizes: byte (8-bit), word (16-bit), doubleword (32-bit), and quadword (64-bit)\n   - Writemask support for conditional moves\n   - Merging and zeroing masking options\n\n3. VEX encoded versions:\n   - Move 128 or 256 bits of packed integer values\n   - Zero out upper bits of the destination register\n\n4. Legacy SSE version (MOVDQU):\n   - Moves 128 bits of packed integer values\n   - Does not modify upper bits of the destination register\n\nThe instructions can be used to:\n- Load a vector register from a memory location\n- Store the contents of a vector register into a memory location\n- Move data between vector registers\n\nWhen using EVEX encoded versions, the destination operand is updated at the specified granularity (8, 16, 32, or 64 bits) according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VMOVDQU32",
    "Brief": "Move unaligned packed doubleword integer values",
    "Description": "\nThese instructions move packed integer values between registers or between registers and memory locations. The key characteristics are:\n\n1. They can move unaligned data without causing a general-protection exception (#GP).\n\n2. EVEX encoded versions support:\n   - Moving 128, 256, or 512 bits of packed data\n   - Different integer sizes: byte (8-bit), word (16-bit), doubleword (32-bit), and quadword (64-bit)\n   - Writemask support for conditional moves\n   - Merging and zeroing masking options\n\n3. VEX encoded versions:\n   - Move 128 or 256 bits of packed integer values\n   - Zero out upper bits of the destination register\n\n4. Legacy SSE version (MOVDQU):\n   - Moves 128 bits of packed integer values\n   - Does not modify upper bits of the destination register\n\nThe instructions can be used to:\n- Load a vector register from a memory location\n- Store the contents of a vector register into a memory location\n- Move data between vector registers\n\nWhen using EVEX encoded versions, the destination operand is updated at the specified granularity (8, 16, 32, or 64 bits) according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VMOVDQU64",
    "Brief": "Move unaligned packed quadword integer values",
    "Description": "\nThese instructions move packed integer values between registers or between registers and memory locations. The key characteristics are:\n\n1. They can move unaligned data without causing a general-protection exception (#GP).\n\n2. EVEX encoded versions support:\n   - Moving 128, 256, or 512 bits of packed data\n   - Different integer sizes: byte (8-bit), word (16-bit), doubleword (32-bit), and quadword (64-bit)\n   - Writemask support for conditional moves\n   - Merging and zeroing masking options\n\n3. VEX encoded versions:\n   - Move 128 or 256 bits of packed integer values\n   - Zero out upper bits of the destination register\n\n4. Legacy SSE version (MOVDQU):\n   - Moves 128 bits of packed integer values\n   - Does not modify upper bits of the destination register\n\nThe instructions can be used to:\n- Load a vector register from a memory location\n- Store the contents of a vector register into a memory location\n- Move data between vector registers\n\nWhen using EVEX encoded versions, the destination operand is updated at the specified granularity (8, 16, 32, or 64 bits) according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "MOVHLPS",
    "Brief": "Move packed single precision floating-point values from high to low quadword",
    "Description": "\nThis instruction cannot be used for memory to register moves.\n\n128-bit two-argument form:\nMoves two packed single precision floating-point values from the high quadword of the second XMM argument (second operand) to the low quadword of the first XMM register (first argument). The quadword at bits 127:64 of the destination operand is left unchanged. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\n128-bit and EVEX three-argument form:\nMoves two packed single precision floating-point values from the high quadword of the third XMM argument (third operand) to the low quadword of the destination (first operand). Copies the high quadword from the second XMM argument (second operand) to the high quadword of the destination (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nIf VMOVHLPS is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L'L= 1 will cause an #UD exception.\n",
    "Alias": []
  },
  {
    "Name": "MOVHPD",
    "Brief": "Move high packed double precision floating-point value",
    "Description": "\nThis instruction cannot be used for register to register or memory to memory moves.\n\n128-bit Legacy SSE load:\nMoves a double precision floating-point value from the source 64-bit memory operand and stores it in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.\n\nVEX.128 & EVEX encoded load:\nLoads a double precision floating-point value from the source 64-bit memory operand (the third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source operand (second operand) are copied to the low 64-bits of the destination. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\n128-bit store:\nStores a double precision floating-point value from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).\n\nNote: VMOVHPD (store) (VEX.128.66.0F 17 /r) is legal and has the same behavior as the existing 66 0F 17 store. For VMOVHPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.\n\nIf VMOVHPD is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L'L= 1 will cause an #UD exception.\n",
    "Alias": []
  },
  {
    "Name": "MOVHPS",
    "Brief": "Move High Packed Single Precision Floating-Point Values",
    "Description": "\nThis instruction cannot be used for register to register or memory to memory moves.\n\n128-bit Legacy SSE load:\nMoves two packed single precision floating-point values from the source 64-bit memory operand and stores them in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.\n\nVEX.128 & EVEX encoded load:\nLoads two single precision floating-point values from the source 64-bit memory operand (the third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source operand (the second operand) are copied to the lower 64-bits of the destination. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\n128-bit store:\nStores two packed single precision floating-point values from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).\n\nNote: VMOVHPS (store) is legal and has the same behavior as the existing store. For VMOVHPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.\n",
    "Alias": []
  },
  {
    "Name": "MOVLHPS",
    "Brief": "Move packed single precision floating-point values from low to high quadword",
    "Description": "\nThis instruction cannot be used for memory to register moves.\n\n128-bit two-argument form:\nMoves two packed single precision floating-point values from the low quadword of the second XMM argument (second operand) to the high quadword of the first XMM register (first argument). The low quadword of the destination operand is left unchanged. Bits (MAXVL-1:128) of the corresponding destination register are unmodified.\n\n128-bit three-argument forms:\nMoves two packed single precision floating-point values from the low quadword of the third XMM argument (third operand) to the high quadword of the destination (first operand). Copies the low quadword from the second XMM argument (second operand) to the low quadword of the destination (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nIf VMOVLHPS is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L'L= 1 will cause an #UD exception.\n",
    "Alias": []
  },
  {
    "Name": "MOVLPD",
    "Brief": "Move Low Packed Double Precision Floating-Point Value",
    "Description": "\nThis instruction cannot be used for register to register or memory to memory moves.\n\n128-bit Legacy SSE load:\nMoves a double precision floating-point value from the source 64-bit memory operand and stores it in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.\n\nVEX.128 & EVEX encoded load:\nLoads a double precision floating-point value from the source 64-bit memory operand (third operand), merges it with the upper 64-bits of the first source XMM register (second operand), and stores it in the low 128-bits of the destination XMM register (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\n128-bit store:\nStores a double precision floating-point value from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).\n\nNote: VMOVLPD (store) (VEX.128.66.0F 13 /r) is legal and has the same behavior as the existing 66 0F 13 store. For VMOVLPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.\n\nIf VMOVLPD is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L'L= 1 will cause an #UD exception.\n",
    "Alias": []
  },
  {
    "Name": "MOVLPS",
    "Brief": "Move Low Packed Single Precision Floating-Point Values",
    "Description": "\nThis instruction cannot be used for register to register or memory to memory moves.\n\n128-bit Legacy SSE load:\nMoves two packed single precision floating-point values from the source 64-bit memory operand and stores them in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.\n\nVEX.128 & EVEX encoded load:\nLoads two packed single precision floating-point values from the source 64-bit memory operand (the third operand), merges them with the upper 64-bits of the first source operand (the second operand), and stores them in the low 128-bits of the destination register (the first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\n128-bit store:\nLoads two packed single precision floating-point values from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).\n\nNote: VMOVLPS (store) (VEX.128.0F 13 /r) is legal and has the same behavior as the existing 0F 13 store. For VMOVLPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.\n\nIf VMOVLPS is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L'L= 1 will cause an #UD exception.\n",
    "Alias": []
  },
  {
    "Name": "MOVMSKPD",
    "Brief": "Extract packed double precision floating-point sign mask",
    "Description": "\nExtracts the sign bits from the packed double precision floating-point values in the source operand (second operand), formats them into a 2-bit or 4-bit mask, and stores the mask in the destination operand (first operand). \n\nFor the 128-bit version:\n- The source operand is an XMM register\n- The destination operand is a general-purpose register\n- The mask is stored in the 2 low-order bits of the destination operand\n- The upper bits of the destination are zero-extended\n\nFor the 256-bit version (VEX.256 encoded):\n- The source operand is a YMM register\n- The destination operand is a general-purpose register\n- The mask is stored in the 4 low-order bits of the destination operand\n- The upper bits of the destination are zero-extended\n\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "MOVMSKPS",
    "Brief": "Extract Packed Single Precision Floating-Point Sign Mask",
    "Description": "\nExtracts the sign bits from the packed single precision floating-point values in the source operand (second operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand beyond the mask are filled with zeros.\n\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\n\n128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.\n\nVEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "MOVNTDQ",
    "Brief": "Store Packed Integers Using Non-Temporal Hint",
    "Description": "\nMoves the packed integers in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain integer data (packed bytes, words, double-words, or quadwords). The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (512-bit version) boundary otherwise a general-protection exception (#GP) will be generated.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with VMOVNTDQ instructions if multiple processors might use different memory types to read/write the destination memory locations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "MOVNTDQA",
    "Brief": "Load Double Quadword Non-Temporal Aligned Hint",
    "Description": "\nMOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first operand) using a non-temporal hint if the memory source is WC (write combining) memory type. \n\nFor WC memory type, the nontemporal hint may be implemented by loading a temporary internal buffer with the equivalent of an aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped and flushed. \n\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when reading the data from memory. The processor does not read the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with a MFENCE instruction should be used in conjunction with MOVNTDQA instructions if multiple processors might use different memory types for the referenced memory locations or to synchronize reads of a processor with writes by other agents in the system.\n\nAlignment requirements:\n- 128-bit MOVNTDQA addresses must be 16-byte aligned\n- 256-bit VMOVNTDQA addresses must be 32-byte aligned\n- 512-bit VMOVNTDQA addresses must be 64-byte aligned\n\nViolation of these alignment requirements will cause a #GP exception.\n",
    "Alias": []
  },
  {
    "Name": "VMOVNTDQA",
    "Brief": "Load Double Quadword Non-Temporal Aligned Hint with vector extensions",
    "Description": "\nMOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first operand) using a non-temporal hint if the memory source is WC (write combining) memory type. \n\nFor WC memory type, the nontemporal hint may be implemented by loading a temporary internal buffer with the equivalent of an aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped and flushed. \n\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when reading the data from memory. The processor does not read the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with a MFENCE instruction should be used in conjunction with MOVNTDQA instructions if multiple processors might use different memory types for the referenced memory locations or to synchronize reads of a processor with writes by other agents in the system.\n\nAlignment requirements:\n- 128-bit MOVNTDQA addresses must be 16-byte aligned\n- 256-bit VMOVNTDQA addresses must be 32-byte aligned\n- 512-bit VMOVNTDQA addresses must be 64-byte aligned\n\nViolation of these alignment requirements will cause a #GP exception.\n",
    "Alias": []
  },
  {
    "Name": "MOVNTI",
    "Brief": "Store Doubleword Using Non-Temporal Hint",
    "Description": "\nMoves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a general-purpose register. The destination operand is a 32-bit memory location.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTI instructions if multiple processors might use different memory types to read/write the destination memory locations.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "MOVNTPD",
    "Brief": "Store packed double precision floating-point values using non-temporal hint",
    "Description": "\nMoves the packed double precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed double precision, floating-pointing data. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPD instructions if multiple processors might use different memory types to read/write the destination memory locations.\n",
    "Alias": []
  },
  {
    "Name": "MOVNTPS",
    "Brief": "Store packed single precision floating-point values using non-temporal hint",
    "Description": "\nMoves the packed single precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed single precision floating-point values. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-bit (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple processors might use different memory types to read/write the destination memory locations.\n",
    "Alias": []
  },
  {
    "Name": "VMOVNTPS",
    "Brief": "Store packed single precision floating-point values using non-temporal hint (vector extensions)",
    "Description": "\nMoves the packed single precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed single precision floating-point values. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-bit (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple processors might use different memory types to read/write the destination memory locations.\n",
    "Alias": []
  },
  {
    "Name": "MOVNTQ",
    "Brief": "Store of quadword using non-temporal hint",
    "Description": "\nMoves the quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an MMX technology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The destination operand is a 64-bit memory location.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTQ instructions if multiple processors might use different memory types to read/write the destination memory locations.\n",
    "Alias": []
  },
  {
    "Name": "VMOVQ",
    "Brief": "Vector move quadword (AVX/AVX512 variant of MOVQ)",
    "Description": "\nCopies a quadword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. \n\nThis instruction can be used to:\n- Move a quadword between two MMX technology registers\n- Move a quadword between an MMX technology register and a 64-bit memory location\n- Move data between two XMM registers\n- Move data between an XMM register and a 64-bit memory location\n\nKey characteristics:\n- Cannot transfer data between memory locations\n- When the source is an XMM register, only the low quadword is moved\n- When the destination is an XMM register, the quadword is stored in the low quadword, and the high quadword is cleared to zeros\n- In 64-bit mode, REX prefix can be used to access additional registers (XMM8-XMM15)\n\nVariants (VMOVQ):\n- VEX and EVEX encoded versions support different register and memory operand configurations\n- VEX.vvvv and EVEX.vvvv must be 1111b, otherwise an #UD exception is raised\n- VEX.L=1 will cause an #UD exception\n",
    "Alias": []
  },
  {
    "Name": "MOVQ2DQ",
    "Brief": "Move quadword from MMX technology register to XMM register",
    "Description": "\nMoves the quadword from the source operand (second operand) to the low quadword of the destination operand (first operand). The source operand is an MMX technology register and the destination operand is an XMM register.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVQ2DQ instruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\n\nThe low 64 bits of the destination XMM register are filled with the source MMX register's quadword, and the upper 64 bits are set to zero.\n",
    "Alias": []
  },
  {
    "Name": "MOVS",
    "Brief": "Move data from source string to destination string",
    "Description": "\nMoves the byte, word, doubleword, or quadword specified with the source operand to the location specified with the destination operand. Both the source and destination operands are located in memory.\n\nThe address of the source operand is read from the DS:ESI or DS:SI registers (depending on the address-size attribute). The address of the destination operand is read from the ES:EDI or ES:DI registers. The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operands form (MOVS mnemonic): Allows source and destination operands to be specified explicitly.\n2. No-operands form (MOVSB, MOVSW, MOVSD, MOVSQ): Assumes DS:(E)SI and ES:(E)DI as source and destination, with size determined by the mnemonic.\n\nAfter the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically based on the Direction Flag (DF):\n- If DF = 0: Registers are incremented\n- If DF = 1: Registers are decremented\n\nIncrements/decrements depend on the operation size:\n- Byte operations: 1\n- Word operations: 2\n- Doubleword operations: 4\n- Quadword operations: 8\n\nIn 64-bit mode, the default address size is 64 bits, with 32-bit address size supported using the 67H prefix. Addresses are specified by RSI/RDI (64-bit) or ESI/EDI (32-bit).\n",
    "Alias": []
  },
  {
    "Name": "MOVSB",
    "Brief": "Move byte from source string to destination string",
    "Description": "\nMoves the byte, word, doubleword, or quadword specified with the source operand to the location specified with the destination operand. Both the source and destination operands are located in memory.\n\nThe address of the source operand is read from the DS:ESI or DS:SI registers (depending on the address-size attribute). The address of the destination operand is read from the ES:EDI or ES:DI registers. The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operands form (MOVS mnemonic): Allows source and destination operands to be specified explicitly.\n2. No-operands form (MOVSB, MOVSW, MOVSD, MOVSQ): Assumes DS:(E)SI and ES:(E)DI as source and destination, with size determined by the mnemonic.\n\nAfter the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically based on the Direction Flag (DF):\n- If DF = 0: Registers are incremented\n- If DF = 1: Registers are decremented\n\nIncrements/decrements depend on the operation size:\n- Byte operations: 1\n- Word operations: 2\n- Doubleword operations: 4\n- Quadword operations: 8\n\nIn 64-bit mode, the default address size is 64 bits, with 32-bit address size supported using the 67H prefix. Addresses are specified by RSI/RDI (64-bit) or ESI/EDI (32-bit).\n",
    "Alias": []
  },
  {
    "Name": "MOVSW",
    "Brief": "Move word from source string to destination string",
    "Description": "\nMoves the byte, word, doubleword, or quadword specified with the source operand to the location specified with the destination operand. Both the source and destination operands are located in memory.\n\nThe address of the source operand is read from the DS:ESI or DS:SI registers (depending on the address-size attribute). The address of the destination operand is read from the ES:EDI or ES:DI registers. The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operands form (MOVS mnemonic): Allows source and destination operands to be specified explicitly.\n2. No-operands form (MOVSB, MOVSW, MOVSD, MOVSQ): Assumes DS:(E)SI and ES:(E)DI as source and destination, with size determined by the mnemonic.\n\nAfter the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically based on the Direction Flag (DF):\n- If DF = 0: Registers are incremented\n- If DF = 1: Registers are decremented\n\nIncrements/decrements depend on the operation size:\n- Byte operations: 1\n- Word operations: 2\n- Doubleword operations: 4\n- Quadword operations: 8\n\nIn 64-bit mode, the default address size is 64 bits, with 32-bit address size supported using the 67H prefix. Addresses are specified by RSI/RDI (64-bit) or ESI/EDI (32-bit).\n",
    "Alias": []
  },
  {
    "Name": "MOVSD",
    "Brief": "Move doubleword from source string to destination string",
    "Description": "\nMoves the byte, word, doubleword, or quadword specified with the source operand to the location specified with the destination operand. Both the source and destination operands are located in memory.\n\nThe address of the source operand is read from the DS:ESI or DS:SI registers (depending on the address-size attribute). The address of the destination operand is read from the ES:EDI or ES:DI registers. The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operands form (MOVS mnemonic): Allows source and destination operands to be specified explicitly.\n2. No-operands form (MOVSB, MOVSW, MOVSD, MOVSQ): Assumes DS:(E)SI and ES:(E)DI as source and destination, with size determined by the mnemonic.\n\nAfter the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically based on the Direction Flag (DF):\n- If DF = 0: Registers are incremented\n- If DF = 1: Registers are decremented\n\nIncrements/decrements depend on the operation size:\n- Byte operations: 1\n- Word operations: 2\n- Doubleword operations: 4\n- Quadword operations: 8\n\nIn 64-bit mode, the default address size is 64 bits, with 32-bit address size supported using the 67H prefix. Addresses are specified by RSI/RDI (64-bit) or ESI/EDI (32-bit).\n",
    "Alias": []
  },
  {
    "Name": "MOVSQ",
    "Brief": "Move quadword from source string to destination string",
    "Description": "\nMoves the byte, word, doubleword, or quadword specified with the source operand to the location specified with the destination operand. Both the source and destination operands are located in memory.\n\nThe address of the source operand is read from the DS:ESI or DS:SI registers (depending on the address-size attribute). The address of the destination operand is read from the ES:EDI or ES:DI registers. The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operands form (MOVS mnemonic): Allows source and destination operands to be specified explicitly.\n2. No-operands form (MOVSB, MOVSW, MOVSD, MOVSQ): Assumes DS:(E)SI and ES:(E)DI as source and destination, with size determined by the mnemonic.\n\nAfter the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically based on the Direction Flag (DF):\n- If DF = 0: Registers are incremented\n- If DF = 1: Registers are decremented\n\nIncrements/decrements depend on the operation size:\n- Byte operations: 1\n- Word operations: 2\n- Doubleword operations: 4\n- Quadword operations: 8\n\nIn 64-bit mode, the default address size is 64 bits, with 32-bit address size supported using the 67H prefix. Addresses are specified by RSI/RDI (64-bit) or ESI/EDI (32-bit).\n",
    "Alias": []
  },
  {
    "Name": "MOVSHDUP",
    "Brief": "Replicate odd-indexed single precision floating-point values",
    "Description": "\nDuplicates odd-indexed single precision floating-point values from the source operand (the second operand) to adjacent element pairs in the destination operand (the first operand).\n\nThe source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.\n\nKey characteristics of different versions:\n- 128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged\n- VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed\n- VEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed\n- EVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask\n\nThe instruction effectively takes a source vector and creates a new vector where each pair of elements is the duplicated value from an odd-indexed element of the source.\n",
    "Alias": []
  },
  {
    "Name": "MOVSLDUP",
    "Brief": "Replicate single precision floating-point values from even indices",
    "Description": "\nDuplicates even-indexed single precision floating-point values from the source operand (the second operand). The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.\n\nVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.\n\nThe instruction works by taking the 32-bit values at even indices (0, 2, 4, etc.) and duplicating them in their respective destination positions. For example, in a 128-bit register, the value at index 0 will be copied to both the 0 and 1 positions, and the value at index 2 will be copied to both the 2 and 3 positions.\n",
    "Alias": []
  },
  {
    "Name": "VMOVSLDUP",
    "Brief": "Replicate single precision floating-point values from even indices with vector extensions",
    "Description": "\nDuplicates even-indexed single precision floating-point values from the source operand (the second operand). The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.\n\nVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.\n\nThe instruction works by taking the 32-bit values at even indices (0, 2, 4, etc.) and duplicating them in their respective destination positions. For example, in a 128-bit register, the value at index 0 will be copied to both the 0 and 1 positions, and the value at index 2 will be copied to both the 2 and 3 positions.\n",
    "Alias": []
  },
  {
    "Name": "MOVSS",
    "Brief": "Move or Merge Scalar Single Precision Floating-Point Value",
    "Description": "\nMoves a scalar single precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to:\n- Move a single precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location\n- Move a single precision floating-point value between the low doublewords of two XMM registers\n\nKey variations in behavior:\n- Legacy SSE version: Bits outside the low 32 bits remain unmodified or zeroed depending on the source/destination\n- VEX and EVEX versions: \n  * Bits 127:32 are copied from the first source operand\n  * Bits MAXVL-1:128 are zeroed\n- EVEX versions support write masking, allowing conditional updates to the low doubleword\n\nRestrictions:\n- Cannot transfer data between memory locations\n- For memory store forms, VEX.vvvv/EVEX.vvvv must be 1111b\n- Software should use VEX.L=0 to avoid unpredictable behavior\n\nThe instruction supports various encoding formats for different scenarios: memory load/store, register-to-register moves, and masked operations.\n",
    "Alias": []
  },
  {
    "Name": "VMOVSS",
    "Brief": "Vector Move or Merge Scalar Single Precision Floating-Point Value",
    "Description": "\nMoves a scalar single precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to:\n- Move a single precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location\n- Move a single precision floating-point value between the low doublewords of two XMM registers\n\nKey variations in behavior:\n- Legacy SSE version: Bits outside the low 32 bits remain unmodified or zeroed depending on the source/destination\n- VEX and EVEX versions: \n  * Bits 127:32 are copied from the first source operand\n  * Bits MAXVL-1:128 are zeroed\n- EVEX versions support write masking, allowing conditional updates to the low doubleword\n\nRestrictions:\n- Cannot transfer data between memory locations\n- For memory store forms, VEX.vvvv/EVEX.vvvv must be 1111b\n- Software should use VEX.L=0 to avoid unpredictable behavior\n\nThe instruction supports various encoding formats for different scenarios: memory load/store, register-to-register moves, and masked operations.\n",
    "Alias": []
  },
  {
    "Name": "MOVSX",
    "Brief": "Move with sign-extension from smaller to larger register sizes",
    "Description": "\nCopies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16, 32, or 64 bits. The size of the converted value depends on the operand-size attribute.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nThe instruction can perform the following sign-extension operations:\n- Byte to word\n- Byte to doubleword\n- Byte to quadword\n- Word to doubleword\n- Word to quadword\n- Doubleword to quadword\n\nNote: In 64-bit mode, using MOVSXD without REX.W is discouraged, and a regular MOV instruction should be used instead.\n",
    "Alias": []
  },
  {
    "Name": "MOVSXD",
    "Brief": "Move with sign-extension from 32-bit to 64-bit register",
    "Description": "\nCopies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16, 32, or 64 bits. The size of the converted value depends on the operand-size attribute.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nThe instruction can perform the following sign-extension operations:\n- Byte to word\n- Byte to doubleword\n- Byte to quadword\n- Word to doubleword\n- Word to quadword\n- Doubleword to quadword\n\nNote: In 64-bit mode, using MOVSXD without REX.W is discouraged, and a regular MOV instruction should be used instead.\n",
    "Alias": []
  },
  {
    "Name": "MOVUPD",
    "Brief": "Move unaligned packed double precision floating-point values",
    "Description": "\nMoves packed double precision floating-point values from the source operand to the destination operand. This instruction supports various versions with different vector register sizes:\n\nEVEX.512 encoded version:\n- Moves 512 bits of packed double precision floating-point values\n- Can load a ZMM register from a memory location or store a ZMM register to memory\n- Destination is updated according to the writemask\n\nVEX.256 encoded version:\n- Moves 256 bits of packed double precision floating-point values\n- Can load a YMM register from a 256-bit memory location or move data between YMM registers\n- Bits (MAXVL-1:256) of the destination register are zeroed\n\n128-bit versions:\n- Moves 128 bits of packed double precision floating-point values\n- Can load an XMM register from a 128-bit memory location or move data between XMM registers\n- In legacy SSE version, bits (MAXVL-1:128) of the destination register remain unchanged\n\nWhen the source or destination operand is a memory operand, it can be unaligned on a 16-byte boundary without causing a general-protection exception.\n\nVEX.128 and EVEX.128 encoded versions zero bits (MAXVL-1:128) of the destination register.\n",
    "Alias": []
  },
  {
    "Name": "VMOVUPD",
    "Brief": "Vector move unaligned packed double precision floating-point values",
    "Description": "\nMoves packed double precision floating-point values from the source operand to the destination operand. This instruction supports various versions with different vector register sizes:\n\nEVEX.512 encoded version:\n- Moves 512 bits of packed double precision floating-point values\n- Can load a ZMM register from a memory location or store a ZMM register to memory\n- Destination is updated according to the writemask\n\nVEX.256 encoded version:\n- Moves 256 bits of packed double precision floating-point values\n- Can load a YMM register from a 256-bit memory location or move data between YMM registers\n- Bits (MAXVL-1:256) of the destination register are zeroed\n\n128-bit versions:\n- Moves 128 bits of packed double precision floating-point values\n- Can load an XMM register from a 128-bit memory location or move data between XMM registers\n- In legacy SSE version, bits (MAXVL-1:128) of the destination register remain unchanged\n\nWhen the source or destination operand is a memory operand, it can be unaligned on a 16-byte boundary without causing a general-protection exception.\n\nVEX.128 and EVEX.128 encoded versions zero bits (MAXVL-1:128) of the destination register.\n",
    "Alias": []
  },
  {
    "Name": "MOVUPS",
    "Brief": "Move unaligned packed single precision floating-point values",
    "Description": "\nMoves packed single precision floating-point values from the source operand to the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and can be used to:\n\n- Load a vector register from a memory location\n- Store a vector register to a memory location\n- Move data between vector registers\n\nKey characteristics:\n- Supports unaligned memory access without causing a general-protection exception\n- VEX and EVEX encoded versions support:\n  * 128-bit XMM registers\n  * 256-bit YMM registers\n  * 512-bit ZMM registers\n- EVEX versions support:\n  * Writemask (k1) for conditional move\n  * Merging and zeroing mask behaviors\n\nFor VEX/EVEX versions:\n- 128-bit version: Upper bits of destination register are zeroed\n- 256-bit version: Upper bits of destination register are zeroed\n- 512-bit version: Full register can be moved with optional masking\n\nLegacy SSE version (128-bit) leaves upper bits of destination register unchanged.\n",
    "Alias": []
  },
  {
    "Name": "VMOVUPS",
    "Brief": "Move unaligned packed single precision floating-point values with VEX/EVEX encoding",
    "Description": "\nMoves packed single precision floating-point values from the source operand to the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and can be used to:\n\n- Load a vector register from a memory location\n- Store a vector register to a memory location\n- Move data between vector registers\n\nKey characteristics:\n- Supports unaligned memory access without causing a general-protection exception\n- VEX and EVEX encoded versions support:\n  * 128-bit XMM registers\n  * 256-bit YMM registers\n  * 512-bit ZMM registers\n- EVEX versions support:\n  * Writemask (k1) for conditional move\n  * Merging and zeroing mask behaviors\n\nFor VEX/EVEX versions:\n- 128-bit version: Upper bits of destination register are zeroed\n- 256-bit version: Upper bits of destination register are zeroed\n- 512-bit version: Full register can be moved with optional masking\n\nLegacy SSE version (128-bit) leaves upper bits of destination register unchanged.\n",
    "Alias": []
  },
  {
    "Name": "MOVZX",
    "Brief": "Move with zero-extension",
    "Description": "\nCopies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value. The size of the converted value depends on the operand-size attribute.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bit operands.\n\nThe instruction supports zero-extending:\n- Byte to word\n- Byte to doubleword\n- Byte to quadword\n- Word to doubleword\n- Word to quadword\n\nNote: In 64-bit mode with REX prefix, r/m8 cannot access AH, BH, CH, DH byte registers.\n",
    "Alias": []
  },
  {
    "Name": "MPSADBW",
    "Brief": "Compute Multiple Packed Sums of Absolute Difference",
    "Description": "\nMPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks of 32-bit dword elements, using two select fields in the immediate byte to select the offsets of the two blocks within the first source operand and the second operand.\n\nThe instruction operates in different modes:\n1. 128-bit Legacy SSE version: Works on a single 128-bit lane\n2. VEX.128 version: Works on a single 128-bit lane with upper bits zeroed\n3. VEX.256 version: Performs SAD operations on two 128-bit lanes, with results in lower and upper 128 bits of the destination\n\nKey characteristics:\n- Uses an 8-bit immediate value to select block offsets\n- Computes absolute differences between bytes\n- Sums the absolute differences into 16-bit word results\n- Supports flexible block selection within source operands\n\nThe immediate byte (imm8) controls:\n- Block 2 offset within second source operand (bits 1:0)\n- Block 1 offset within first source operand (bit 2)\n- Additional block offsets for 256-bit version (bits 4:3, 5)\n",
    "Alias": []
  },
  {
    "Name": "MUL",
    "Brief": "Unsigned multiply of source and destination operands",
    "Description": "\nPerforms an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location.\n\nThe result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size), with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nThe operand size determines the multiplication behavior:\n- Byte: AL * r/m8 = Result in AX\n- Word: AX * r/m16 = Result in DX:AX\n- Doubleword: EAX * r/m32 = Result in EDX:EAX\n- Quadword: RAX * r/m64 = Result in RDX:RAX\n\nThe OF and CF flags are set to 0 if the upper half of the result is 0; otherwise, they are set to 1. The SF, ZF, AF, and PF flags are undefined.\n",
    "Alias": []
  },
  {
    "Name": "MULPD",
    "Brief": "Multiply packed double precision floating-point values",
    "Description": "\nMultiply packed double precision floating-point values from the first source operand with corresponding values in the second source operand, and stores the packed double precision floating-point results in the destination operand.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the destination YMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "MULPS",
    "Brief": "Multiply packed single precision floating-point values",
    "Description": "\nMultiply the packed single precision floating-point values from the first source operand with the corresponding values in the second source operand, and stores the packed double precision floating-point results in the destination operand.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the destination YMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "MULSD",
    "Brief": "Multiply low double precision floating-point value",
    "Description": "\nMultiplies the low double precision floating-point value in the second source operand by the low double precision floating-point value in the first source operand, and stores the double precision floating-point result in the destination operand.\n\nThe second source operand can be an XMM register or a 64-bit memory location. The first source operand and the destination operands are XMM registers.\n\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX encoded version: The quadword at bits 127:64 of the destination operand is copied from the same bits of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX encoded version: The low quadword element of the destination operand is updated according to the write-mask.\n\nSoftware should ensure VMULSD is encoded with VEX.L=0. Encoding VMULSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "MULSS",
    "Brief": "Multiply scalar single precision floating-point values",
    "Description": "\nMultiplies the low single precision floating-point value from the second source operand by the low single precision floating-point value in the first source operand, and stores the single precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source operand and the destination operands are XMM registers.\n\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the write-mask.\n\nSoftware should ensure VMULSS is encoded with VEX.L=0. Encoding VMULSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "MULX",
    "Brief": "Unsigned multiply without affecting arithmetic flags",
    "Description": "\nPerforms an unsigned multiplication of the implicit source operand (EDX/RDX) and the specified source operand (the third operand) and stores the low half of the result in the second destination (second operand), the high half of the result in the first destination operand (first operand), without reading or writing the arithmetic flags.\n\nThis enables efficient programming where the software can interleave add with carry operations and multiplications. If the first and second operand are identical, it will contain the high half of the multiplication result.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n",
    "Alias": []
  },
  {
    "Name": "MWAIT",
    "Brief": "Provides hints to allow the processor to enter an implementation-dependent optimized state",
    "Description": "\nMWAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state. There are two principal targeted usages: address-range monitoring and advanced power management. Both usages of MWAIT require the use of the MONITOR instruction.\n\nFor address-range monitoring, the MWAIT instruction operates with the MONITOR instruction. The two instructions allow the definition of an address at which to wait (MONITOR) and an implementation-dependent-optimized operation to commence at the wait address (MWAIT). The execution of MWAIT is a hint to the processor that it can enter an implementation-dependent-optimized state while waiting for an event or a store operation to the address range armed by MONITOR.\n\nFor power management, MWAIT accepts a hint and optional extension to the processor that it can enter a specified target C state while waiting for an event or a store operation to the address range armed by MONITOR. EAX and ECX are used to communicate additional information, such as the kind of optimized state the processor should enter.\n\nThe processor will exit the implementation-dependent-optimized state due to events like a store to the monitored address range, NMI, SMI, debug exception, machine check exception, BINIT#, INIT#, and RESET# signals. External interrupts may also cause the processor to exit the state under certain conditions.\n\nNote that MWAIT may only be executed at privilege level 0, and its availability is indicated by the CPUID.01H:ECX.MONITOR feature flag.\n",
    "Alias": []
  },
  {
    "Name": "NEG",
    "Brief": "Two's complement negation of the operand",
    "Description": "\nReplaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe instruction sets the carry flag (CF) to 0 if the source operand is 0; otherwise it is set to 1. The OF, SF, ZF, AF, and PF flags are set according to the result.\n",
    "Alias": []
  },
  {
    "Name": "NOP",
    "Brief": "No Operation instruction that performs no operation and takes up space in the instruction stream",
    "Description": "\nThis instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction stream but does not impact machine context, except for the EIP register.\n\nThe multi-byte form of NOP is available on processors with specific CPUID model encoding. The multi-byte NOP instruction does not alter the content of a register and will not issue a memory operation.\n\nThe one-byte NOP instruction is an alias mnemonic for the XCHG (E)AX, (E)AX instruction. The multi-byte NOP instruction performs no operation on supported processors and generates an undefined opcode exception on processors that do not support the multi-byte NOP instruction.\n\nFor situations requiring multiple-byte NOPs, the documentation provides recommended byte sequences ranging from 2 to 9 bytes in length, which can be used to create precise \"no operation\" instruction sequences.\n",
    "Alias": []
  },
  {
    "Name": "NOT",
    "Brief": "Performs a bitwise NOT operation on the destination operand",
    "Description": "\nPerforms a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe instruction supports different operand sizes:\n- r/m8: Reverses each bit of an 8-bit operand\n- r/m16: Reverses each bit of a 16-bit operand\n- r/m32: Reverses each bit of a 32-bit operand\n- r/m64: Reverses each bit of a 64-bit operand\n\nIn 64-bit mode with a REX prefix, byte registers AH, BH, CH, and DH cannot be accessed.\n",
    "Alias": []
  },
  {
    "Name": "OR",
    "Brief": "Performs a bitwise inclusive OR operation between the destination and source operands",
    "Description": "\nPerforms a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) \n\nEach bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.\n",
    "Alias": []
  },
  {
    "Name": "ORPD",
    "Brief": "Bitwise Logical OR of Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms a bitwise logical OR of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VORPD",
    "Brief": "Bitwise Logical OR of Packed Double Precision Floating-Point Values (VEX/EVEX encoded)",
    "Description": "\nPerforms a bitwise logical OR of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "ORPS",
    "Brief": "Bitwise logical OR of packed single precision floating-point values",
    "Description": "\nPerforms a bitwise logical OR of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VORPS",
    "Brief": "Bitwise logical OR of packed single precision floating-point values (vector variant)",
    "Description": "\nPerforms a bitwise logical OR of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "OUT",
    "Brief": "Output to I/O Port",
    "Description": "\nCopies the value from the source operand to the I/O port specified by the destination operand. The source operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). The destination operand can be a byte-immediate or the DX register.\n\nUsing a byte immediate allows I/O port addresses 0 to 255 to be accessed, while using the DX register allows I/O ports from 0 to 65,535 to be accessed.\n\nThe size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\n\nAt the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports, with the upper eight bits of the port address being 0.\n\nThis instruction is only useful for accessing I/O ports located in the processor's I/O address space. In protected mode with CPL > IOPL or virtual-8086 mode, the instruction checks I/O permission bits in the Task State Segment (TSS) before allowing the I/O operation.\n\nIn real mode or protected mode with CPL ≤ IOPL, the instruction directly writes to the selected I/O port.\n",
    "Alias": []
  },
  {
    "Name": "OUTS",
    "Brief": "Output string from memory to I/O port",
    "Description": "\nCopies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register.\n\nThe size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\n\nTwo forms of this instruction are allowed:\n1. Explicit-operands form (OUTS): Allows source and destination operands to be specified explicitly.\n2. No-operands form (OUTSB, OUTSW, OUTSD): Provides short forms with assumed DS:(E)SI source and DX destination.\n\nAfter the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nIn 64-bit mode, the default operand size is 32 bits, and the default address size is 64 bits (using RSI). 32-bit addressing using ESI is supported with the 67H prefix.\n\nThe OUTS instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords.\n",
    "Alias": []
  },
  {
    "Name": "OUTSB",
    "Brief": "Output byte from memory to I/O port",
    "Description": "\nCopies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register.\n\nThe size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\n\nTwo forms of this instruction are allowed:\n1. Explicit-operands form (OUTS): Allows source and destination operands to be specified explicitly.\n2. No-operands form (OUTSB, OUTSW, OUTSD): Provides short forms with assumed DS:(E)SI source and DX destination.\n\nAfter the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nIn 64-bit mode, the default operand size is 32 bits, and the default address size is 64 bits (using RSI). 32-bit addressing using ESI is supported with the 67H prefix.\n\nThe OUTS instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords.\n",
    "Alias": []
  },
  {
    "Name": "OUTSW",
    "Brief": "Output word from memory to I/O port",
    "Description": "\nCopies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register.\n\nThe size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\n\nTwo forms of this instruction are allowed:\n1. Explicit-operands form (OUTS): Allows source and destination operands to be specified explicitly.\n2. No-operands form (OUTSB, OUTSW, OUTSD): Provides short forms with assumed DS:(E)SI source and DX destination.\n\nAfter the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nIn 64-bit mode, the default operand size is 32 bits, and the default address size is 64 bits (using RSI). 32-bit addressing using ESI is supported with the 67H prefix.\n\nThe OUTS instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords.\n",
    "Alias": []
  },
  {
    "Name": "OUTSD",
    "Brief": "Output doubleword from memory to I/O port",
    "Description": "\nCopies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register.\n\nThe size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\n\nTwo forms of this instruction are allowed:\n1. Explicit-operands form (OUTS): Allows source and destination operands to be specified explicitly.\n2. No-operands form (OUTSB, OUTSW, OUTSD): Provides short forms with assumed DS:(E)SI source and DX destination.\n\nAfter the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n\nIn 64-bit mode, the default operand size is 32 bits, and the default address size is 64 bits (using RSI). 32-bit addressing using ESI is supported with the 67H prefix.\n\nThe OUTS instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords.\n",
    "Alias": []
  },
  {
    "Name": "PABSB",
    "Brief": "Compute the absolute value of signed bytes and store unsigned result",
    "Description": "\nPABSB/W/D/Q instructions compute the absolute value of each data element of the source operand and store the UNSIGNED results in the destination operand. \n\nSpecific details:\n- PABSB operates on signed bytes\n- PABSW operates on signed 16-bit words\n- PABSD operates on signed 32-bit integers\n- PABSQ operates on signed 64-bit integers\n\nEVEX encoded versions have additional features:\n- Support for larger vector lengths (128, 256, 512 bits)\n- Write mask support for conditional processing\n- Broadcast mode for some variants\n\nFor EVEX encoded instructions:\n- Source can be a ZMM/YMM/XMM register, memory location, or broadcasted from a memory location\n- Destination is a ZMM/YMM/XMM register updated according to the write mask\n- Upper bits of destination register can be zeroed or left unchanged based on masking mode\n\nVEX encoded versions provide similar functionality for 128-bit and 256-bit vectors with upper bits of destination register zeroed.\n\nLegacy SSE versions operate on 128-bit vectors with upper bits of destination register unmodified.\n",
    "Alias": []
  },
  {
    "Name": "PABSW",
    "Brief": "Compute the absolute value of signed 16-bit words and store unsigned result",
    "Description": "\nPABSB/W/D/Q instructions compute the absolute value of each data element of the source operand and store the UNSIGNED results in the destination operand. \n\nSpecific details:\n- PABSB operates on signed bytes\n- PABSW operates on signed 16-bit words\n- PABSD operates on signed 32-bit integers\n- PABSQ operates on signed 64-bit integers\n\nEVEX encoded versions have additional features:\n- Support for larger vector lengths (128, 256, 512 bits)\n- Write mask support for conditional processing\n- Broadcast mode for some variants\n\nFor EVEX encoded instructions:\n- Source can be a ZMM/YMM/XMM register, memory location, or broadcasted from a memory location\n- Destination is a ZMM/YMM/XMM register updated according to the write mask\n- Upper bits of destination register can be zeroed or left unchanged based on masking mode\n\nVEX encoded versions provide similar functionality for 128-bit and 256-bit vectors with upper bits of destination register zeroed.\n\nLegacy SSE versions operate on 128-bit vectors with upper bits of destination register unmodified.\n",
    "Alias": []
  },
  {
    "Name": "PABSD",
    "Brief": "Compute the absolute value of signed 32-bit integers and store unsigned result",
    "Description": "\nPABSB/W/D/Q instructions compute the absolute value of each data element of the source operand and store the UNSIGNED results in the destination operand. \n\nSpecific details:\n- PABSB operates on signed bytes\n- PABSW operates on signed 16-bit words\n- PABSD operates on signed 32-bit integers\n- PABSQ operates on signed 64-bit integers\n\nEVEX encoded versions have additional features:\n- Support for larger vector lengths (128, 256, 512 bits)\n- Write mask support for conditional processing\n- Broadcast mode for some variants\n\nFor EVEX encoded instructions:\n- Source can be a ZMM/YMM/XMM register, memory location, or broadcasted from a memory location\n- Destination is a ZMM/YMM/XMM register updated according to the write mask\n- Upper bits of destination register can be zeroed or left unchanged based on masking mode\n\nVEX encoded versions provide similar functionality for 128-bit and 256-bit vectors with upper bits of destination register zeroed.\n\nLegacy SSE versions operate on 128-bit vectors with upper bits of destination register unmodified.\n",
    "Alias": []
  },
  {
    "Name": "PABSQ",
    "Brief": "Compute the absolute value of signed 64-bit integers and store unsigned result",
    "Description": "\nPABSB/W/D/Q instructions compute the absolute value of each data element of the source operand and store the UNSIGNED results in the destination operand. \n\nSpecific details:\n- PABSB operates on signed bytes\n- PABSW operates on signed 16-bit words\n- PABSD operates on signed 32-bit integers\n- PABSQ operates on signed 64-bit integers\n\nEVEX encoded versions have additional features:\n- Support for larger vector lengths (128, 256, 512 bits)\n- Write mask support for conditional processing\n- Broadcast mode for some variants\n\nFor EVEX encoded instructions:\n- Source can be a ZMM/YMM/XMM register, memory location, or broadcasted from a memory location\n- Destination is a ZMM/YMM/XMM register updated according to the write mask\n- Upper bits of destination register can be zeroed or left unchanged based on masking mode\n\nVEX encoded versions provide similar functionality for 128-bit and 256-bit vectors with upper bits of destination register zeroed.\n\nLegacy SSE versions operate on 128-bit vectors with upper bits of destination register unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VPABSB",
    "Brief": "Compute the absolute value of signed bytes and store unsigned result with support for vector lengths and write masks",
    "Description": "\nPABSB/W/D/Q instructions compute the absolute value of each data element of the source operand and store the UNSIGNED results in the destination operand. \n\nSpecific details:\n- PABSB operates on signed bytes\n- PABSW operates on signed 16-bit words\n- PABSD operates on signed 32-bit integers\n- PABSQ operates on signed 64-bit integers\n\nEVEX encoded versions have additional features:\n- Support for larger vector lengths (128, 256, 512 bits)\n- Write mask support for conditional processing\n- Broadcast mode for some variants\n\nFor EVEX encoded instructions:\n- Source can be a ZMM/YMM/XMM register, memory location, or broadcasted from a memory location\n- Destination is a ZMM/YMM/XMM register updated according to the write mask\n- Upper bits of destination register can be zeroed or left unchanged based on masking mode\n\nVEX encoded versions provide similar functionality for 128-bit and 256-bit vectors with upper bits of destination register zeroed.\n\nLegacy SSE versions operate on 128-bit vectors with upper bits of destination register unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VPABSW",
    "Brief": "Compute the absolute value of signed 16-bit words and store unsigned result with support for vector lengths and write masks",
    "Description": "\nPABSB/W/D/Q instructions compute the absolute value of each data element of the source operand and store the UNSIGNED results in the destination operand. \n\nSpecific details:\n- PABSB operates on signed bytes\n- PABSW operates on signed 16-bit words\n- PABSD operates on signed 32-bit integers\n- PABSQ operates on signed 64-bit integers\n\nEVEX encoded versions have additional features:\n- Support for larger vector lengths (128, 256, 512 bits)\n- Write mask support for conditional processing\n- Broadcast mode for some variants\n\nFor EVEX encoded instructions:\n- Source can be a ZMM/YMM/XMM register, memory location, or broadcasted from a memory location\n- Destination is a ZMM/YMM/XMM register updated according to the write mask\n- Upper bits of destination register can be zeroed or left unchanged based on masking mode\n\nVEX encoded versions provide similar functionality for 128-bit and 256-bit vectors with upper bits of destination register zeroed.\n\nLegacy SSE versions operate on 128-bit vectors with upper bits of destination register unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VPABSD",
    "Brief": "Compute the absolute value of signed 32-bit integers and store unsigned result with support for vector lengths and write masks",
    "Description": "\nPABSB/W/D/Q instructions compute the absolute value of each data element of the source operand and store the UNSIGNED results in the destination operand. \n\nSpecific details:\n- PABSB operates on signed bytes\n- PABSW operates on signed 16-bit words\n- PABSD operates on signed 32-bit integers\n- PABSQ operates on signed 64-bit integers\n\nEVEX encoded versions have additional features:\n- Support for larger vector lengths (128, 256, 512 bits)\n- Write mask support for conditional processing\n- Broadcast mode for some variants\n\nFor EVEX encoded instructions:\n- Source can be a ZMM/YMM/XMM register, memory location, or broadcasted from a memory location\n- Destination is a ZMM/YMM/XMM register updated according to the write mask\n- Upper bits of destination register can be zeroed or left unchanged based on masking mode\n\nVEX encoded versions provide similar functionality for 128-bit and 256-bit vectors with upper bits of destination register zeroed.\n\nLegacy SSE versions operate on 128-bit vectors with upper bits of destination register unmodified.\n",
    "Alias": []
  },
  {
    "Name": "VPABSQ",
    "Brief": "Compute the absolute value of signed 64-bit integers and store unsigned result with support for vector lengths and write masks",
    "Description": "\nPABSB/W/D/Q instructions compute the absolute value of each data element of the source operand and store the UNSIGNED results in the destination operand. \n\nSpecific details:\n- PABSB operates on signed bytes\n- PABSW operates on signed 16-bit words\n- PABSD operates on signed 32-bit integers\n- PABSQ operates on signed 64-bit integers\n\nEVEX encoded versions have additional features:\n- Support for larger vector lengths (128, 256, 512 bits)\n- Write mask support for conditional processing\n- Broadcast mode for some variants\n\nFor EVEX encoded instructions:\n- Source can be a ZMM/YMM/XMM register, memory location, or broadcasted from a memory location\n- Destination is a ZMM/YMM/XMM register updated according to the write mask\n- Upper bits of destination register can be zeroed or left unchanged based on masking mode\n\nVEX encoded versions provide similar functionality for 128-bit and 256-bit vectors with upper bits of destination register zeroed.\n\nLegacy SSE versions operate on 128-bit vectors with upper bits of destination register unmodified.\n",
    "Alias": []
  },
  {
    "Name": "PACKSSWB",
    "Brief": "Convert packed signed word integers into packed signed byte integers using signed saturation",
    "Description": "\nConverts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions.\n\nPACKSSWB converts packed signed word integers in the first and second source operands into packed signed byte integers using signed saturation to handle overflow conditions beyond the range of signed byte integers. If the signed word value is beyond the range of a signed byte value (i.e., greater than 7FH or less than 80H), the saturated signed byte integer value of 7FH or 80H, respectively, is stored in the destination.\n\nPACKSSDW converts packed signed doubleword integers in the first and second source operands into packed signed word integers using signed saturation to handle overflow conditions beyond 7FFFH and 8000H.\n\nThe instruction supports various vector register sizes (MMX, SSE, AVX, AVX-512) and provides different encoding variants with different operand handling and register sizes. The EVEX-encoded versions support write masking and can operate on larger vector registers (up to 512 bits).\n\nKey characteristics:\n- Handles integer overflow using signed saturation\n- Supports multiple register sizes and vector lengths\n- Provides both legacy and advanced vector extensions (AVX, AVX-512) versions\n- Can convert between different integer sizes while preserving the sign\n",
    "Alias": []
  },
  {
    "Name": "PACKSSDW",
    "Brief": "Convert packed signed doubleword integers into packed signed word integers using signed saturation",
    "Description": "\nConverts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions.\n\nPACKSSWB converts packed signed word integers in the first and second source operands into packed signed byte integers using signed saturation to handle overflow conditions beyond the range of signed byte integers. If the signed word value is beyond the range of a signed byte value (i.e., greater than 7FH or less than 80H), the saturated signed byte integer value of 7FH or 80H, respectively, is stored in the destination.\n\nPACKSSDW converts packed signed doubleword integers in the first and second source operands into packed signed word integers using signed saturation to handle overflow conditions beyond 7FFFH and 8000H.\n\nThe instruction supports various vector register sizes (MMX, SSE, AVX, AVX-512) and provides different encoding variants with different operand handling and register sizes. The EVEX-encoded versions support write masking and can operate on larger vector registers (up to 512 bits).\n\nKey characteristics:\n- Handles integer overflow using signed saturation\n- Supports multiple register sizes and vector lengths\n- Provides both legacy and advanced vector extensions (AVX, AVX-512) versions\n- Can convert between different integer sizes while preserving the sign\n",
    "Alias": []
  },
  {
    "Name": "PACKUSDW",
    "Brief": "Pack signed doubleword integers to unsigned word integers with unsigned saturation",
    "Description": "\nConverts packed signed doubleword integers in the first and second source operands into packed unsigned word integers using unsigned saturation to handle overflow conditions. If the signed doubleword value is beyond the range of an unsigned word (that is, greater than FFFFH or less than 0000H), the saturated unsigned word integer value of FFFFH or 0000H, respectively, is stored in the destination.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, updated conditionally under the writemask k1.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding destination register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "PACKUSWB",
    "Brief": "Pack signed word integers into unsigned byte integers with saturation",
    "Description": "\nConverts 4, 8, 16, or 32 signed word integers from the destination operand (first operand) and 4, 8, 16, or 32 signed word integers from the source operand (second operand) into 8, 16, 32 or 64 unsigned byte integers and stores the result in the destination operand.\n\nIf a signed word integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.\n\nThe instruction supports multiple variants:\n- MMX version: Converts 4 signed word integers to 8 unsigned byte integers\n- SSE version (128-bit): Converts 8 signed word integers to 16 unsigned byte integers\n- AVX version (128-bit and 256-bit): Converts 8 or 16 signed word integers to 16 or 32 unsigned byte integers\n- AVX-512 version (128, 256, and 512-bit): Converts signed word integers to unsigned byte integers with optional write masking\n\nThe instruction performs saturation, ensuring that values outside the unsigned byte range are clamped to 0x00 or 0xFF.\n",
    "Alias": []
  },
  {
    "Name": "PADDB",
    "Brief": "Add packed byte integers",
    "Description": "\nPerforms a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe instructions can be categorized by the size of integers they operate on:\n- PADDB/VPADDB: Add packed byte integers (8-bit)\n- PADDW/VPADDW: Add packed word integers (16-bit)\n- PADDD/VPADDD: Add packed doubleword integers (32-bit)\n- PADDQ/VPADDQ: Add packed quadword integers (64-bit)\n\nOverflow is handled with wraparound: when an individual result is too large to be represented in the target bit width, the result is wrapped around and the low bits are written to the destination operand (the carry is ignored).\n\nThese instructions can operate on either unsigned or signed (two's complement notation) packed integers. However, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. Software must control the ranges of values operated on to prevent undetected overflow conditions.\n\nThe instructions support various vector register sizes (MMX, SSE, AVX, AVX-512) and have different encoding variants with different operand handling and masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "PADDW",
    "Brief": "Add packed word integers",
    "Description": "\nPerforms a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe instructions can be categorized by the size of integers they operate on:\n- PADDB/VPADDB: Add packed byte integers (8-bit)\n- PADDW/VPADDW: Add packed word integers (16-bit)\n- PADDD/VPADDD: Add packed doubleword integers (32-bit)\n- PADDQ/VPADDQ: Add packed quadword integers (64-bit)\n\nOverflow is handled with wraparound: when an individual result is too large to be represented in the target bit width, the result is wrapped around and the low bits are written to the destination operand (the carry is ignored).\n\nThese instructions can operate on either unsigned or signed (two's complement notation) packed integers. However, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. Software must control the ranges of values operated on to prevent undetected overflow conditions.\n\nThe instructions support various vector register sizes (MMX, SSE, AVX, AVX-512) and have different encoding variants with different operand handling and masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "PADDD",
    "Brief": "Add packed doubleword integers",
    "Description": "\nPerforms a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe instructions can be categorized by the size of integers they operate on:\n- PADDB/VPADDB: Add packed byte integers (8-bit)\n- PADDW/VPADDW: Add packed word integers (16-bit)\n- PADDD/VPADDD: Add packed doubleword integers (32-bit)\n- PADDQ/VPADDQ: Add packed quadword integers (64-bit)\n\nOverflow is handled with wraparound: when an individual result is too large to be represented in the target bit width, the result is wrapped around and the low bits are written to the destination operand (the carry is ignored).\n\nThese instructions can operate on either unsigned or signed (two's complement notation) packed integers. However, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. Software must control the ranges of values operated on to prevent undetected overflow conditions.\n\nThe instructions support various vector register sizes (MMX, SSE, AVX, AVX-512) and have different encoding variants with different operand handling and masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "PADDQ",
    "Brief": "Add packed quadword integers",
    "Description": "\nPerforms a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe instructions can be categorized by the size of integers they operate on:\n- PADDB/VPADDB: Add packed byte integers (8-bit)\n- PADDW/VPADDW: Add packed word integers (16-bit)\n- PADDD/VPADDD: Add packed doubleword integers (32-bit)\n- PADDQ/VPADDQ: Add packed quadword integers (64-bit)\n\nOverflow is handled with wraparound: when an individual result is too large to be represented in the target bit width, the result is wrapped around and the low bits are written to the destination operand (the carry is ignored).\n\nThese instructions can operate on either unsigned or signed (two's complement notation) packed integers. However, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. Software must control the ranges of values operated on to prevent undetected overflow conditions.\n\nThe instructions support various vector register sizes (MMX, SSE, AVX, AVX-512) and have different encoding variants with different operand handling and masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "VPADDB",
    "Brief": "Vector add packed byte integers",
    "Description": "\nPerforms a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe instructions can be categorized by the size of integers they operate on:\n- PADDB/VPADDB: Add packed byte integers (8-bit)\n- PADDW/VPADDW: Add packed word integers (16-bit)\n- PADDD/VPADDD: Add packed doubleword integers (32-bit)\n- PADDQ/VPADDQ: Add packed quadword integers (64-bit)\n\nOverflow is handled with wraparound: when an individual result is too large to be represented in the target bit width, the result is wrapped around and the low bits are written to the destination operand (the carry is ignored).\n\nThese instructions can operate on either unsigned or signed (two's complement notation) packed integers. However, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. Software must control the ranges of values operated on to prevent undetected overflow conditions.\n\nThe instructions support various vector register sizes (MMX, SSE, AVX, AVX-512) and have different encoding variants with different operand handling and masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "VPADDW",
    "Brief": "Vector add packed word integers",
    "Description": "\nPerforms a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe instructions can be categorized by the size of integers they operate on:\n- PADDB/VPADDB: Add packed byte integers (8-bit)\n- PADDW/VPADDW: Add packed word integers (16-bit)\n- PADDD/VPADDD: Add packed doubleword integers (32-bit)\n- PADDQ/VPADDQ: Add packed quadword integers (64-bit)\n\nOverflow is handled with wraparound: when an individual result is too large to be represented in the target bit width, the result is wrapped around and the low bits are written to the destination operand (the carry is ignored).\n\nThese instructions can operate on either unsigned or signed (two's complement notation) packed integers. However, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. Software must control the ranges of values operated on to prevent undetected overflow conditions.\n\nThe instructions support various vector register sizes (MMX, SSE, AVX, AVX-512) and have different encoding variants with different operand handling and masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "VPADDD",
    "Brief": "Vector add packed doubleword integers",
    "Description": "\nPerforms a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe instructions can be categorized by the size of integers they operate on:\n- PADDB/VPADDB: Add packed byte integers (8-bit)\n- PADDW/VPADDW: Add packed word integers (16-bit)\n- PADDD/VPADDD: Add packed doubleword integers (32-bit)\n- PADDQ/VPADDQ: Add packed quadword integers (64-bit)\n\nOverflow is handled with wraparound: when an individual result is too large to be represented in the target bit width, the result is wrapped around and the low bits are written to the destination operand (the carry is ignored).\n\nThese instructions can operate on either unsigned or signed (two's complement notation) packed integers. However, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. Software must control the ranges of values operated on to prevent undetected overflow conditions.\n\nThe instructions support various vector register sizes (MMX, SSE, AVX, AVX-512) and have different encoding variants with different operand handling and masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "VPADDQ",
    "Brief": "Vector add packed quadword integers",
    "Description": "\nPerforms a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe instructions can be categorized by the size of integers they operate on:\n- PADDB/VPADDB: Add packed byte integers (8-bit)\n- PADDW/VPADDW: Add packed word integers (16-bit)\n- PADDD/VPADDD: Add packed doubleword integers (32-bit)\n- PADDQ/VPADDQ: Add packed quadword integers (64-bit)\n\nOverflow is handled with wraparound: when an individual result is too large to be represented in the target bit width, the result is wrapped around and the low bits are written to the destination operand (the carry is ignored).\n\nThese instructions can operate on either unsigned or signed (two's complement notation) packed integers. However, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. Software must control the ranges of values operated on to prevent undetected overflow conditions.\n\nThe instructions support various vector register sizes (MMX, SSE, AVX, AVX-512) and have different encoding variants with different operand handling and masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "PADDSB",
    "Brief": "Add packed signed byte integers with signed saturation",
    "Description": "\nPerforms a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nPADDSB performs a SIMD add of the packed signed byte integers with saturation. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\n\nPADDSW performs a SIMD add of the packed signed word integers with saturation. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\n\nThe instruction supports various instruction set extensions like MMX, SSE2, AVX, AVX2, and AVX512. The operand size and register types vary depending on the specific version of the instruction (64-bit MMX, 128-bit SSE, 256-bit AVX, or 512-bit AVX512).\n\nOverflow is handled with signed saturation, meaning that if the result of an addition exceeds the representable range for the data type, the result is \"saturated\" to the maximum or minimum value for that type.\n",
    "Alias": []
  },
  {
    "Name": "PADDSW",
    "Brief": "Add packed signed word integers with signed saturation",
    "Description": "\nPerforms a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nPADDSB performs a SIMD add of the packed signed byte integers with saturation. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\n\nPADDSW performs a SIMD add of the packed signed word integers with saturation. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\n\nThe instruction supports various instruction set extensions like MMX, SSE2, AVX, AVX2, and AVX512. The operand size and register types vary depending on the specific version of the instruction (64-bit MMX, 128-bit SSE, 256-bit AVX, or 512-bit AVX512).\n\nOverflow is handled with signed saturation, meaning that if the result of an addition exceeds the representable range for the data type, the result is \"saturated\" to the maximum or minimum value for that type.\n",
    "Alias": []
  },
  {
    "Name": "PADDUSB",
    "Brief": "Add packed unsigned integers with unsigned saturation for bytes",
    "Description": "\nPerforms a SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nPADDUSB performs a SIMD add of the packed unsigned byte integers with saturation. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.\n\nPADDUSW performs a SIMD add of the packed unsigned word integers with saturation. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.\n\nThe instruction supports various encoding versions:\n- 64-bit MMX registers\n- 128-bit SSE registers\n- 256-bit AVX registers\n- 512-bit AVX-512 registers\n\nEVEX encoded versions support writemask operations, allowing selective updating of destination register elements.\n\nOverflow is handled with unsigned saturation, ensuring that the result never exceeds the maximum value for the given integer size.\n",
    "Alias": []
  },
  {
    "Name": "PADDUSW",
    "Brief": "Add packed unsigned integers with unsigned saturation for words",
    "Description": "\nPerforms a SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nPADDUSB performs a SIMD add of the packed unsigned byte integers with saturation. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.\n\nPADDUSW performs a SIMD add of the packed unsigned word integers with saturation. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.\n\nThe instruction supports various encoding versions:\n- 64-bit MMX registers\n- 128-bit SSE registers\n- 256-bit AVX registers\n- 512-bit AVX-512 registers\n\nEVEX encoded versions support writemask operations, allowing selective updating of destination register elements.\n\nOverflow is handled with unsigned saturation, ensuring that the result never exceeds the maximum value for the given integer size.\n",
    "Alias": []
  },
  {
    "Name": "PALIGNR",
    "Brief": "Packed Align Right - Concatenate destination and source operands, extract byte-aligned result shifted to the right",
    "Description": "\nPALIGNR concatenates the destination operand (the first operand) and the source operand (the second operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant immediate, and extracts the right-aligned result into the destination.\n\nThe first and the second operands can be an MMX, XMM or a YMM register. The immediate value is considered unsigned. Immediate shift counts larger than the 2L (i.e., 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result.\n\nIn 64-bit mode and not encoded by VEX/EVEX prefix, use the REX prefix to access additional registers.\n\nThe instruction supports different variations:\n- For 64-bit operands: Concatenates DEST and SRC, then shifts right\n- For 128-bit operands: Concatenates DEST and SRC, shifts right\n- VEX and EVEX encoded versions support 128-bit, 256-bit, and 512-bit operands with additional features like zero-masking and write-masking\n\nThe key operation is to create a temporary composite by concatenating the source operands, then shifting and extracting a portion of that composite based on the immediate value.\n",
    "Alias": []
  },
  {
    "Name": "PAND",
    "Brief": "Perform bitwise logical AND operation",
    "Description": "\nPerforms a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.\n\nThe instruction has several variants:\n- Legacy MMX/SSE versions work with 64-bit and 128-bit operands\n- VEX-encoded versions support 128-bit and 256-bit vector registers\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit vector registers with additional features like write masking and broadcasting\n\nKey characteristics:\n- Can operate on integer data types (doublewords and quadwords)\n- Supports different register sizes and instruction set extensions (MMX, SSE, AVX, AVX2, AVX-512)\n- In EVEX versions, supports conditional updates using write masks\n- Can broadcast values from memory in EVEX versions\n\nThe result is always a bitwise AND of the source operands, with zero-padding or merging of upper bits depending on the specific instruction variant.\n",
    "Alias": []
  },
  {
    "Name": "VPAND",
    "Brief": "Perform bitwise logical AND operation with vector registers",
    "Description": "\nPerforms a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.\n\nThe instruction has several variants:\n- Legacy MMX/SSE versions work with 64-bit and 128-bit operands\n- VEX-encoded versions support 128-bit and 256-bit vector registers\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit vector registers with additional features like write masking and broadcasting\n\nKey characteristics:\n- Can operate on integer data types (doublewords and quadwords)\n- Supports different register sizes and instruction set extensions (MMX, SSE, AVX, AVX2, AVX-512)\n- In EVEX versions, supports conditional updates using write masks\n- Can broadcast values from memory in EVEX versions\n\nThe result is always a bitwise AND of the source operands, with zero-padding or merging of upper bits depending on the specific instruction variant.\n",
    "Alias": []
  },
  {
    "Name": "VPANDD",
    "Brief": "Perform bitwise logical AND operation on packed doubleword integers",
    "Description": "\nPerforms a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.\n\nThe instruction has several variants:\n- Legacy MMX/SSE versions work with 64-bit and 128-bit operands\n- VEX-encoded versions support 128-bit and 256-bit vector registers\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit vector registers with additional features like write masking and broadcasting\n\nKey characteristics:\n- Can operate on integer data types (doublewords and quadwords)\n- Supports different register sizes and instruction set extensions (MMX, SSE, AVX, AVX2, AVX-512)\n- In EVEX versions, supports conditional updates using write masks\n- Can broadcast values from memory in EVEX versions\n\nThe result is always a bitwise AND of the source operands, with zero-padding or merging of upper bits depending on the specific instruction variant.\n",
    "Alias": []
  },
  {
    "Name": "VPANDQ",
    "Brief": "Perform bitwise logical AND operation on packed quadword integers",
    "Description": "\nPerforms a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.\n\nThe instruction has several variants:\n- Legacy MMX/SSE versions work with 64-bit and 128-bit operands\n- VEX-encoded versions support 128-bit and 256-bit vector registers\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit vector registers with additional features like write masking and broadcasting\n\nKey characteristics:\n- Can operate on integer data types (doublewords and quadwords)\n- Supports different register sizes and instruction set extensions (MMX, SSE, AVX, AVX2, AVX-512)\n- In EVEX versions, supports conditional updates using write masks\n- Can broadcast values from memory in EVEX versions\n\nThe result is always a bitwise AND of the source operands, with zero-padding or merging of upper bits depending on the specific instruction variant.\n",
    "Alias": []
  },
  {
    "Name": "PANDN",
    "Brief": "Bitwise logical NOT operation followed by a bitwise AND",
    "Description": "\nPerforms a bitwise logical NOT operation on the first source operand, then performs bitwise AND with the second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.\n\nThe instruction supports multiple variants across different instruction set extensions:\n- Legacy MMX/SSE versions operate on 64-bit or 128-bit registers\n- VEX-encoded versions support 128-bit and 256-bit registers with zero-extension of upper bits\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit registers with writemask and broadcast capabilities\n\nIn the EVEX versions, the instruction can operate on packed doubleword (32-bit) or quadword (64-bit) integers, with optional masking and broadcasting from memory.\n\nThe core operation can be summarized as: DEST := NOT(SRC1) AND SRC2, where the bitwise NOT is applied to the first source operand before the AND operation.\n",
    "Alias": []
  },
  {
    "Name": "VPANDN",
    "Brief": "Vector bitwise logical NOT operation followed by a bitwise AND",
    "Description": "\nPerforms a bitwise logical NOT operation on the first source operand, then performs bitwise AND with the second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.\n\nThe instruction supports multiple variants across different instruction set extensions:\n- Legacy MMX/SSE versions operate on 64-bit or 128-bit registers\n- VEX-encoded versions support 128-bit and 256-bit registers with zero-extension of upper bits\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit registers with writemask and broadcast capabilities\n\nIn the EVEX versions, the instruction can operate on packed doubleword (32-bit) or quadword (64-bit) integers, with optional masking and broadcasting from memory.\n\nThe core operation can be summarized as: DEST := NOT(SRC1) AND SRC2, where the bitwise NOT is applied to the first source operand before the AND operation.\n",
    "Alias": []
  },
  {
    "Name": "VPANDND",
    "Brief": "Vector packed doubleword bitwise AND NOT",
    "Description": "\nPerforms a bitwise logical NOT operation on the first source operand, then performs bitwise AND with the second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.\n\nThe instruction supports multiple variants across different instruction set extensions:\n- Legacy MMX/SSE versions operate on 64-bit or 128-bit registers\n- VEX-encoded versions support 128-bit and 256-bit registers with zero-extension of upper bits\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit registers with writemask and broadcast capabilities\n\nIn the EVEX versions, the instruction can operate on packed doubleword (32-bit) or quadword (64-bit) integers, with optional masking and broadcasting from memory.\n\nThe core operation can be summarized as: DEST := NOT(SRC1) AND SRC2, where the bitwise NOT is applied to the first source operand before the AND operation.\n",
    "Alias": []
  },
  {
    "Name": "VPANDNQ",
    "Brief": "Vector packed quadword bitwise AND NOT",
    "Description": "\nPerforms a bitwise logical NOT operation on the first source operand, then performs bitwise AND with the second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.\n\nThe instruction supports multiple variants across different instruction set extensions:\n- Legacy MMX/SSE versions operate on 64-bit or 128-bit registers\n- VEX-encoded versions support 128-bit and 256-bit registers with zero-extension of upper bits\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit registers with writemask and broadcast capabilities\n\nIn the EVEX versions, the instruction can operate on packed doubleword (32-bit) or quadword (64-bit) integers, with optional masking and broadcasting from memory.\n\nThe core operation can be summarized as: DEST := NOT(SRC1) AND SRC2, where the bitwise NOT is applied to the first source operand before the AND operation.\n",
    "Alias": []
  },
  {
    "Name": "PAUSE",
    "Brief": "Spin Loop Hint",
    "Description": "\nImproves the performance of spin-wait loops. When executing a \"spin-wait loop,\" processors will suffer a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop.\n\nKey functions of the PAUSE instruction:\n1. Avoid memory order violation penalties in spin-wait loops\n2. Reduce power consumption during spin loops by introducing a small delay\n3. Provides a performance hint to the processor\n\nThe instruction was introduced in Pentium 4 processors and is backward compatible with all IA-32 processors. In earlier processors, it operates like a NOP instruction. On Pentium 4 and Intel Xeon processors, it implements a finite delay.\n\nThe instruction does not change the architectural state of the processor and essentially performs a delaying no-op operation.\n",
    "Alias": []
  },
  {
    "Name": "PAVGB",
    "Brief": "Average packed unsigned byte integers with rounding",
    "Description": "\nPerforms a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.\n\nThe (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.\n\nIn different instruction variants (MMX, SSE, VEX, and EVEX), the instructions work on different register sizes and have slightly different behaviors:\n\n- Legacy SSE instructions work with MMX technology registers or 64-bit memory locations\n- 128-bit SSE versions work with XMM registers\n- VEX.128/256 and EVEX.128/256/512 versions work with larger register sizes (XMM, YMM, ZMM)\n- EVEX versions support write masking, allowing conditional processing of packed integers\n\nThe core operation remains consistent across variants: adding corresponding packed integer elements, adding 1 to the sum, and right-shifting by 1 bit to compute the average with rounding.\n",
    "Alias": []
  },
  {
    "Name": "PAVGW",
    "Brief": "Average packed unsigned word integers with rounding",
    "Description": "\nPerforms a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.\n\nThe (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.\n\nIn different instruction variants (MMX, SSE, VEX, and EVEX), the instructions work on different register sizes and have slightly different behaviors:\n\n- Legacy SSE instructions work with MMX technology registers or 64-bit memory locations\n- 128-bit SSE versions work with XMM registers\n- VEX.128/256 and EVEX.128/256/512 versions work with larger register sizes (XMM, YMM, ZMM)\n- EVEX versions support write masking, allowing conditional processing of packed integers\n\nThe core operation remains consistent across variants: adding corresponding packed integer elements, adding 1 to the sum, and right-shifting by 1 bit to compute the average with rounding.\n",
    "Alias": []
  },
  {
    "Name": "VPAVGB",
    "Brief": "Vector average packed unsigned byte integers with rounding",
    "Description": "\nPerforms a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.\n\nThe (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.\n\nIn different instruction variants (MMX, SSE, VEX, and EVEX), the instructions work on different register sizes and have slightly different behaviors:\n\n- Legacy SSE instructions work with MMX technology registers or 64-bit memory locations\n- 128-bit SSE versions work with XMM registers\n- VEX.128/256 and EVEX.128/256/512 versions work with larger register sizes (XMM, YMM, ZMM)\n- EVEX versions support write masking, allowing conditional processing of packed integers\n\nThe core operation remains consistent across variants: adding corresponding packed integer elements, adding 1 to the sum, and right-shifting by 1 bit to compute the average with rounding.\n",
    "Alias": []
  },
  {
    "Name": "VPAVGW",
    "Brief": "Vector average packed unsigned word integers with rounding",
    "Description": "\nPerforms a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.\n\nThe (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.\n\nIn different instruction variants (MMX, SSE, VEX, and EVEX), the instructions work on different register sizes and have slightly different behaviors:\n\n- Legacy SSE instructions work with MMX technology registers or 64-bit memory locations\n- 128-bit SSE versions work with XMM registers\n- VEX.128/256 and EVEX.128/256/512 versions work with larger register sizes (XMM, YMM, ZMM)\n- EVEX versions support write masking, allowing conditional processing of packed integers\n\nThe core operation remains consistent across variants: adding corresponding packed integer elements, adding 1 to the sum, and right-shifting by 1 bit to compute the average with rounding.\n",
    "Alias": []
  },
  {
    "Name": "PBLENDVB",
    "Brief": "Variable Blend Packed Bytes",
    "Description": "\nConditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument (XMM0 for legacy SSE version) or a specified mask register.\n\nIf a mask bit is \"1\", then the corresponding byte element in the source operand is copied to the destination, else the byte element in the destination operand is left unchanged.\n\nKey variations:\n- 128-bit Legacy SSE version: Uses XMM0 implicitly as the mask, and the first source operand is both the destination and source.\n- VEX.128 version: Allows a specified mask register, supports non-destructive destination operation, and zeroes the upper bits of the destination YMM register.\n- VEX.256 version: Operates on 256-bit YMM registers with a specified mask register.\n\nThe mask bits are the most significant bit in each byte element of the mask register. This allows for fine-grained byte-level selection between two source operands.\n",
    "Alias": []
  },
  {
    "Name": "VPBLENDVB",
    "Brief": "Variable Blend Packed Bytes with VEX prefix",
    "Description": "\nConditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument (XMM0 for legacy SSE version) or a specified mask register.\n\nIf a mask bit is \"1\", then the corresponding byte element in the source operand is copied to the destination, else the byte element in the destination operand is left unchanged.\n\nKey variations:\n- 128-bit Legacy SSE version: Uses XMM0 implicitly as the mask, and the first source operand is both the destination and source.\n- VEX.128 version: Allows a specified mask register, supports non-destructive destination operation, and zeroes the upper bits of the destination YMM register.\n- VEX.256 version: Operates on 256-bit YMM registers with a specified mask register.\n\nThe mask bits are the most significant bit in each byte element of the mask register. This allows for fine-grained byte-level selection between two source operands.\n",
    "Alias": []
  },
  {
    "Name": "PBLENDW",
    "Brief": "Blend packed words based on an immediate mask",
    "Description": "\nWords from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is \"1\", then the word is copied, else the word element in the destination operand is unchanged.\n\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n",
    "Alias": []
  },
  {
    "Name": "VPBLENDW",
    "Brief": "Vector blend packed words based on an immediate mask",
    "Description": "\nWords from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is \"1\", then the word is copied, else the word element in the destination operand is unchanged.\n\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n",
    "Alias": []
  },
  {
    "Name": "PCLMULQDQ",
    "Brief": "Carry-less multiplication of two quadwords",
    "Description": "\nPerforms a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use.\n\nThe instruction supports different quadword selection based on the immediate byte:\n- 00b: Multiply lower 64-bit quadwords of both sources\n- 01b: Multiply lower 64-bit quadword of first source with upper 64-bit quadword of second source\n- 10b: Multiply upper 64-bit quadword of first source with lower 64-bit quadword of second source\n- 11b: Multiply upper 64-bit quadwords of both sources\n\nThe first source operand and the destination operand are the same and must be a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\n\nThe instruction supports pseudo-ops to simplify programming:\n- PCLMULLQLQDQ: Multiply lower quadwords\n- PCLMULHQLQDQ: Multiply lower quadword of first source with upper quadword of second source\n- PCLMULLQHQDQ: Multiply upper quadword of first source with lower quadword of second source\n- PCLMULHQHQDQ: Multiply upper quadwords of both sources\n\nCompilers and assemblers can use these pseudo-ops to generate the appropriate immediate byte encoding.\n",
    "Alias": []
  },
  {
    "Name": "VPCLMULQDQ",
    "Brief": "Vector carry-less multiplication of two quadwords",
    "Description": "\nPerforms a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use.\n\nThe instruction supports different quadword selection based on the immediate byte:\n- 00b: Multiply lower 64-bit quadwords of both sources\n- 01b: Multiply lower 64-bit quadword of first source with upper 64-bit quadword of second source\n- 10b: Multiply upper 64-bit quadword of first source with lower 64-bit quadword of second source\n- 11b: Multiply upper 64-bit quadwords of both sources\n\nThe first source operand and the destination operand are the same and must be a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\n\nThe instruction supports pseudo-ops to simplify programming:\n- PCLMULLQLQDQ: Multiply lower quadwords\n- PCLMULHQLQDQ: Multiply lower quadword of first source with upper quadword of second source\n- PCLMULLQHQDQ: Multiply upper quadword of first source with lower quadword of second source\n- PCLMULHQHQDQ: Multiply upper quadwords of both sources\n\nCompilers and assemblers can use these pseudo-ops to generate the appropriate immediate byte encoding.\n",
    "Alias": []
  },
  {
    "Name": "PCMPEQB",
    "Brief": "Compare packed bytes for equality",
    "Description": "\nPerforms a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the PCMPEQW instruction compares the corresponding words in the destination and source operands; and the PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support MMX technology registers and 64-bit memory locations. 128-bit Legacy SSE version supports XMM registers and 128-bit memory locations. VEX and EVEX encoded versions provide extended support for YMM and ZMM registers with various comparison modes and write mask capabilities.\n\nThe instruction supports different register sizes and formats:\n- 64-bit operands: Compare between MMX registers\n- 128-bit operands: Compare between XMM registers\n- 256-bit operands (VEX): Compare between YMM registers\n- 512-bit operands (EVEX): Compare between ZMM registers with mask support\n",
    "Alias": []
  },
  {
    "Name": "PCMPEQW",
    "Brief": "Compare packed words for equality",
    "Description": "\nPerforms a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the PCMPEQW instruction compares the corresponding words in the destination and source operands; and the PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support MMX technology registers and 64-bit memory locations. 128-bit Legacy SSE version supports XMM registers and 128-bit memory locations. VEX and EVEX encoded versions provide extended support for YMM and ZMM registers with various comparison modes and write mask capabilities.\n\nThe instruction supports different register sizes and formats:\n- 64-bit operands: Compare between MMX registers\n- 128-bit operands: Compare between XMM registers\n- 256-bit operands (VEX): Compare between YMM registers\n- 512-bit operands (EVEX): Compare between ZMM registers with mask support\n",
    "Alias": []
  },
  {
    "Name": "PCMPEQD",
    "Brief": "Compare packed doublewords for equality",
    "Description": "\nPerforms a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the PCMPEQW instruction compares the corresponding words in the destination and source operands; and the PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support MMX technology registers and 64-bit memory locations. 128-bit Legacy SSE version supports XMM registers and 128-bit memory locations. VEX and EVEX encoded versions provide extended support for YMM and ZMM registers with various comparison modes and write mask capabilities.\n\nThe instruction supports different register sizes and formats:\n- 64-bit operands: Compare between MMX registers\n- 128-bit operands: Compare between XMM registers\n- 256-bit operands (VEX): Compare between YMM registers\n- 512-bit operands (EVEX): Compare between ZMM registers with mask support\n",
    "Alias": []
  },
  {
    "Name": "PCMPEQQ",
    "Brief": "Compare Packed Qword Data for Equality",
    "Description": "\nPerforms an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.\n\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nEVEX encoded VPCMPEQQ: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.\n",
    "Alias": []
  },
  {
    "Name": "VPCMPEQQ",
    "Brief": "Vector Compare Packed Qword Data for Equality",
    "Description": "\nPerforms an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.\n\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nEVEX encoded VPCMPEQQ: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.\n",
    "Alias": []
  },
  {
    "Name": "PCMPESTRI",
    "Brief": "Packed Compare Explicit Length Strings, Return Index",
    "Description": "\nThe instruction compares and processes data from two string fragments based on the encoded value in the imm8 control byte, and generates an index stored to the count register (ECX).\n\nEach string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.\n\nThe length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).\n\nThe comparison and aggregation operations are performed according to the encoded value of imm8 bit fields. The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).\n\nThe Arithmetic Flags are written in a non-standard manner:\n- CFlag – Reset if IntRes2 is equal to zero, set otherwise\n- ZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise\n- SFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise\n- OFlag – IntRes2[0]\n- AFlag – Reset\n- PFlag – Reset\n",
    "Alias": []
  },
  {
    "Name": "PCMPESTRM",
    "Brief": "Packed Compare Explicit Length Strings, Return Mask",
    "Description": "\nThe instruction compares data from two string fragments based on the encoded value in the imm8 control byte, and generates a mask stored to XMM0.\n\nEach string fragment is represented by two values:\n1. An xmm (or m128) containing the data elements of the string (byte or word data)\n2. An input length register (EAX/RAX for xmm1, EDX/RDX for xmm2/m128)\n\nThe length represents the number of bytes/words which are valid for the respective xmm/m128 data. The length is interpreted as the absolute value, which saturates to 16 (for bytes) and 8 (for words).\n\nThe comparison and aggregation operations are performed according to the encoded value of imm8 bit fields. The result (IntRes2) is either stored to the least significant bits of XMM0 or expanded into a byte/word-mask.\n\nArithmetic Flags are written in a non-standard manner:\n- CFlag: Reset if IntRes2 is zero, set otherwise\n- ZFlag: Set if absolute value of EDX is < 16 (8), reset otherwise\n- SFlag: Set if absolute value of EAX is < 16 (8), reset otherwise\n- OFlag: IntRes2[0]\n- AFlag and PFlag: Reset\n\nIn VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv must be 1111b, and VEX.L must be 0.\n",
    "Alias": []
  },
  {
    "Name": "PCMPGTB",
    "Brief": "Compare packed signed byte integers for greater than",
    "Description": "\nPerforms an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding data element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support 64-bit MMX technology registers or memory locations. 128-bit Legacy SSE version supports XMM registers and memory locations. VEX and EVEX encoded versions support XMM, YMM, and ZMM registers with various comparison modes and write mask options.\n\nThe instruction variations include:\n- Direct register comparisons\n- Comparisons with memory locations\n- Full vector comparisons (128-bit, 256-bit, 512-bit)\n- Mask register output options\n- Broadcast and writemask capabilities in EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "PCMPGTW",
    "Brief": "Compare packed signed word integers for greater than",
    "Description": "\nPerforms an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding data element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support 64-bit MMX technology registers or memory locations. 128-bit Legacy SSE version supports XMM registers and memory locations. VEX and EVEX encoded versions support XMM, YMM, and ZMM registers with various comparison modes and write mask options.\n\nThe instruction variations include:\n- Direct register comparisons\n- Comparisons with memory locations\n- Full vector comparisons (128-bit, 256-bit, 512-bit)\n- Mask register output options\n- Broadcast and writemask capabilities in EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "PCMPGTD",
    "Brief": "Compare packed signed doubleword integers for greater than",
    "Description": "\nPerforms an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding data element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support 64-bit MMX technology registers or memory locations. 128-bit Legacy SSE version supports XMM registers and memory locations. VEX and EVEX encoded versions support XMM, YMM, and ZMM registers with various comparison modes and write mask options.\n\nThe instruction variations include:\n- Direct register comparisons\n- Comparisons with memory locations\n- Full vector comparisons (128-bit, 256-bit, 512-bit)\n- Mask register output options\n- Broadcast and writemask capabilities in EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "VPCMPGTB",
    "Brief": "Vector compare packed signed byte integers for greater than",
    "Description": "\nPerforms an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding data element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support 64-bit MMX technology registers or memory locations. 128-bit Legacy SSE version supports XMM registers and memory locations. VEX and EVEX encoded versions support XMM, YMM, and ZMM registers with various comparison modes and write mask options.\n\nThe instruction variations include:\n- Direct register comparisons\n- Comparisons with memory locations\n- Full vector comparisons (128-bit, 256-bit, 512-bit)\n- Mask register output options\n- Broadcast and writemask capabilities in EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "VPCMPGTW",
    "Brief": "Vector compare packed signed word integers for greater than",
    "Description": "\nPerforms an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding data element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support 64-bit MMX technology registers or memory locations. 128-bit Legacy SSE version supports XMM registers and memory locations. VEX and EVEX encoded versions support XMM, YMM, and ZMM registers with various comparison modes and write mask options.\n\nThe instruction variations include:\n- Direct register comparisons\n- Comparisons with memory locations\n- Full vector comparisons (128-bit, 256-bit, 512-bit)\n- Mask register output options\n- Broadcast and writemask capabilities in EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "VPCMPGTD",
    "Brief": "Vector compare packed signed doubleword integers for greater than",
    "Description": "\nPerforms an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding data element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\n\nThe PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions support 64-bit MMX technology registers or memory locations. 128-bit Legacy SSE version supports XMM registers and memory locations. VEX and EVEX encoded versions support XMM, YMM, and ZMM registers with various comparison modes and write mask options.\n\nThe instruction variations include:\n- Direct register comparisons\n- Comparisons with memory locations\n- Full vector comparisons (128-bit, 256-bit, 512-bit)\n- Mask register output options\n- Broadcast and writemask capabilities in EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "PCMPGTQ",
    "Brief": "Compare Packed Signed Quadwords for Greater Than",
    "Description": "\nPerforms an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the source operand (second operand). If the data element in the first (destination) operand is greater than the corresponding element in the second (source) operand, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.\n\nThe instruction has multiple variants:\n- 128-bit Legacy SSE version: Compares XMM registers or 128-bit memory locations\n- VEX.128 encoded version: Compares XMM registers with optional 128-bit memory location, zeroes upper bits of YMM register\n- VEX.256 encoded version: Compares YMM registers or 256-bit memory locations\n- EVEX encoded version: Supports full vector lengths (128/256/512 bits) with optional broadcasting and write masking\n\nFor each 64-bit quadword element:\n- If the first operand's element is greater than the second operand's element, set the result to all 1s\n- Otherwise, set the result to 0s\n\nThe instruction supports various vector lengths and can work with register-to-register comparisons or comparisons involving memory operands.\n",
    "Alias": []
  },
  {
    "Name": "VPCMPGTQ",
    "Brief": "Vector Compare Packed Signed Quadwords for Greater Than",
    "Description": "\nPerforms an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the source operand (second operand). If the data element in the first (destination) operand is greater than the corresponding element in the second (source) operand, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.\n\nThe instruction has multiple variants:\n- 128-bit Legacy SSE version: Compares XMM registers or 128-bit memory locations\n- VEX.128 encoded version: Compares XMM registers with optional 128-bit memory location, zeroes upper bits of YMM register\n- VEX.256 encoded version: Compares YMM registers or 256-bit memory locations\n- EVEX encoded version: Supports full vector lengths (128/256/512 bits) with optional broadcasting and write masking\n\nFor each 64-bit quadword element:\n- If the first operand's element is greater than the second operand's element, set the result to all 1s\n- Otherwise, set the result to 0s\n\nThe instruction supports various vector lengths and can work with register-to-register comparisons or comparisons involving memory operands.\n",
    "Alias": []
  },
  {
    "Name": "PCMPISTRI",
    "Brief": "Perform a packed comparison of string data with implicit lengths, generating an index",
    "Description": "\nThe instruction compares data from two strings based on the encoded value in the imm8 control byte, and generates an index stored to ECX.\n\nEach string is represented by a single value, an xmm (or m128) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)\n\nThe comparison and aggregation operations are performed according to the encoded value of imm8 bit fields. The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).\n\nThe Arithmetic Flags are written in a non-standard manner:\n- CFlag – Reset if IntRes2 is equal to zero, set otherwise\n- ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise\n- SFlag – Set if any byte/word of xmm1 is null, reset otherwise\n- OFlag – IntRes2[0]\n- AFlag – Reset\n- PFlag – Reset\n\nIn the VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.\n",
    "Alias": []
  },
  {
    "Name": "PCMPISTRM",
    "Brief": "Packed Compare Implicit Length Strings, Return Mask",
    "Description": "\nThe instruction compares data from two strings based on the encoded value in the imm8 byte, generating a mask stored to XMM0.\n\nEach string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)\n\nThe comparison and aggregation operation are performed according to the encoded value of imm8 bit fields. As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.\n\nThe Arithmetic Flags are written in a non-standard manner:\n- CFlag – Reset if IntRes2 is equal to zero, set otherwise\n- ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise\n- SFlag – Set if any byte/word of xmm1 is null, reset otherwise\n- OFlag – IntRes2[0]\n- AFlag – Reset\n- PFlag – Reset\n\nIn VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.\n",
    "Alias": []
  },
  {
    "Name": "PCONFIG",
    "Brief": "Platform Configuration instruction for configuring platform features",
    "Description": "\nThe PCONFIG instruction allows software to configure certain platform features. It supports these features with multiple leaf functions, selecting a leaf function using the value in EAX.\n\nDepending on the leaf function, the registers RBX, RCX, and RDX may be used to provide input information or for the instruction to report output information. Addresses and operands are 32 bits outside 64-bit mode and are 64 bits in 64-bit mode.\n\nExecutions of PCONFIG may fail for platform-specific reasons. An execution reports failure by setting the ZF flag and loading EAX with a non-zero failure reason; a successful execution clears ZF and EAX.\n\nEach PCONFIG leaf function applies to a specific hardware block called a PCONFIG target. The leaf function is supported only if the processor supports that target. Each target is associated with a numerical target identifier, and CPUID leaf 1BH (PCONFIG information) enumerates the identifiers of the supported targets.\n\nAs of this writing, the only defined PCONFIG leaf function is used for key programming for total memory encryption-multi-key (TME-MK). This leaf function is called MKTME_KEY_PROGRAM and it pertains to the TME-MK target, which has target identifier 1. \n\nSoftware uses the MKTME_KEY_PROGRAM leaf function to manage the encryption key associated with a particular key identifier (KeyID). The leaf function uses a data structure called the TME-MK key programming structure (MKTME_KEY_PROGRAM_STRUCT) to specify key programming details such as the KeyID, key programming command, encryption algorithm, and key data.\n",
    "Alias": []
  },
  {
    "Name": "PDEP",
    "Brief": "Parallel deposit of bits from source using a mask",
    "Description": "\nPDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits from the first source operand and deposit them in the destination operand at the corresponding bit locations that are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nThe instruction works by iterating through the mask and source bits:\n1. If a bit in the mask is 1, take the next bit from the source and place it in the corresponding destination bit position\n2. If a bit in the mask is 0, set the destination bit to 0\n3. Repeat until all bits in the operand size are processed\n\nThe figure provided illustrates an example of how bits are deposited based on a mask.\n",
    "Alias": []
  },
  {
    "Name": "PEXT",
    "Brief": "Parallel bits extract from source using a mask",
    "Description": "\nPEXT uses a mask in the second source operand (the third operand) to transfer either contiguous or non-contiguous bits in the first source operand (the second operand) to contiguous low order bit positions in the destination (the first operand).\n\nFor each bit set in the MASK, PEXT extracts the corresponding bits from the first source operand and writes them into contiguous lower bits of destination operand. The remaining upper bits of destination are zeroed.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nThe instruction supports two variants:\n1. 32-bit mode: PEXT r32a, r32b, r/m32\n2. 64-bit mode: PEXT r64a, r64b, r/m64\n\nThe operation can be summarized as:\n- Iterate through each bit in the source and mask\n- If the mask bit is 1, copy the corresponding source bit to the destination\n- Bits are placed contiguously in the destination from the least significant bit\n- Unmatched bits in the destination are zeroed\n",
    "Alias": []
  },
  {
    "Name": "PEXTRB",
    "Brief": "Extract a byte integer value from the source XMM register",
    "Description": "\nExtract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.\n\nIn legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.\n\nIn VEX.128 and EVEX.128 encoded versions, VEX.vvvv/EVEX.vvvv must be 1111b, and VEX.L/EVEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, with bits above the least significant byte/word/dword data filled with zeros.\n",
    "Alias": []
  },
  {
    "Name": "PEXTRD",
    "Brief": "Extract a dword integer value from the source XMM register",
    "Description": "\nExtract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.\n\nIn legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.\n\nIn VEX.128 and EVEX.128 encoded versions, VEX.vvvv/EVEX.vvvv must be 1111b, and VEX.L/EVEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, with bits above the least significant byte/word/dword data filled with zeros.\n",
    "Alias": []
  },
  {
    "Name": "PEXTRQ",
    "Brief": "Extract a qword integer value from the source XMM register",
    "Description": "\nExtract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.\n\nIn legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.\n\nIn VEX.128 and EVEX.128 encoded versions, VEX.vvvv/EVEX.vvvv must be 1111b, and VEX.L/EVEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, with bits above the least significant byte/word/dword data filled with zeros.\n",
    "Alias": []
  },
  {
    "Name": "PEXTRW",
    "Brief": "Extract a word from a MMX or XMM register and move it to a destination register",
    "Description": "\nCopies the word in the source operand (second operand) specified by the count operand (third operand) to the destination operand (first operand). The source operand can be an MMX technology register or an XMM register. The destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count operand is an 8-bit immediate.\n\nWhen specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location. The content of the destination register above bit 16 is cleared (set to all 0s).\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). If the destination operand is a general-purpose register, the default operand size is 64-bits in 64-bit mode.\n\nNote: In VEX.128 and EVEX.128 encoded versions, VEX.vvvv/EVEX.vvvv is reserved and must be 1111b, VEX.L/EVEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRW is 64 bits, with the bits above the least significant byte/word/dword data filled with zeros.\n",
    "Alias": []
  },
  {
    "Name": "PHADDW",
    "Brief": "Packed Horizontal Add for 16-bit integers",
    "Description": "\nThe PHADDW and PHADDD instructions add two adjacent integers horizontally from the source and destination operands and pack the signed results to the destination operand.\n\n(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand.\n\n(V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand.\n\nThese instructions can operate on either unsigned or signed (two's complement notation) integers; however, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.\n\nLegacy SSE instructions support MMX and XMM registers, while VEX-encoded versions support XMM and YMM registers with additional variations for 128-bit and 256-bit operations.\n\nThe instructions perform horizontal addition across packed integer values, effectively summing adjacent pairs of elements and storing the results in the destination register.\n",
    "Alias": []
  },
  {
    "Name": "PHADDD",
    "Brief": "Packed Horizontal Add for 32-bit integers",
    "Description": "\nThe PHADDW and PHADDD instructions add two adjacent integers horizontally from the source and destination operands and pack the signed results to the destination operand.\n\n(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand.\n\n(V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand.\n\nThese instructions can operate on either unsigned or signed (two's complement notation) integers; however, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.\n\nLegacy SSE instructions support MMX and XMM registers, while VEX-encoded versions support XMM and YMM registers with additional variations for 128-bit and 256-bit operations.\n\nThe instructions perform horizontal addition across packed integer values, effectively summing adjacent pairs of elements and storing the results in the destination register.\n",
    "Alias": []
  },
  {
    "Name": "VPHADDW",
    "Brief": "Vector Packed Horizontal Add for 16-bit integers",
    "Description": "\nThe PHADDW and PHADDD instructions add two adjacent integers horizontally from the source and destination operands and pack the signed results to the destination operand.\n\n(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand.\n\n(V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand.\n\nThese instructions can operate on either unsigned or signed (two's complement notation) integers; however, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.\n\nLegacy SSE instructions support MMX and XMM registers, while VEX-encoded versions support XMM and YMM registers with additional variations for 128-bit and 256-bit operations.\n\nThe instructions perform horizontal addition across packed integer values, effectively summing adjacent pairs of elements and storing the results in the destination register.\n",
    "Alias": []
  },
  {
    "Name": "VPHADDD",
    "Brief": "Vector Packed Horizontal Add for 32-bit integers",
    "Description": "\nThe PHADDW and PHADDD instructions add two adjacent integers horizontally from the source and destination operands and pack the signed results to the destination operand.\n\n(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand.\n\n(V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand.\n\nThese instructions can operate on either unsigned or signed (two's complement notation) integers; however, they do not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.\n\nLegacy SSE instructions support MMX and XMM registers, while VEX-encoded versions support XMM and YMM registers with additional variations for 128-bit and 256-bit operations.\n\nThe instructions perform horizontal addition across packed integer values, effectively summing adjacent pairs of elements and storing the results in the destination register.\n",
    "Alias": []
  },
  {
    "Name": "PHADDSW",
    "Brief": "Packed Horizontal Add and Saturate",
    "Description": "\n(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand).\n\nWhen the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\n\nLegacy SSE version:\n- Both operands can be MMX registers\n- The second source operand can be an MMX register or a 64-bit memory location\n\n128-bit Legacy SSE version:\n- First source and destination operands are XMM registers\n- Second source operand is an XMM register or a 128-bit memory location\n- Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged\n\nVEX.128 encoded version:\n- First source and destination operands are XMM registers\n- Second source operand is an XMM register or a 128-bit memory location\n- Bits (MAXVL-1:128) of the destination YMM register are zeroed\n\nVEX.256 encoded version:\n- First source and destination operands are YMM registers\n- Second source operand can be an YMM register or a 256-bit memory location\n\nIn 64-bit mode, use the REX prefix to access additional registers.\n",
    "Alias": []
  },
  {
    "Name": "PHMINPOSUW",
    "Brief": "Find the minimum unsigned word in packed words and return its value and index",
    "Description": "\nDetermine the minimum unsigned word value in the source operand (second operand) and place the unsigned word in the low word (bits 0-15) of the destination operand (first operand). The word index of the minimum value is stored in bits 16-18 of the destination operand. The remaining upper bits of the destination are set to zero.\n\nIn the 128-bit Legacy SSE version, bits (MAXVL-1:128) of the corresponding XMM destination register remain unchanged.\n\nIn the VEX.128 encoded version, bits (MAXVL-1:128) of the destination XMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.\n\nThe instruction searches through all 8 unsigned words in the source XMM register, comparing each word to find the minimum value. When the minimum value is found, it is placed in the low word of the destination, and its index (0-7) is placed in bits 16-18 of the destination.\n",
    "Alias": []
  },
  {
    "Name": "VPHMINPOSUW",
    "Brief": "VEX-encoded version of PHMINPOSUW to find the minimum unsigned word in packed words",
    "Description": "\nDetermine the minimum unsigned word value in the source operand (second operand) and place the unsigned word in the low word (bits 0-15) of the destination operand (first operand). The word index of the minimum value is stored in bits 16-18 of the destination operand. The remaining upper bits of the destination are set to zero.\n\nIn the 128-bit Legacy SSE version, bits (MAXVL-1:128) of the corresponding XMM destination register remain unchanged.\n\nIn the VEX.128 encoded version, bits (MAXVL-1:128) of the destination XMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.\n\nThe instruction searches through all 8 unsigned words in the source XMM register, comparing each word to find the minimum value. When the minimum value is found, it is placed in the low word of the destination, and its index (0-7) is placed in bits 16-18 of the destination.\n",
    "Alias": []
  },
  {
    "Name": "PHSUBW",
    "Brief": "Perform horizontal subtraction on packed 16-bit signed integers",
    "Description": "\n(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). \n\n(V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant doubleword of each pair, and packs the signed 32-bit result to the destination operand.\n\nWhen the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\n\nLegacy SSE version supports MMX registers with 64-bit operands. 128-bit Legacy SSE version uses XMM registers, with bits (MAXVL-1:128) of the destination YMM register remaining unchanged.\n\nVEX.128 encoded version uses XMM registers, with bits (MAXVL-1:128) of the destination YMM register zeroed.\n\nVEX.256 encoded version uses YMM registers with 256-bit operands.\n\nIn 64-bit mode, the REX prefix can be used to access additional registers.\n",
    "Alias": []
  },
  {
    "Name": "PHSUBD",
    "Brief": "Perform horizontal subtraction on packed 32-bit signed integers",
    "Description": "\n(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). \n\n(V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant doubleword of each pair, and packs the signed 32-bit result to the destination operand.\n\nWhen the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\n\nLegacy SSE version supports MMX registers with 64-bit operands. 128-bit Legacy SSE version uses XMM registers, with bits (MAXVL-1:128) of the destination YMM register remaining unchanged.\n\nVEX.128 encoded version uses XMM registers, with bits (MAXVL-1:128) of the destination YMM register zeroed.\n\nVEX.256 encoded version uses YMM registers with 256-bit operands.\n\nIn 64-bit mode, the REX prefix can be used to access additional registers.\n",
    "Alias": []
  },
  {
    "Name": "PHSUBSW",
    "Brief": "Packed Horizontal Subtract and Saturate",
    "Description": "\n(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed, saturated 16-bit results are packed to the destination operand (first operand).\n\nWhen the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\n\nLegacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\n\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "PINSRB",
    "Brief": "Insert a byte integer value into an XMM register",
    "Description": "\nCopies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) \n\nThe source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. \n\nWhen specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.\n\nLegacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the destination register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "PINSRD",
    "Brief": "Insert a dword integer value into an XMM register",
    "Description": "\nCopies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) \n\nThe source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. \n\nWhen specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.\n\nLegacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the destination register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "PINSRQ",
    "Brief": "Insert a qword integer value into an XMM register",
    "Description": "\nCopies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) \n\nThe source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. \n\nWhen specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.\n\nLegacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the destination register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "PINSRW",
    "Brief": "Insert a word from source operand into destination operand at a specified location",
    "Description": "\nThree operand MMX and SSE instructions:\nCopies a word from the source operand and inserts it in the destination operand at the location specified with the count operand. (The other words in the destination register are left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The destination operand can be an MMX technology register or an XMM register. The count operand is an 8-bit immediate.\n\nFour operand AVX and AVX-512 instructions:\nCombines a word from the first source operand with the second source operand, and inserts it in the destination operand at the location specified with the count operand. The second source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The first source and destination operands are XMM registers. The count operand is an 8-bit immediate.\n\nWhen specifying a word location, the 2 least-significant bits (for MMX) or 3 least-significant bits (for XMM) of the count operand specify the location. Bits (MAXVL-1:128) of the destination register remain unchanged or are zeroed depending on the instruction variant.\n",
    "Alias": []
  },
  {
    "Name": "PMADDUBSW",
    "Brief": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words",
    "Description": "\n(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corresponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each adjacent pair of signed words is added and the saturated result is packed to the destination operand.\n\nFor example, the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same operation is performed on the other pairs of adjacent bytes.\n\nThe instruction supports multiple variants:\n- MMX register operations with 64-bit operands\n- SSE/AVX/AVX2 versions with 128-bit operands\n- AVX-512 versions with 256-bit and 512-bit operands\n\nThe instruction can operate with different register sizes and supports writemask operations in the EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "VPMADDUBSW",
    "Brief": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words",
    "Description": "\n(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corresponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each adjacent pair of signed words is added and the saturated result is packed to the destination operand.\n\nFor example, the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same operation is performed on the other pairs of adjacent bytes.\n\nThe instruction supports multiple variants:\n- MMX register operations with 64-bit operands\n- SSE/AVX/AVX2 versions with 128-bit operands\n- AVX-512 versions with 256-bit and 512-bit operands\n\nThe instruction can operate with different register sizes and supports writemask operations in the EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "PMADDWD",
    "Brief": "Multiply and add packed word integers",
    "Description": "\nMultiplies the individual signed words of the destination operand (first operand) by the corresponding signed words of the source operand (second operand), producing temporary signed, doubleword results. The adjacent double-word results are then summed and stored in the destination operand.\n\nFor example, the corresponding low-order words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the double-word results are added together and stored in the low doubleword of the destination register (31-0). The same operation is performed on the other pairs of adjacent words.\n\nThe (V)PMADDWD instruction wraps around only in one situation: when the 2 pairs of words being operated on in a group are all 8000H. In this case, the result wraps around to 80000000H.\n\nDifferent versions of the instruction support various register sizes:\n- MMX version: 64-bit operands\n- SSE version: 128-bit operands\n- AVX versions: 128-bit and 256-bit operands\n- AVX-512 versions: 512-bit operands with optional masking\n\nThe instruction can work with different register sizes and has variants with and without write masking in later SIMD extensions.\n",
    "Alias": []
  },
  {
    "Name": "PMAXSB",
    "Brief": "Compare packed signed byte integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\nLegacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n\nEVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMAXSW",
    "Brief": "Compare packed signed word integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\nLegacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n\nEVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMAXSD",
    "Brief": "Compare packed signed doubleword integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\nLegacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n\nEVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMAXSQ",
    "Brief": "Compare packed signed quadword integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\nLegacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n\nEVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMAXUB",
    "Brief": "Compare packed unsigned byte integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\nLegacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be a YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n\nThe instruction compares each pair of unsigned byte or word integers and selects the maximum value, storing it in the destination register.\n",
    "Alias": []
  },
  {
    "Name": "PMAXUW",
    "Brief": "Compare packed unsigned word integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\nLegacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be a YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n\nThe instruction compares each pair of unsigned byte or word integers and selects the maximum value, storing it in the destination register.\n",
    "Alias": []
  },
  {
    "Name": "VPMAXUB",
    "Brief": "SIMD compare of packed unsigned byte integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\nLegacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be a YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n\nThe instruction compares each pair of unsigned byte or word integers and selects the maximum value, storing it in the destination register.\n",
    "Alias": []
  },
  {
    "Name": "VPMAXUW",
    "Brief": "SIMD compare of packed unsigned word integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\nLegacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be a YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n\nThe instruction compares each pair of unsigned byte or word integers and selects the maximum value, storing it in the destination register.\n",
    "Alias": []
  },
  {
    "Name": "PMAXUD",
    "Brief": "Compare packed unsigned dword integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPMAXUD",
    "Brief": "Compare packed unsigned dword integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPMAXUQ",
    "Brief": "Compare packed unsigned qword integers and return maximum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMINSB",
    "Brief": "Compare packed signed byte integers and return minimum values",
    "Description": "\nPerforms a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\nLegacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMINSW",
    "Brief": "Compare packed signed word integers and return minimum values",
    "Description": "\nPerforms a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\nLegacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPMINSB",
    "Brief": "SIMD compare of packed signed byte integers and return minimum values",
    "Description": "\nPerforms a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\nLegacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPMINSW",
    "Brief": "SIMD compare of packed signed word integers and return minimum values",
    "Description": "\nPerforms a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\nLegacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMINSD",
    "Brief": "Compare packed signed dword integers and store minimum values",
    "Description": "\nPerforms a SIMD compare of the packed signed dword or qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMINSQ",
    "Brief": "Compare packed signed qword integers and store minimum values",
    "Description": "\nPerforms a SIMD compare of the packed signed dword or qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMINUB",
    "Brief": "Compare packed unsigned byte integers and return minimum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\nThe instruction variants differ by register size and instruction set extension:\n- Legacy SSE version (PMINUB): Operates on MMX technology registers or 64-bit memory locations\n- 128-bit SSE version: Operates on XMM registers\n- VEX.128 and VEX.256 versions: Operates on XMM/YMM registers with zero-extension of upper bits\n- EVEX encoded versions: Supports larger register sizes (ZMM/YMM/XMM) with optional write masking\n\nFor each pair of unsigned byte or word integers, the instruction compares the values and selects the smaller value. The comparison is performed element-wise across the entire register, with the result stored in the destination register.\n\nThe instruction supports different vector lengths:\n- Byte-wise comparison: 8-bit elements (PMINUB/VPMINUB)\n- Word-wise comparison: 16-bit elements (PMINUW/VPMINUW)\n\nThe EVEX encoded versions provide additional flexibility with write masking and support for larger vector registers.\n",
    "Alias": []
  },
  {
    "Name": "PMINUW",
    "Brief": "Compare packed unsigned word integers and return minimum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\nThe instruction variants differ by register size and instruction set extension:\n- Legacy SSE version (PMINUB): Operates on MMX technology registers or 64-bit memory locations\n- 128-bit SSE version: Operates on XMM registers\n- VEX.128 and VEX.256 versions: Operates on XMM/YMM registers with zero-extension of upper bits\n- EVEX encoded versions: Supports larger register sizes (ZMM/YMM/XMM) with optional write masking\n\nFor each pair of unsigned byte or word integers, the instruction compares the values and selects the smaller value. The comparison is performed element-wise across the entire register, with the result stored in the destination register.\n\nThe instruction supports different vector lengths:\n- Byte-wise comparison: 8-bit elements (PMINUB/VPMINUB)\n- Word-wise comparison: 16-bit elements (PMINUW/VPMINUW)\n\nThe EVEX encoded versions provide additional flexibility with write masking and support for larger vector registers.\n",
    "Alias": []
  },
  {
    "Name": "VPMINUB",
    "Brief": "Vector compare packed unsigned byte integers and return minimum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\nThe instruction variants differ by register size and instruction set extension:\n- Legacy SSE version (PMINUB): Operates on MMX technology registers or 64-bit memory locations\n- 128-bit SSE version: Operates on XMM registers\n- VEX.128 and VEX.256 versions: Operates on XMM/YMM registers with zero-extension of upper bits\n- EVEX encoded versions: Supports larger register sizes (ZMM/YMM/XMM) with optional write masking\n\nFor each pair of unsigned byte or word integers, the instruction compares the values and selects the smaller value. The comparison is performed element-wise across the entire register, with the result stored in the destination register.\n\nThe instruction supports different vector lengths:\n- Byte-wise comparison: 8-bit elements (PMINUB/VPMINUB)\n- Word-wise comparison: 16-bit elements (PMINUW/VPMINUW)\n\nThe EVEX encoded versions provide additional flexibility with write masking and support for larger vector registers.\n",
    "Alias": []
  },
  {
    "Name": "VPMINUW",
    "Brief": "Vector compare packed unsigned word integers and return minimum values",
    "Description": "\nPerforms a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\nThe instruction variants differ by register size and instruction set extension:\n- Legacy SSE version (PMINUB): Operates on MMX technology registers or 64-bit memory locations\n- 128-bit SSE version: Operates on XMM registers\n- VEX.128 and VEX.256 versions: Operates on XMM/YMM registers with zero-extension of upper bits\n- EVEX encoded versions: Supports larger register sizes (ZMM/YMM/XMM) with optional write masking\n\nFor each pair of unsigned byte or word integers, the instruction compares the values and selects the smaller value. The comparison is performed element-wise across the entire register, with the result stored in the destination register.\n\nThe instruction supports different vector lengths:\n- Byte-wise comparison: 8-bit elements (PMINUB/VPMINUB)\n- Word-wise comparison: 16-bit elements (PMINUW/VPMINUW)\n\nThe EVEX encoded versions provide additional flexibility with write masking and support for larger vector registers.\n",
    "Alias": []
  },
  {
    "Name": "PMINUD",
    "Brief": "Performs a SIMD compare of packed unsigned dword integers and returns the minimum value",
    "Description": "\nPerforms a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPMINUD",
    "Brief": "Performs a SIMD compare of packed unsigned dword integers and returns the minimum value",
    "Description": "\nPerforms a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPMINUQ",
    "Brief": "Performs a SIMD compare of packed unsigned qword integers and returns the minimum value",
    "Description": "\nPerforms a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMOVMSKB",
    "Brief": "Move a byte mask created from the most significant bit of each byte of the source operand",
    "Description": "\nCreates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores the result in the low byte or word of the destination operand (first operand).\n\nThe byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit source operand and 32 bits for 256-bit source operand. The destination operand is a general-purpose register.\n\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\n\nLegacy SSE version: The source operand is an MMX technology register.\n128-bit Legacy SSE version: The source operand is an XMM register.\nVEX.128 encoded version: The source operand is an XMM register.\nVEX.256 encoded version: The source operand is a YMM register.\n\nNote: VEX.vvvv is reserved and must be 1111b.\n",
    "Alias": []
  },
  {
    "Name": "PMOVSXBW",
    "Brief": "Sign extend 8 packed 8-bit integers to 8 packed 16-bit integers",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "PMOVSXBD",
    "Brief": "Sign extend 4 packed 8-bit integers to 4 packed 32-bit integers",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "PMOVSXBQ",
    "Brief": "Sign extend 2 packed 8-bit integers to 2 packed 64-bit integers",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "PMOVSXWD",
    "Brief": "Sign extend 4 packed 16-bit integers to 4 packed 32-bit integers",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "PMOVSXWQ",
    "Brief": "Sign extend 2 packed 16-bit integers to 2 packed 64-bit integers",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "PMOVSXDQ",
    "Brief": "Sign extend 2 packed 32-bit integers to 2 packed 64-bit integers",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSXBW",
    "Brief": "Vector sign extend packed integers from lower bit-width to higher bit-width",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSXBD",
    "Brief": "Vector sign extend packed integers from lower bit-width to higher bit-width",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSXBQ",
    "Brief": "Vector sign extend packed integers from lower bit-width to higher bit-width",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSXWD",
    "Brief": "Vector sign extend packed integers from lower bit-width to higher bit-width",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSXWQ",
    "Brief": "Vector sign extend packed integers from lower bit-width to higher bit-width",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSXDQ",
    "Brief": "Vector sign extend packed integers from lower bit-width to higher bit-width",
    "Description": "\nLegacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThe various forms of instructions (PMOVSXBW, PMOVSXBD, etc.) provide sign extension from different source integer sizes to different destination integer sizes, always taking the lower bits of the source and sign extending them.\n",
    "Alias": []
  },
  {
    "Name": "PMOVZXBW",
    "Brief": "Zero extend 8-bit integers to 16-bit integers",
    "Description": "\nLegacy, VEX, and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "PMOVZXBD",
    "Brief": "Zero extend 8-bit integers to 32-bit integers",
    "Description": "\nLegacy, VEX, and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "PMOVZXBQ",
    "Brief": "Zero extend 8-bit integers to 64-bit integers",
    "Description": "\nLegacy, VEX, and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "PMOVZXWD",
    "Brief": "Zero extend 16-bit integers to 32-bit integers",
    "Description": "\nLegacy, VEX, and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "PMOVZXWQ",
    "Brief": "Zero extend 16-bit integers to 64-bit integers",
    "Description": "\nLegacy, VEX, and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "PMOVZXDQ",
    "Brief": "Zero extend 32-bit integers to 64-bit integers",
    "Description": "\nLegacy, VEX, and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "PMULDQ",
    "Brief": "Multiply packed signed doubleword integers and store quadword results",
    "Description": "\nMultiplies packed signed doubleword integers in the even-numbered (zero-based reference) elements of the first source operand with the packed signed doubleword integers in the corresponding elements of the second source operand and stores packed signed quadword results in the destination operand.\n\n128-bit Legacy SSE version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e., the first (low) and third doubleword element. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand and the destination XMM operand is the same. The second source operand can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n\nVEX.128 encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e., the first (low) and third doubleword element. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e., the first, 3rd, 5th, 7th doubleword element. For 256-bit memory operands, 256 bits are fetched from memory, but only the four even-numbered doublewords are used in the computation. The first source operand and the destination operand are YMM registers. The second source operand can be a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\n\nEVEX encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands. The first source operand is a ZMM/YMM/XMM registers. The second source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination is a ZMM/YMM/XMM register, and updated according to the writemask at 64-bit granularity.\n",
    "Alias": []
  },
  {
    "Name": "PMULHRSW",
    "Brief": "Packed Multiply High With Round and Scale",
    "Description": "\nPMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32-bit integers.\n\nThe multiplication process involves the following steps:\n1. Multiply corresponding 16-bit signed integers\n2. Truncate the result to the 18 most significant bits\n3. Round the result by adding 1 to the least significant bit\n4. Select the 16 bits immediately to the right of the most significant bit\n5. Pack the results into the destination operand\n\nThe instruction supports multiple variants:\n- Legacy SSE version with 64-bit MMX registers\n- 128-bit SSE version with XMM registers\n- VEX-encoded 128-bit and 256-bit versions\n- EVEX-encoded versions supporting write masks for 128-bit, 256-bit, and 512-bit registers\n\nWhen the source operand is a memory operand, it must be aligned on a 16-byte boundary, or a general-protection exception will be generated.\n\nIn 64-bit mode, a REX prefix can be used to access XMM8-XMM15 registers when not using VEX/EVEX encoding.\n",
    "Alias": []
  },
  {
    "Name": "PMULHUW",
    "Brief": "Multiply packed unsigned word integers and store high 16 bits of result",
    "Description": "\nPerforms a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the destination operand.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nThe instruction performs unsigned multiplication of packed 16-bit integers, storing only the high 16 bits of each result. This is useful for scaling and other high-precision multiplication operations.\n",
    "Alias": []
  },
  {
    "Name": "PMULHW",
    "Brief": "Multiply Packed Signed Integers and Store High Result",
    "Description": "\nPerforms a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destination operand.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMULLD",
    "Brief": "Multiply packed dword signed integers and store low 32 bits of each product",
    "Description": "\nPerforms a SIMD signed multiply of the packed signed dword/qword integers from each element of the first source operand with the corresponding element in the second source operand. The low 32/64 bits of each 64/128-bit intermediate results are stored to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMULLQ",
    "Brief": "Multiply packed qword signed integers and store low 64 bits of each product",
    "Description": "\nPerforms a SIMD signed multiply of the packed signed dword/qword integers from each element of the first source operand with the corresponding element in the second source operand. The low 32/64 bits of each 64/128-bit intermediate results are stored to the destination operand.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMULLW",
    "Brief": "Multiply packed signed word integers and store low 16 bits of the results",
    "Description": "\nPerforms a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destination operand.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "PMULUDQ",
    "Brief": "Multiply Packed Unsigned Doubleword Integers",
    "Description": "\nMultiplies the first operand (destination operand) by the second operand (source operand) and stores the result in the destination operand.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nLegacy SSE version 64-bit operand: The source operand can be an unsigned doubleword integer stored in the low doubleword of an MMX technology register or a 64-bit memory location. The destination operand can be an unsigned doubleword integer stored in the low doubleword an MMX technology register. The result is an unsigned quadword integer stored in the destination an MMX technology register. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).\n\nFor 64-bit memory operands, 64 bits are fetched from memory, but only the low doubleword is used in the computation.\n\n128-bit Legacy SSE version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register.\n\nVEX and EVEX encoded versions support multiplication of packed unsigned doubleword integers across different vector register sizes (128-bit, 256-bit, and 512-bit) with additional features like writemask and broadcast.\n",
    "Alias": []
  },
  {
    "Name": "POP",
    "Brief": "Pop a value from the stack into a destination operand",
    "Description": "\nLoads the value from the top of the stack to the location specified with the destination operand and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.\n\nAddress and operand sizes are determined as follows:\n- Address size: Determined by the D flag in the current code-segment descriptor, can be overridden by an instruction prefix (67H).\n- Operand size: Determined by the D flag in the current code-segment descriptor, can be overridden by instruction prefixes (66H or REX.W).\n- Stack-address size: Outside 64-bit mode, determined by the B flag in the current stack-segment descriptor; in 64-bit mode, always 64 bits.\n\nWhen popping into segment registers (DS, ES, FS, GS, SS) in protected mode:\n- The value must be a valid segment selector.\n- Loading automatically validates the segment selector and loads descriptor information.\n- A NULL value (0000-0003) can be popped into DS, ES, FS, or GS without causing an immediate fault.\n\nSpecial notes:\n- Cannot pop into the CS register (use RET instead).\n- In 64-bit mode, POPs using 32-bit operands are not encodable.\n- POPs to DS, ES, SS are not valid in 64-bit mode.\n- Loading SS suppresses debug exceptions and interrupts on the next instruction boundary.\n",
    "Alias": []
  },
  {
    "Name": "POPA",
    "Brief": "Pop words from the stack into general-purpose registers",
    "Description": "\nPops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are loaded in the following order:\n\n- For 32-bit operand size (POPAD): EDI, ESI, EBP, EBX, EDX, ECX, and EAX\n- For 16-bit operand size (POPA): DI, SI, BP, BX, DX, CX, and AX\n\nThe value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded.\n\nThe POPA and POPAD mnemonics reference the same opcode. The choice between them depends on the operand-size attribute (16 or 32 bits). Some assemblers may enforce the operand size based on the mnemonic used, while others may use the current operand-size attribute setting.\n\nThis instruction is only valid in non-64-bit modes and will generate an Undefined Instruction (#UD) exception in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "POPAD",
    "Brief": "Pop doublewords from the stack into general-purpose registers",
    "Description": "\nPops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are loaded in the following order:\n\n- For 32-bit operand size (POPAD): EDI, ESI, EBP, EBX, EDX, ECX, and EAX\n- For 16-bit operand size (POPA): DI, SI, BP, BX, DX, CX, and AX\n\nThe value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded.\n\nThe POPA and POPAD mnemonics reference the same opcode. The choice between them depends on the operand-size attribute (16 or 32 bits). Some assemblers may enforce the operand size based on the mnemonic used, while others may use the current operand-size attribute setting.\n\nThis instruction is only valid in non-64-bit modes and will generate an Undefined Instruction (#UD) exception in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "POPCNT",
    "Brief": "Return the count of number of bits set to 1",
    "Description": "\nThis instruction calculates the number of bits set to 1 in the second operand (source) and returns the count in the first operand (a destination register).\n\nThe instruction works by iterating through each bit of the source operand and incrementing a counter for each bit that is set to 1. The final count is then stored in the destination register.\n\nFlags are affected as follows:\n- OF, SF, AF, CF, PF are all cleared\n- ZF is set if the source operand is 0, otherwise ZF is cleared\n\nThe instruction is available for 16-bit, 32-bit, and 64-bit operands, with the 64-bit version requiring the REX.W prefix.\n\nNote that the instruction requires POPCNT support, which can be checked via the CPUID feature flag (CPUID.01H:ECX.POPCNT [Bit 23]).\n",
    "Alias": []
  },
  {
    "Name": "POPF",
    "Brief": "Pop top of stack into lower 16 bits of EFLAGS",
    "Description": "\nPops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD/PUSHFQ instructions.\n\nThe POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD.\n\nThe effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation:\n\n- In protected, compatibility, or 64-bit mode at privilege level 0, all non-reserved flags except RF, VIP, VIF, and VM may be modified.\n- In protected, compatibility, or 64-bit mode with a privilege level greater than 0, some flags are restricted from modification based on the current privilege level and IOPL.\n- In virtual-8086 mode, the behavior depends on the IOPL and whether virtual-8086 mode extensions are enabled.\n\nIn 64-bit mode, the mnemonic POPFQ is used, which pops 64 bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits) are not affected.\n",
    "Alias": []
  },
  {
    "Name": "POPFD",
    "Brief": "Pop top of stack into EFLAGS",
    "Description": "\nPops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD/PUSHFQ instructions.\n\nThe POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD.\n\nThe effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation:\n\n- In protected, compatibility, or 64-bit mode at privilege level 0, all non-reserved flags except RF, VIP, VIF, and VM may be modified.\n- In protected, compatibility, or 64-bit mode with a privilege level greater than 0, some flags are restricted from modification based on the current privilege level and IOPL.\n- In virtual-8086 mode, the behavior depends on the IOPL and whether virtual-8086 mode extensions are enabled.\n\nIn 64-bit mode, the mnemonic POPFQ is used, which pops 64 bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits) are not affected.\n",
    "Alias": []
  },
  {
    "Name": "POPFQ",
    "Brief": "Pop top of stack and zero-extend into RFLAGS",
    "Description": "\nPops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD/PUSHFQ instructions.\n\nThe POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD.\n\nThe effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation:\n\n- In protected, compatibility, or 64-bit mode at privilege level 0, all non-reserved flags except RF, VIP, VIF, and VM may be modified.\n- In protected, compatibility, or 64-bit mode with a privilege level greater than 0, some flags are restricted from modification based on the current privilege level and IOPL.\n- In virtual-8086 mode, the behavior depends on the IOPL and whether virtual-8086 mode extensions are enabled.\n\nIn 64-bit mode, the mnemonic POPFQ is used, which pops 64 bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits) are not affected.\n",
    "Alias": []
  },
  {
    "Name": "POR",
    "Brief": "Performs a bitwise logical OR operation on the source and destination operands",
    "Description": "\nPerforms a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nDifferent versions of the instruction support various register sizes and formats:\n- Legacy SSE version supports MMX technology registers and 64-bit memory locations\n- 128-bit Legacy SSE version supports XMM registers and 128-bit memory locations\n- VEX.128 and VEX.256 encoded versions support XMM and YMM registers\n- EVEX encoded versions support ZMM/YMM/XMM registers with optional write-masking and broadcasting\n\nThe instruction variants include:\n- POR: Basic bitwise OR for 64-bit operands\n- VPOR: Vector bitwise OR with different register sizes\n- VPORD: Bitwise OR for packed doubleword integers\n- VPORQ: Bitwise OR for packed quadword integers\n",
    "Alias": []
  },
  {
    "Name": "VPOR",
    "Brief": "Vector bitwise logical OR operation with different register sizes",
    "Description": "\nPerforms a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nDifferent versions of the instruction support various register sizes and formats:\n- Legacy SSE version supports MMX technology registers and 64-bit memory locations\n- 128-bit Legacy SSE version supports XMM registers and 128-bit memory locations\n- VEX.128 and VEX.256 encoded versions support XMM and YMM registers\n- EVEX encoded versions support ZMM/YMM/XMM registers with optional write-masking and broadcasting\n\nThe instruction variants include:\n- POR: Basic bitwise OR for 64-bit operands\n- VPOR: Vector bitwise OR with different register sizes\n- VPORD: Bitwise OR for packed doubleword integers\n- VPORQ: Bitwise OR for packed quadword integers\n",
    "Alias": []
  },
  {
    "Name": "VPORD",
    "Brief": "Vector bitwise logical OR operation for packed doubleword integers",
    "Description": "\nPerforms a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nDifferent versions of the instruction support various register sizes and formats:\n- Legacy SSE version supports MMX technology registers and 64-bit memory locations\n- 128-bit Legacy SSE version supports XMM registers and 128-bit memory locations\n- VEX.128 and VEX.256 encoded versions support XMM and YMM registers\n- EVEX encoded versions support ZMM/YMM/XMM registers with optional write-masking and broadcasting\n\nThe instruction variants include:\n- POR: Basic bitwise OR for 64-bit operands\n- VPOR: Vector bitwise OR with different register sizes\n- VPORD: Bitwise OR for packed doubleword integers\n- VPORQ: Bitwise OR for packed quadword integers\n",
    "Alias": []
  },
  {
    "Name": "VPORQ",
    "Brief": "Vector bitwise logical OR operation for packed quadword integers",
    "Description": "\nPerforms a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nDifferent versions of the instruction support various register sizes and formats:\n- Legacy SSE version supports MMX technology registers and 64-bit memory locations\n- 128-bit Legacy SSE version supports XMM registers and 128-bit memory locations\n- VEX.128 and VEX.256 encoded versions support XMM and YMM registers\n- EVEX encoded versions support ZMM/YMM/XMM registers with optional write-masking and broadcasting\n\nThe instruction variants include:\n- POR: Basic bitwise OR for 64-bit operands\n- VPOR: Vector bitwise OR with different register sizes\n- VPORD: Bitwise OR for packed doubleword integers\n- VPORQ: Bitwise OR for packed quadword integers\n",
    "Alias": []
  },
  {
    "Name": "PREFETCHW",
    "Brief": "Prefetch Data Into Caches in Anticipation of a Write",
    "Description": "\nFetches the cache line of data from memory that contains the byte specified with the source operand to a location in the 1st or 2nd level cache and invalidates other cached instances of the line.\n\nThe source operand is a byte memory location. If the line selected is already present in the lowest level cache and is already in an exclusively owned state, no data movement occurs. Prefetches from non-writeback memory are ignored.\n\nThe PREFETCHW instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor and invalidates other cached copies in anticipation of the line being written to in the future.\n\nThe characteristic of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes.\n\nProcessors are free to speculatively fetch and cache data with exclusive ownership from system memory regions that permit such accesses. A PREFETCHW instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHW instruction is not ordered with respect to fence instructions, locked memory references, CLFLUSH, CLFLUSHOPT instructions, or other general instructions.\n\nIt is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.\n",
    "Alias": []
  },
  {
    "Name": "PREFETCHT0",
    "Brief": "Move data from memory closer to the processor using T0 hint (temporal data)",
    "Description": "\nFetches the line of data from memory that contains the specified byte to a location in the cache hierarchy specified by a locality hint:\n\n- T0 (temporal data)—prefetch data into all levels of the cache hierarchy.\n- T1 (temporal data with respect to first level cache misses)—prefetch data into level 2 cache and higher.\n- T2 (temporal data with respect to second level cache misses)—prefetch data into level 3 cache and higher, or an implementation-specific choice.\n- NTA (non-temporal data with respect to all cache levels)—prefetch data into non-temporal cache structure and into a location close to the processor, minimizing cache pollution.\n\nThe source operand is a byte memory location. If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\n\nThe PREFETCH instructions are merely a hint and do not affect program behavior. If executed, these instructions move data closer to the processor in anticipation of future use. The implementation of prefetch locality hints is implementation-dependent and can be overloaded or ignored by a processor implementation.\n\nThe amount of data prefetched is processor implementation-dependent but will be a minimum of 32 bytes. These instructions are not ordered with respect to fence instructions, locked memory references, or other general instructions, except for serializing instructions.\n",
    "Alias": []
  },
  {
    "Name": "PREFETCHT1",
    "Brief": "Move data from memory closer to the processor using T1 hint (temporal data with respect to first level cache misses)",
    "Description": "\nFetches the line of data from memory that contains the specified byte to a location in the cache hierarchy specified by a locality hint:\n\n- T0 (temporal data)—prefetch data into all levels of the cache hierarchy.\n- T1 (temporal data with respect to first level cache misses)—prefetch data into level 2 cache and higher.\n- T2 (temporal data with respect to second level cache misses)—prefetch data into level 3 cache and higher, or an implementation-specific choice.\n- NTA (non-temporal data with respect to all cache levels)—prefetch data into non-temporal cache structure and into a location close to the processor, minimizing cache pollution.\n\nThe source operand is a byte memory location. If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\n\nThe PREFETCH instructions are merely a hint and do not affect program behavior. If executed, these instructions move data closer to the processor in anticipation of future use. The implementation of prefetch locality hints is implementation-dependent and can be overloaded or ignored by a processor implementation.\n\nThe amount of data prefetched is processor implementation-dependent but will be a minimum of 32 bytes. These instructions are not ordered with respect to fence instructions, locked memory references, or other general instructions, except for serializing instructions.\n",
    "Alias": []
  },
  {
    "Name": "PREFETCHT2",
    "Brief": "Move data from memory closer to the processor using T2 hint (temporal data with respect to second level cache misses)",
    "Description": "\nFetches the line of data from memory that contains the specified byte to a location in the cache hierarchy specified by a locality hint:\n\n- T0 (temporal data)—prefetch data into all levels of the cache hierarchy.\n- T1 (temporal data with respect to first level cache misses)—prefetch data into level 2 cache and higher.\n- T2 (temporal data with respect to second level cache misses)—prefetch data into level 3 cache and higher, or an implementation-specific choice.\n- NTA (non-temporal data with respect to all cache levels)—prefetch data into non-temporal cache structure and into a location close to the processor, minimizing cache pollution.\n\nThe source operand is a byte memory location. If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\n\nThe PREFETCH instructions are merely a hint and do not affect program behavior. If executed, these instructions move data closer to the processor in anticipation of future use. The implementation of prefetch locality hints is implementation-dependent and can be overloaded or ignored by a processor implementation.\n\nThe amount of data prefetched is processor implementation-dependent but will be a minimum of 32 bytes. These instructions are not ordered with respect to fence instructions, locked memory references, or other general instructions, except for serializing instructions.\n",
    "Alias": []
  },
  {
    "Name": "PREFETCHNTA",
    "Brief": "Move data from memory closer to the processor using NTA hint (non-temporal data with respect to all cache levels)",
    "Description": "\nFetches the line of data from memory that contains the specified byte to a location in the cache hierarchy specified by a locality hint:\n\n- T0 (temporal data)—prefetch data into all levels of the cache hierarchy.\n- T1 (temporal data with respect to first level cache misses)—prefetch data into level 2 cache and higher.\n- T2 (temporal data with respect to second level cache misses)—prefetch data into level 3 cache and higher, or an implementation-specific choice.\n- NTA (non-temporal data with respect to all cache levels)—prefetch data into non-temporal cache structure and into a location close to the processor, minimizing cache pollution.\n\nThe source operand is a byte memory location. If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\n\nThe PREFETCH instructions are merely a hint and do not affect program behavior. If executed, these instructions move data closer to the processor in anticipation of future use. The implementation of prefetch locality hints is implementation-dependent and can be overloaded or ignored by a processor implementation.\n\nThe amount of data prefetched is processor implementation-dependent but will be a minimum of 32 bytes. These instructions are not ordered with respect to fence instructions, locked memory references, or other general instructions, except for serializing instructions.\n",
    "Alias": []
  },
  {
    "Name": "PSADBW",
    "Brief": "Compute Sum of Absolute Differences",
    "Description": "\nComputes the absolute value of the difference of 8 unsigned byte integers from the source operand (second operand) and from the destination operand (first operand). These 8 differences are then summed to produce an unsigned word integer result that is stored in the destination operand.\n\nWhen operating on 64-bit operands, the word integer result is stored in the low word of the destination operand, and the remaining bytes in the destination operand are cleared to all 0s.\n\nWhen operating on 128-bit operands, two packed results are computed. The 8 low-order bytes of the source and destination operands are operated on to produce a word result that is stored in the low word of the destination operand, and the 8 high-order bytes are operated on to produce a word result that is stored in bits 64 through 79 of the destination operand. The remaining bytes of the destination operand are cleared.\n\nFor 256-bit version, the third group of 8 differences are summed to produce an unsigned word in bits[143:128] of the destination register and the fourth group of 8 differences are summed to produce an unsigned word in bits[207:192] of the destination register. The remaining words of the destination are set to 0.\n\nFor 512-bit version, additional groups of differences are summed and stored in specific bit ranges of the destination register, with the remaining bits set to 0.\n",
    "Alias": []
  },
  {
    "Name": "PSHUFB",
    "Brief": "Packed Shuffle Bytes",
    "Description": "\nPSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle control mask in the source operand (the second operand). The instruction permutes the data in the destination operand, leaving the shuffle mask unaffected.\n\nKey characteristics:\n- If the most significant bit (bit[7]) of each byte of the shuffle control mask is set, then constant zero is written in the result byte.\n- Each byte in the shuffle control mask forms an index to permute the corresponding byte in the destination operand.\n- The value of each index is the least significant 4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte.\n\nVariations:\n- Legacy SSE version: 64-bit operands, both can be MMX registers\n- 128-bit Legacy SSE version: First source and destination operands are the same\n- VEX.128 version: Destination is first operand, first source is second, second source is third. Upper bits of destination YMM register are zeroed.\n- VEX.256 version: Performs shuffles on upper and lower 128-bit lanes\n- EVEX version: Supports write masking and can operate on larger register sizes (128/256/512 bits)\n\nThe instruction provides a flexible way to rearrange bytes within a vector register, with the ability to zero out specific bytes based on the control mask.\n",
    "Alias": []
  },
  {
    "Name": "VPSHUFB",
    "Brief": "Vector Packed Shuffle Bytes",
    "Description": "\nPSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle control mask in the source operand (the second operand). The instruction permutes the data in the destination operand, leaving the shuffle mask unaffected.\n\nKey characteristics:\n- If the most significant bit (bit[7]) of each byte of the shuffle control mask is set, then constant zero is written in the result byte.\n- Each byte in the shuffle control mask forms an index to permute the corresponding byte in the destination operand.\n- The value of each index is the least significant 4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte.\n\nVariations:\n- Legacy SSE version: 64-bit operands, both can be MMX registers\n- 128-bit Legacy SSE version: First source and destination operands are the same\n- VEX.128 version: Destination is first operand, first source is second, second source is third. Upper bits of destination YMM register are zeroed.\n- VEX.256 version: Performs shuffles on upper and lower 128-bit lanes\n- EVEX version: Supports write masking and can operate on larger register sizes (128/256/512 bits)\n\nThe instruction provides a flexible way to rearrange bytes within a vector register, with the ability to zero out specific bytes based on the control mask.\n",
    "Alias": []
  },
  {
    "Name": "PSHUFD",
    "Brief": "Shuffle packed doublewords in source operand based on immediate value",
    "Description": "\nCopies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand).\n\nEach 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and copies it to the target element in the destination operand. The encoded value of bits 1:0 of the order operand determines which doubleword element (from the respective 128-bit lane) of the source operand will be copied to doubleword 0 of the destination operand.\n\nFor 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate.\n\nThe instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.\n\nVariations of the instruction exist for different vector lengths and encoding methods (Legacy SSE, VEX, and EVEX), with slightly different behaviors regarding register zeroing and broadcast options.\n",
    "Alias": []
  },
  {
    "Name": "PSHUFHW",
    "Brief": "Shuffle Packed High Words",
    "Description": "\nCopies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand.\n\nEach 2-bit field in the immediate operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand. The low quadword of the source operand is copied to the low quadword of the destination operand, for each 128-bit lane.\n\nThis instruction permits a word in the high quadword of the source operand to be copied to more than one word location in the high quadword of the destination operand.\n\nDifferent versions of the instruction support:\n- 128-bit Legacy SSE version\n- VEX.128 encoded version\n- VEX.256 encoded version\n- EVEX encoded versions for 128-bit, 256-bit, and 512-bit operations\n\nThe destination operand can be an XMM, YMM, or ZMM register, and the source operand can be a register or memory location. EVEX encoded versions support write masking.\n",
    "Alias": []
  },
  {
    "Name": "VPSHUFHW",
    "Brief": "Shuffle Packed High Words (Vector)",
    "Description": "\nCopies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand.\n\nEach 2-bit field in the immediate operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand. The low quadword of the source operand is copied to the low quadword of the destination operand, for each 128-bit lane.\n\nThis instruction permits a word in the high quadword of the source operand to be copied to more than one word location in the high quadword of the destination operand.\n\nDifferent versions of the instruction support:\n- 128-bit Legacy SSE version\n- VEX.128 encoded version\n- VEX.256 encoded version\n- EVEX encoded versions for 128-bit, 256-bit, and 512-bit operations\n\nThe destination operand can be an XMM, YMM, or ZMM register, and the source operand can be a register or memory location. EVEX encoded versions support write masking.\n",
    "Alias": []
  },
  {
    "Name": "PSHUFLW",
    "Brief": "Shuffle Packed Low Words",
    "Description": "\nCopies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. \n\nEach 2-bit field in the immediate operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand to be copied to the destination operand. \n\nThe high quadword of the source operand is copied to the high quadword of the destination operand, for each 128-bit lane.\n\nThis instruction permits a word in the low quadword of the source operand to be copied to more than one word location in the low quadword of the destination operand.\n\nKey variations:\n- 128-bit Legacy SSE version: Destination is an XMM register, source can be XMM register or 128-bit memory location\n- VEX.128 version: Zeroes upper bits of destination YMM register\n- VEX.256 version: Operates on 256-bit lanes\n- EVEX encoded version: Supports write masking and operates on larger register sizes (ZMM/YMM/XMM)\n\nNote: In VEX encoded versions, VEX.vvvv must be 1111b, otherwise an undefined instruction (#UD) exception will be raised.\n",
    "Alias": []
  },
  {
    "Name": "VPSHUFLW",
    "Brief": "Shuffle Packed Low Words (vector extension versions)",
    "Description": "\nCopies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. \n\nEach 2-bit field in the immediate operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand to be copied to the destination operand. \n\nThe high quadword of the source operand is copied to the high quadword of the destination operand, for each 128-bit lane.\n\nThis instruction permits a word in the low quadword of the source operand to be copied to more than one word location in the low quadword of the destination operand.\n\nKey variations:\n- 128-bit Legacy SSE version: Destination is an XMM register, source can be XMM register or 128-bit memory location\n- VEX.128 version: Zeroes upper bits of destination YMM register\n- VEX.256 version: Operates on 256-bit lanes\n- EVEX encoded version: Supports write masking and operates on larger register sizes (ZMM/YMM/XMM)\n\nNote: In VEX encoded versions, VEX.vvvv must be 1111b, otherwise an undefined instruction (#UD) exception will be raised.\n",
    "Alias": []
  },
  {
    "Name": "PSHUFW",
    "Brief": "Shuffle the words in the source operand based on an immediate value",
    "Description": "\nCopies words from the source operand (second operand) and inserts them in the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the PSHUFD instruction.\n\nEach 2-bit field in the order operand selects the contents of one word location in the destination operand. The encodings of the order operand fields select words from the source operand to be copied to the destination operand.\n\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register. The order operand is an 8-bit immediate. Note that this instruction permits a word in the source operand to be copied to more than one word location in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "PSIGNB",
    "Brief": "Negate/zero/preserve packed byte integers based on sign",
    "Description": "\nPSIGNB, PSIGNW, and PSIGND are instructions that modify the sign of packed integers based on the sign of a corresponding control value:\n\n- If the control value is less than zero, the corresponding data element is negated.\n- If the control value is zero, the corresponding data element is set to zero.\n- If the control value is positive, the corresponding data element remains unchanged.\n\nSpecific details:\n- PSIGNB operates on signed bytes\n- PSIGNW operates on 16-bit signed words\n- PSIGND operates on signed 32-bit integers\n\nThe instructions support different register sizes:\n- MMX registers (64-bit)\n- SSE XMM registers (128-bit)\n- AVX YMM registers (256-bit)\n\nThe instruction variations include:\n- Legacy SSE instructions for MMX and XMM registers\n- VEX-encoded instructions for XMM and YMM registers with different vector lengths\n\nIn 64-bit mode, the REX prefix can be used to access additional registers.\n",
    "Alias": []
  },
  {
    "Name": "PSIGNW",
    "Brief": "Negate/zero/preserve packed word integers based on sign",
    "Description": "\nPSIGNB, PSIGNW, and PSIGND are instructions that modify the sign of packed integers based on the sign of a corresponding control value:\n\n- If the control value is less than zero, the corresponding data element is negated.\n- If the control value is zero, the corresponding data element is set to zero.\n- If the control value is positive, the corresponding data element remains unchanged.\n\nSpecific details:\n- PSIGNB operates on signed bytes\n- PSIGNW operates on 16-bit signed words\n- PSIGND operates on signed 32-bit integers\n\nThe instructions support different register sizes:\n- MMX registers (64-bit)\n- SSE XMM registers (128-bit)\n- AVX YMM registers (256-bit)\n\nThe instruction variations include:\n- Legacy SSE instructions for MMX and XMM registers\n- VEX-encoded instructions for XMM and YMM registers with different vector lengths\n\nIn 64-bit mode, the REX prefix can be used to access additional registers.\n",
    "Alias": []
  },
  {
    "Name": "PSIGND",
    "Brief": "Negate/zero/preserve packed doubleword integers based on sign",
    "Description": "\nPSIGNB, PSIGNW, and PSIGND are instructions that modify the sign of packed integers based on the sign of a corresponding control value:\n\n- If the control value is less than zero, the corresponding data element is negated.\n- If the control value is zero, the corresponding data element is set to zero.\n- If the control value is positive, the corresponding data element remains unchanged.\n\nSpecific details:\n- PSIGNB operates on signed bytes\n- PSIGNW operates on 16-bit signed words\n- PSIGND operates on signed 32-bit integers\n\nThe instructions support different register sizes:\n- MMX registers (64-bit)\n- SSE XMM registers (128-bit)\n- AVX YMM registers (256-bit)\n\nThe instruction variations include:\n- Legacy SSE instructions for MMX and XMM registers\n- VEX-encoded instructions for XMM and YMM registers with different vector lengths\n\nIn 64-bit mode, the REX prefix can be used to access additional registers.\n",
    "Alias": []
  },
  {
    "Name": "PSLLW",
    "Brief": "Shift packed words left logical",
    "Description": "\nThese instructions shift the bits in the individual data elements (words, doublewords, or quadwords) in the destination operand to the left by the number of bits specified in the count operand. As the bits are shifted left, the empty low-order bits are cleared (set to 0).\n\nKey characteristics:\n- If the count is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), the destination operand is set to all 0s\n- Supports various register sizes: MMX, XMM, YMM, and ZMM registers\n- Different variants for immediate count and variable count shifts\n- VEX and EVEX encoded versions support additional features like write masking and zero masking\n\nVariants include:\n- Shifting by an immediate 8-bit value\n- Shifting by a count from a register\n- Different vector length versions (128-bit, 256-bit, 512-bit)\n- Legacy SSE, AVX, and AVX-512 versions\n\nThe shift operation zeros out the low-order bits and shifts existing bits to the left, effectively multiplying the value by powers of 2.\n",
    "Alias": []
  },
  {
    "Name": "PSLLD",
    "Brief": "Shift packed doublewords left logical",
    "Description": "\nThese instructions shift the bits in the individual data elements (words, doublewords, or quadwords) in the destination operand to the left by the number of bits specified in the count operand. As the bits are shifted left, the empty low-order bits are cleared (set to 0).\n\nKey characteristics:\n- If the count is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), the destination operand is set to all 0s\n- Supports various register sizes: MMX, XMM, YMM, and ZMM registers\n- Different variants for immediate count and variable count shifts\n- VEX and EVEX encoded versions support additional features like write masking and zero masking\n\nVariants include:\n- Shifting by an immediate 8-bit value\n- Shifting by a count from a register\n- Different vector length versions (128-bit, 256-bit, 512-bit)\n- Legacy SSE, AVX, and AVX-512 versions\n\nThe shift operation zeros out the low-order bits and shifts existing bits to the left, effectively multiplying the value by powers of 2.\n",
    "Alias": []
  },
  {
    "Name": "PSLLQ",
    "Brief": "Shift packed quadwords left logical",
    "Description": "\nThese instructions shift the bits in the individual data elements (words, doublewords, or quadwords) in the destination operand to the left by the number of bits specified in the count operand. As the bits are shifted left, the empty low-order bits are cleared (set to 0).\n\nKey characteristics:\n- If the count is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), the destination operand is set to all 0s\n- Supports various register sizes: MMX, XMM, YMM, and ZMM registers\n- Different variants for immediate count and variable count shifts\n- VEX and EVEX encoded versions support additional features like write masking and zero masking\n\nVariants include:\n- Shifting by an immediate 8-bit value\n- Shifting by a count from a register\n- Different vector length versions (128-bit, 256-bit, 512-bit)\n- Legacy SSE, AVX, and AVX-512 versions\n\nThe shift operation zeros out the low-order bits and shifts existing bits to the left, effectively multiplying the value by powers of 2.\n",
    "Alias": []
  },
  {
    "Name": "VPSLLW",
    "Brief": "Vector shift packed words left logical",
    "Description": "\nThese instructions shift the bits in the individual data elements (words, doublewords, or quadwords) in the destination operand to the left by the number of bits specified in the count operand. As the bits are shifted left, the empty low-order bits are cleared (set to 0).\n\nKey characteristics:\n- If the count is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), the destination operand is set to all 0s\n- Supports various register sizes: MMX, XMM, YMM, and ZMM registers\n- Different variants for immediate count and variable count shifts\n- VEX and EVEX encoded versions support additional features like write masking and zero masking\n\nVariants include:\n- Shifting by an immediate 8-bit value\n- Shifting by a count from a register\n- Different vector length versions (128-bit, 256-bit, 512-bit)\n- Legacy SSE, AVX, and AVX-512 versions\n\nThe shift operation zeros out the low-order bits and shifts existing bits to the left, effectively multiplying the value by powers of 2.\n",
    "Alias": []
  },
  {
    "Name": "VPSLLD",
    "Brief": "Vector shift packed doublewords left logical",
    "Description": "\nThese instructions shift the bits in the individual data elements (words, doublewords, or quadwords) in the destination operand to the left by the number of bits specified in the count operand. As the bits are shifted left, the empty low-order bits are cleared (set to 0).\n\nKey characteristics:\n- If the count is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), the destination operand is set to all 0s\n- Supports various register sizes: MMX, XMM, YMM, and ZMM registers\n- Different variants for immediate count and variable count shifts\n- VEX and EVEX encoded versions support additional features like write masking and zero masking\n\nVariants include:\n- Shifting by an immediate 8-bit value\n- Shifting by a count from a register\n- Different vector length versions (128-bit, 256-bit, 512-bit)\n- Legacy SSE, AVX, and AVX-512 versions\n\nThe shift operation zeros out the low-order bits and shifts existing bits to the left, effectively multiplying the value by powers of 2.\n",
    "Alias": []
  },
  {
    "Name": "VPSLLQ",
    "Brief": "Vector shift packed quadwords left logical",
    "Description": "\nThese instructions shift the bits in the individual data elements (words, doublewords, or quadwords) in the destination operand to the left by the number of bits specified in the count operand. As the bits are shifted left, the empty low-order bits are cleared (set to 0).\n\nKey characteristics:\n- If the count is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), the destination operand is set to all 0s\n- Supports various register sizes: MMX, XMM, YMM, and ZMM registers\n- Different variants for immediate count and variable count shifts\n- VEX and EVEX encoded versions support additional features like write masking and zero masking\n\nVariants include:\n- Shifting by an immediate 8-bit value\n- Shifting by a count from a register\n- Different vector length versions (128-bit, 256-bit, 512-bit)\n- Legacy SSE, AVX, and AVX-512 versions\n\nThe shift operation zeros out the low-order bits and shifts existing bits to the left, effectively multiplying the value by powers of 2.\n",
    "Alias": []
  },
  {
    "Name": "PSLLDQ",
    "Brief": "Shift Double Quadword Left Logical",
    "Description": "\nShifts the destination operand (first operand) to the left by the number of bytes specified in the count operand (second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.\n\n128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\n\nVEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.\n",
    "Alias": []
  },
  {
    "Name": "PSRAW",
    "Brief": "Shift packed words right arithmetic",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand to the right by the number of bits specified in the count operand. As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element.\n\nIf the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element.\n\nThe instructions have several variants:\n- Legacy SSE versions for MMX and XMM registers\n- VEX-encoded versions for 128-bit and 256-bit registers\n- EVEX-encoded versions for 512-bit registers with additional masking and broadcasting capabilities\n\nThe main difference between PSRAW/PSRAD and VPSRAW/VPSRAD is the vector length and additional features in the VEX and EVEX variants. The VPSRAQ instruction specifically handles quadword (64-bit) shifts with sign extension.\n\nThe shift operation preserves the sign bit during right shifting, which is useful for maintaining the sign of signed integer values during arithmetic right shifts.\n",
    "Alias": []
  },
  {
    "Name": "PSRAD",
    "Brief": "Shift packed doublewords right arithmetic",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand to the right by the number of bits specified in the count operand. As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element.\n\nIf the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element.\n\nThe instructions have several variants:\n- Legacy SSE versions for MMX and XMM registers\n- VEX-encoded versions for 128-bit and 256-bit registers\n- EVEX-encoded versions for 512-bit registers with additional masking and broadcasting capabilities\n\nThe main difference between PSRAW/PSRAD and VPSRAW/VPSRAD is the vector length and additional features in the VEX and EVEX variants. The VPSRAQ instruction specifically handles quadword (64-bit) shifts with sign extension.\n\nThe shift operation preserves the sign bit during right shifting, which is useful for maintaining the sign of signed integer values during arithmetic right shifts.\n",
    "Alias": []
  },
  {
    "Name": "VPSRAW",
    "Brief": "Shift packed words right arithmetic (vector)",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand to the right by the number of bits specified in the count operand. As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element.\n\nIf the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element.\n\nThe instructions have several variants:\n- Legacy SSE versions for MMX and XMM registers\n- VEX-encoded versions for 128-bit and 256-bit registers\n- EVEX-encoded versions for 512-bit registers with additional masking and broadcasting capabilities\n\nThe main difference between PSRAW/PSRAD and VPSRAW/VPSRAD is the vector length and additional features in the VEX and EVEX variants. The VPSRAQ instruction specifically handles quadword (64-bit) shifts with sign extension.\n\nThe shift operation preserves the sign bit during right shifting, which is useful for maintaining the sign of signed integer values during arithmetic right shifts.\n",
    "Alias": []
  },
  {
    "Name": "VPSRAD",
    "Brief": "Shift packed doublewords right arithmetic (vector)",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand to the right by the number of bits specified in the count operand. As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element.\n\nIf the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element.\n\nThe instructions have several variants:\n- Legacy SSE versions for MMX and XMM registers\n- VEX-encoded versions for 128-bit and 256-bit registers\n- EVEX-encoded versions for 512-bit registers with additional masking and broadcasting capabilities\n\nThe main difference between PSRAW/PSRAD and VPSRAW/VPSRAD is the vector length and additional features in the VEX and EVEX variants. The VPSRAQ instruction specifically handles quadword (64-bit) shifts with sign extension.\n\nThe shift operation preserves the sign bit during right shifting, which is useful for maintaining the sign of signed integer values during arithmetic right shifts.\n",
    "Alias": []
  },
  {
    "Name": "VPSRAQ",
    "Brief": "Shift packed quadwords right arithmetic (vector)",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand to the right by the number of bits specified in the count operand. As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element.\n\nIf the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element.\n\nThe instructions have several variants:\n- Legacy SSE versions for MMX and XMM registers\n- VEX-encoded versions for 128-bit and 256-bit registers\n- EVEX-encoded versions for 512-bit registers with additional masking and broadcasting capabilities\n\nThe main difference between PSRAW/PSRAD and VPSRAW/VPSRAD is the vector length and additional features in the VEX and EVEX variants. The VPSRAQ instruction specifically handles quadword (64-bit) shifts with sign extension.\n\nThe shift operation preserves the sign bit during right shifting, which is useful for maintaining the sign of signed integer values during arithmetic right shifts.\n",
    "Alias": []
  },
  {
    "Name": "PSRLW",
    "Brief": "Shift packed words right by specified amount while shifting in zeros",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). \n\nIf the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s.\n\nThe instruction variants support different operand sizes and shifting methods:\n- PSRLW: Shifts words (16-bit elements)\n- PSRLD: Shifts doublewords (32-bit elements)\n- PSRLQ: Shifts quadwords (64-bit elements)\n\nEach instruction has multiple variants supporting:\n- Shifting by an immediate value\n- Shifting by a count from a register\n- Different register sizes (MMX, XMM, YMM, ZMM)\n- Masked and unmasked operations in newer instruction set extensions\n\nThe instructions are available in multiple instruction set generations:\n- Legacy SSE (MMX/SSE2)\n- VEX-encoded (AVX/AVX2)\n- EVEX-encoded (AVX-512)\n\nOnly the low 64 bits of a 128-bit count operand are checked to compute the count.\n",
    "Alias": []
  },
  {
    "Name": "PSRLD",
    "Brief": "Shift packed doublewords right by specified amount while shifting in zeros",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). \n\nIf the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s.\n\nThe instruction variants support different operand sizes and shifting methods:\n- PSRLW: Shifts words (16-bit elements)\n- PSRLD: Shifts doublewords (32-bit elements)\n- PSRLQ: Shifts quadwords (64-bit elements)\n\nEach instruction has multiple variants supporting:\n- Shifting by an immediate value\n- Shifting by a count from a register\n- Different register sizes (MMX, XMM, YMM, ZMM)\n- Masked and unmasked operations in newer instruction set extensions\n\nThe instructions are available in multiple instruction set generations:\n- Legacy SSE (MMX/SSE2)\n- VEX-encoded (AVX/AVX2)\n- EVEX-encoded (AVX-512)\n\nOnly the low 64 bits of a 128-bit count operand are checked to compute the count.\n",
    "Alias": []
  },
  {
    "Name": "PSRLQ",
    "Brief": "Shift packed quadwords right by specified amount while shifting in zeros",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). \n\nIf the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s.\n\nThe instruction variants support different operand sizes and shifting methods:\n- PSRLW: Shifts words (16-bit elements)\n- PSRLD: Shifts doublewords (32-bit elements)\n- PSRLQ: Shifts quadwords (64-bit elements)\n\nEach instruction has multiple variants supporting:\n- Shifting by an immediate value\n- Shifting by a count from a register\n- Different register sizes (MMX, XMM, YMM, ZMM)\n- Masked and unmasked operations in newer instruction set extensions\n\nThe instructions are available in multiple instruction set generations:\n- Legacy SSE (MMX/SSE2)\n- VEX-encoded (AVX/AVX2)\n- EVEX-encoded (AVX-512)\n\nOnly the low 64 bits of a 128-bit count operand are checked to compute the count.\n",
    "Alias": []
  },
  {
    "Name": "PSRLDQ",
    "Brief": "Shift Double Quadword Right Logical",
    "Description": "\nShifts the destination operand (first operand) to the right by the number of bytes specified in the count operand (second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\n128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\n\nVEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The count operand applies to both the low and high 128-bit lanes.\n\nVEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.\n",
    "Alias": []
  },
  {
    "Name": "PSUBB",
    "Brief": "Subtract packed byte integers",
    "Description": "\nPerforms a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.\n\nThe (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.\n\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.\n\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.\n\nThe instructions support various register sizes and encoding formats, including MMX, SSE, AVX, and EVEX, with different vector lengths (128-bit, 256-bit, and 512-bit) and optional write masking for EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "PSUBW",
    "Brief": "Subtract packed word integers",
    "Description": "\nPerforms a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.\n\nThe (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.\n\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.\n\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.\n\nThe instructions support various register sizes and encoding formats, including MMX, SSE, AVX, and EVEX, with different vector lengths (128-bit, 256-bit, and 512-bit) and optional write masking for EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "PSUBD",
    "Brief": "Subtract packed doubleword integers",
    "Description": "\nPerforms a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.\n\nThe (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.\n\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.\n\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.\n\nThe instructions support various register sizes and encoding formats, including MMX, SSE, AVX, and EVEX, with different vector lengths (128-bit, 256-bit, and 512-bit) and optional write masking for EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "VPSUBB",
    "Brief": "Vector subtract packed byte integers",
    "Description": "\nPerforms a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.\n\nThe (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.\n\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.\n\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.\n\nThe instructions support various register sizes and encoding formats, including MMX, SSE, AVX, and EVEX, with different vector lengths (128-bit, 256-bit, and 512-bit) and optional write masking for EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "VPSUBW",
    "Brief": "Vector subtract packed word integers",
    "Description": "\nPerforms a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.\n\nThe (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.\n\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.\n\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.\n\nThe instructions support various register sizes and encoding formats, including MMX, SSE, AVX, and EVEX, with different vector lengths (128-bit, 256-bit, and 512-bit) and optional write masking for EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "VPSUBD",
    "Brief": "Vector subtract packed doubleword integers",
    "Description": "\nPerforms a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.\n\nThe (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.\n\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.\n\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.\n\nThe instructions support various register sizes and encoding formats, including MMX, SSE, AVX, and EVEX, with different vector lengths (128-bit, 256-bit, and 512-bit) and optional write masking for EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "PSUBQ",
    "Brief": "Subtract packed quadword integers",
    "Description": "\nSubtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).\n\nNote that the (V)PSUBQ instruction can operate on either unsigned or signed (two's complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values upon which it operates.\n\nThe instruction supports various vector lengths and encoding variants:\n- Legacy SSE version: 64-bit and 128-bit operands\n- VEX.128 and VEX.256 encoded versions: XMM and YMM registers\n- EVEX encoded versions: ZMM/YMM/XMM registers with optional write masking and broadcasting\n\nWhen overflow occurs, the result is wrapped around, and only the low 64 bits are retained in the destination element.\n",
    "Alias": []
  },
  {
    "Name": "VPSUBQ",
    "Brief": "Vector subtract packed quadword integers",
    "Description": "\nSubtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).\n\nNote that the (V)PSUBQ instruction can operate on either unsigned or signed (two's complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values upon which it operates.\n\nThe instruction supports various vector lengths and encoding variants:\n- Legacy SSE version: 64-bit and 128-bit operands\n- VEX.128 and VEX.256 encoded versions: XMM and YMM registers\n- EVEX encoded versions: ZMM/YMM/XMM registers with optional write masking and broadcasting\n\nWhen overflow occurs, the result is wrapped around, and only the low 64 bits are retained in the destination element.\n",
    "Alias": []
  },
  {
    "Name": "PSUBSB",
    "Brief": "Subtract packed signed byte integers with signed saturation",
    "Description": "\nPerforms a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\n\nThe (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\n\nDifferent versions of the instruction exist for various SIMD register sizes and instruction set extensions (MMX, SSE, AVX, AVX-512):\n- Legacy MMX/SSE versions work with 64-bit and 128-bit registers\n- VEX-encoded versions support 128-bit and 256-bit registers with zero-extending\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit registers with masking and saturation\n\nOverflow is handled with signed saturation, ensuring that the result stays within the representable range of signed integers.\n",
    "Alias": []
  },
  {
    "Name": "PSUBSW",
    "Brief": "Subtract packed signed word integers with signed saturation",
    "Description": "\nPerforms a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\n\nThe (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\n\nDifferent versions of the instruction exist for various SIMD register sizes and instruction set extensions (MMX, SSE, AVX, AVX-512):\n- Legacy MMX/SSE versions work with 64-bit and 128-bit registers\n- VEX-encoded versions support 128-bit and 256-bit registers with zero-extending\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit registers with masking and saturation\n\nOverflow is handled with signed saturation, ensuring that the result stays within the representable range of signed integers.\n",
    "Alias": []
  },
  {
    "Name": "VPSUBSB",
    "Brief": "Vector subtract packed signed byte integers with signed saturation",
    "Description": "\nPerforms a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\n\nThe (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\n\nDifferent versions of the instruction exist for various SIMD register sizes and instruction set extensions (MMX, SSE, AVX, AVX-512):\n- Legacy MMX/SSE versions work with 64-bit and 128-bit registers\n- VEX-encoded versions support 128-bit and 256-bit registers with zero-extending\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit registers with masking and saturation\n\nOverflow is handled with signed saturation, ensuring that the result stays within the representable range of signed integers.\n",
    "Alias": []
  },
  {
    "Name": "VPSUBSW",
    "Brief": "Vector subtract packed signed word integers with signed saturation",
    "Description": "\nPerforms a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand.\n\nThe (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\n\nThe (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\n\nDifferent versions of the instruction exist for various SIMD register sizes and instruction set extensions (MMX, SSE, AVX, AVX-512):\n- Legacy MMX/SSE versions work with 64-bit and 128-bit registers\n- VEX-encoded versions support 128-bit and 256-bit registers with zero-extending\n- EVEX-encoded versions support 128-bit, 256-bit, and 512-bit registers with masking and saturation\n\nOverflow is handled with signed saturation, ensuring that the result stays within the representable range of signed integers.\n",
    "Alias": []
  },
  {
    "Name": "PSUBUSB",
    "Brief": "Subtract packed unsigned integers with unsigned saturation (byte)",
    "Description": "\nPerforms a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand.\n\nThe (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.\n\nThe (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.\n\nThese instructions can operate on 64-bit or 128-bit operands, with different versions supporting MMX, SSE, AVX, and AVX-512 instruction sets. The instructions have various encoding variants:\n\n- Legacy SSE version: 64-bit operands with MMX registers\n- 128-bit Legacy SSE version: XMM registers with 128-bit operands\n- VEX.128 and VEX.256 versions: Support for AVX with zero-extended destination\n- EVEX versions: Support for AVX-512 with writemask and optional saturation\n\nThe key feature of these instructions is unsigned saturation, which means that if the subtraction result would be negative, the result is clamped to zero instead of wrapping around.\n",
    "Alias": []
  },
  {
    "Name": "PSUBUSW",
    "Brief": "Subtract packed unsigned integers with unsigned saturation (word)",
    "Description": "\nPerforms a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand.\n\nThe (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.\n\nThe (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.\n\nThese instructions can operate on 64-bit or 128-bit operands, with different versions supporting MMX, SSE, AVX, and AVX-512 instruction sets. The instructions have various encoding variants:\n\n- Legacy SSE version: 64-bit operands with MMX registers\n- 128-bit Legacy SSE version: XMM registers with 128-bit operands\n- VEX.128 and VEX.256 versions: Support for AVX with zero-extended destination\n- EVEX versions: Support for AVX-512 with writemask and optional saturation\n\nThe key feature of these instructions is unsigned saturation, which means that if the subtraction result would be negative, the result is clamped to zero instead of wrapping around.\n",
    "Alias": []
  },
  {
    "Name": "PTEST",
    "Brief": "Logical comparison of packed bits",
    "Description": "\nPTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.\n\nThe first source register is specified by the ModR/M reg field.\n\n128-bit versions: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.\n\nVEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nThe instruction performs two key operations:\n1. Sets the Zero Flag (ZF) if the bitwise AND of the source operands is zero\n2. Sets the Carry Flag (CF) if the bitwise AND of the second source and the logical NOT of the first source is zero\n\nThe flags OF, AF, PF, and SF are cleared during this operation.\n",
    "Alias": []
  },
  {
    "Name": "VPTEST",
    "Brief": "Vector logical comparison of packed bits",
    "Description": "\nPTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.\n\nThe first source register is specified by the ModR/M reg field.\n\n128-bit versions: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.\n\nVEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nThe instruction performs two key operations:\n1. Sets the Zero Flag (ZF) if the bitwise AND of the source operands is zero\n2. Sets the Carry Flag (CF) if the bitwise AND of the second source and the logical NOT of the first source is zero\n\nThe flags OF, AF, PF, and SF are cleared during this operation.\n",
    "Alias": []
  },
  {
    "Name": "PTWRITE",
    "Brief": "Write data to a Processor Trace packet",
    "Description": "\nThis instruction reads data in the source operand and sends it to the Intel Processor Trace hardware to be encoded in a PTW packet if TriggerEn, ContextEn, FilterEn, and PTWEn are all set to 1. \n\nThe size of data is 64-bit if using REX.W in 64-bit mode, otherwise 32-bits of data are copied from the source operand.\n\nThe instruction will raise an Undefined Opcode (#UD) exception if the 66H prefix is used.\n\nIf the specified conditions are met, the instruction will:\n- Set the payload bytes to the encoded payload size\n- Set the instruction pointer (IP) based on the IA32_RTIT_CTL.FUPonPTW setting\n- Optionally insert a FUP (Flow Update Packet) with the IP of the PTWRITE instruction\n\nFor more details, refer to the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3C, Section 33.2.2, \"Software Trace Instrumentation with PTWRITE.\"\n",
    "Alias": []
  },
  {
    "Name": "PUNPCKHBW",
    "Brief": "Unpack and interleave high-order bytes from two operands",
    "Description": "\nThese instructions unpack and interleave the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The low-order data elements are ignored.\n\nThe instructions can be used to convert data elements from smaller to larger sizes by placing all 0s in the source operand. When the source operand contains all 0s, the result contains zero extensions of the high-order data elements from the original value in the destination operand.\n\nSpecific operations:\n- PUNPCKHBW: Interleaves high-order bytes, converting to unsigned word integers\n- PUNPCKHWD: Interleaves high-order words, converting to unsigned doubleword integers\n- PUNPCKHDQ: Interleaves high-order doublewords\n- PUNPCKHQDQ: Interleaves high-order quadwords\n\nThe instructions support various vector register sizes (64-bit MMX, 128-bit SSE, 256-bit AVX, and 512-bit AVX-512) with different encoding variants (legacy, VEX, and EVEX).\n\nIn 64-bit mode, these instructions can be used with REX prefixes to access additional registers. The instructions can work with memory operands or registers, with different behavior depending on the specific encoding and vector length.\n",
    "Alias": []
  },
  {
    "Name": "PUNPCKHWD",
    "Brief": "Unpack and interleave high-order words from two operands",
    "Description": "\nThese instructions unpack and interleave the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The low-order data elements are ignored.\n\nThe instructions can be used to convert data elements from smaller to larger sizes by placing all 0s in the source operand. When the source operand contains all 0s, the result contains zero extensions of the high-order data elements from the original value in the destination operand.\n\nSpecific operations:\n- PUNPCKHBW: Interleaves high-order bytes, converting to unsigned word integers\n- PUNPCKHWD: Interleaves high-order words, converting to unsigned doubleword integers\n- PUNPCKHDQ: Interleaves high-order doublewords\n- PUNPCKHQDQ: Interleaves high-order quadwords\n\nThe instructions support various vector register sizes (64-bit MMX, 128-bit SSE, 256-bit AVX, and 512-bit AVX-512) with different encoding variants (legacy, VEX, and EVEX).\n\nIn 64-bit mode, these instructions can be used with REX prefixes to access additional registers. The instructions can work with memory operands or registers, with different behavior depending on the specific encoding and vector length.\n",
    "Alias": []
  },
  {
    "Name": "PUNPCKHDQ",
    "Brief": "Unpack and interleave high-order doublewords from two operands",
    "Description": "\nThese instructions unpack and interleave the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The low-order data elements are ignored.\n\nThe instructions can be used to convert data elements from smaller to larger sizes by placing all 0s in the source operand. When the source operand contains all 0s, the result contains zero extensions of the high-order data elements from the original value in the destination operand.\n\nSpecific operations:\n- PUNPCKHBW: Interleaves high-order bytes, converting to unsigned word integers\n- PUNPCKHWD: Interleaves high-order words, converting to unsigned doubleword integers\n- PUNPCKHDQ: Interleaves high-order doublewords\n- PUNPCKHQDQ: Interleaves high-order quadwords\n\nThe instructions support various vector register sizes (64-bit MMX, 128-bit SSE, 256-bit AVX, and 512-bit AVX-512) with different encoding variants (legacy, VEX, and EVEX).\n\nIn 64-bit mode, these instructions can be used with REX prefixes to access additional registers. The instructions can work with memory operands or registers, with different behavior depending on the specific encoding and vector length.\n",
    "Alias": []
  },
  {
    "Name": "PUNPCKHQDQ",
    "Brief": "Unpack and interleave high-order quadwords from two operands",
    "Description": "\nThese instructions unpack and interleave the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The low-order data elements are ignored.\n\nThe instructions can be used to convert data elements from smaller to larger sizes by placing all 0s in the source operand. When the source operand contains all 0s, the result contains zero extensions of the high-order data elements from the original value in the destination operand.\n\nSpecific operations:\n- PUNPCKHBW: Interleaves high-order bytes, converting to unsigned word integers\n- PUNPCKHWD: Interleaves high-order words, converting to unsigned doubleword integers\n- PUNPCKHDQ: Interleaves high-order doublewords\n- PUNPCKHQDQ: Interleaves high-order quadwords\n\nThe instructions support various vector register sizes (64-bit MMX, 128-bit SSE, 256-bit AVX, and 512-bit AVX-512) with different encoding variants (legacy, VEX, and EVEX).\n\nIn 64-bit mode, these instructions can be used with REX prefixes to access additional registers. The instructions can work with memory operands or registers, with different behavior depending on the specific encoding and vector length.\n",
    "Alias": []
  },
  {
    "Name": "PUNPCKLBW",
    "Brief": "Interleave low-order bytes from source and destination operands",
    "Description": "\nThese instructions unpack and interleave the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The high-order data elements are ignored.\n\nThe instructions can be used to convert data between different sizes:\n- PUNPCKLBW: Convert bytes to words by zero-extending high-order bytes\n- PUNPCKLWD: Convert words to doublewords by zero-extending high-order words\n- PUNPCKLDQ: Convert doublewords to quadwords by zero-extending high-order doublewords\n- PUNPCKLQDQ: Convert quadwords to double quadwords\n\nThe specific operation depends on the instruction variant:\n- Legacy MMX/SSE versions modify the existing destination register\n- VEX/EVEX versions support wider vector registers (XMM, YMM, ZMM) and provide additional features like zero-masking and write-masking\n\nIn 64-bit mode, REX prefixes can be used to access additional registers (XMM8-XMM15).\n\nThe instructions support various operand sizes and can interleave data from different register types and memory locations, with specific behavior defined for 128-bit, 256-bit, and 512-bit vector lengths.\n",
    "Alias": []
  },
  {
    "Name": "PUNPCKLWD",
    "Brief": "Interleave low-order words from source and destination operands",
    "Description": "\nThese instructions unpack and interleave the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The high-order data elements are ignored.\n\nThe instructions can be used to convert data between different sizes:\n- PUNPCKLBW: Convert bytes to words by zero-extending high-order bytes\n- PUNPCKLWD: Convert words to doublewords by zero-extending high-order words\n- PUNPCKLDQ: Convert doublewords to quadwords by zero-extending high-order doublewords\n- PUNPCKLQDQ: Convert quadwords to double quadwords\n\nThe specific operation depends on the instruction variant:\n- Legacy MMX/SSE versions modify the existing destination register\n- VEX/EVEX versions support wider vector registers (XMM, YMM, ZMM) and provide additional features like zero-masking and write-masking\n\nIn 64-bit mode, REX prefixes can be used to access additional registers (XMM8-XMM15).\n\nThe instructions support various operand sizes and can interleave data from different register types and memory locations, with specific behavior defined for 128-bit, 256-bit, and 512-bit vector lengths.\n",
    "Alias": []
  },
  {
    "Name": "PUNPCKLDQ",
    "Brief": "Interleave low-order doublewords from source and destination operands",
    "Description": "\nThese instructions unpack and interleave the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The high-order data elements are ignored.\n\nThe instructions can be used to convert data between different sizes:\n- PUNPCKLBW: Convert bytes to words by zero-extending high-order bytes\n- PUNPCKLWD: Convert words to doublewords by zero-extending high-order words\n- PUNPCKLDQ: Convert doublewords to quadwords by zero-extending high-order doublewords\n- PUNPCKLQDQ: Convert quadwords to double quadwords\n\nThe specific operation depends on the instruction variant:\n- Legacy MMX/SSE versions modify the existing destination register\n- VEX/EVEX versions support wider vector registers (XMM, YMM, ZMM) and provide additional features like zero-masking and write-masking\n\nIn 64-bit mode, REX prefixes can be used to access additional registers (XMM8-XMM15).\n\nThe instructions support various operand sizes and can interleave data from different register types and memory locations, with specific behavior defined for 128-bit, 256-bit, and 512-bit vector lengths.\n",
    "Alias": []
  },
  {
    "Name": "PUNPCKLQDQ",
    "Brief": "Interleave low-order quadwords from source and destination operands",
    "Description": "\nThese instructions unpack and interleave the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The high-order data elements are ignored.\n\nThe instructions can be used to convert data between different sizes:\n- PUNPCKLBW: Convert bytes to words by zero-extending high-order bytes\n- PUNPCKLWD: Convert words to doublewords by zero-extending high-order words\n- PUNPCKLDQ: Convert doublewords to quadwords by zero-extending high-order doublewords\n- PUNPCKLQDQ: Convert quadwords to double quadwords\n\nThe specific operation depends on the instruction variant:\n- Legacy MMX/SSE versions modify the existing destination register\n- VEX/EVEX versions support wider vector registers (XMM, YMM, ZMM) and provide additional features like zero-masking and write-masking\n\nIn 64-bit mode, REX prefixes can be used to access additional registers (XMM8-XMM15).\n\nThe instructions support various operand sizes and can interleave data from different register types and memory locations, with specific behavior defined for 128-bit, 256-bit, and 512-bit vector lengths.\n",
    "Alias": []
  },
  {
    "Name": "PUSH",
    "Brief": "Push a value onto the stack",
    "Description": "\nDecrements the stack pointer and then stores the source operand on the top of the stack. The PUSH instruction can push various types of operands:\n\n1. Register operands (16, 32, or 64 bits)\n2. Memory operands (16, 32, or 64 bits)\n3. Immediate values (8, 16, or 32 bits)\n4. Segment registers (CS, SS, DS, ES, FS, GS)\n\nKey characteristics of the PUSH instruction:\n- Address size is determined by the D flag in the code-segment descriptor or can be overridden by an instruction prefix\n- Operand size determines the amount by which the stack pointer is decremented (2, 4, or 8 bytes)\n- Immediate operands less than the operand size are sign-extended\n- Segment register pushes may be zero-extended depending on the operand size\n\nSpecial cases:\n- PUSH ESP pushes the value of ESP as it existed before the instruction was executed\n- In 64-bit mode, the stack pointer size is always 64 bits\n- Pushing a value may result in a misaligned stack pointer if the operand size is less than the stack-address size\n\nNote: In real-address mode, if the SP or ESP register is 1 when PUSH is executed, it can trigger a stack-fault exception.\n",
    "Alias": []
  },
  {
    "Name": "PUSHA",
    "Brief": "Push all 16-bit general-purpose registers onto the stack",
    "Description": "\nPushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the following order:\n\n- For 32-bit operand size (PUSHAD): EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI\n- For 16-bit operand size (PUSHA): AX, CX, DX, BX, original SP, BP, SI, and DI\n\nThe value pushed for the ESP or SP register is its value before pushing the first register. These instructions perform the reverse operation of the POPA/POPAD instructions.\n\nThe PUSHA and PUSHAD mnemonics reference the same opcode, with the operand size determining the register width. Some assemblers may force the operand size to 16 for PUSHA and 32 for PUSHAD, while others may treat them as synonyms.\n\nThis instruction is valid only in compatibility and legacy modes. It is not valid in 64-bit mode and will generate an #UD (Undefined Opcode) exception if used.\n\nIn real-address mode, if the ESP or SP register has certain specific values when PUSHA/PUSHAD executes, it can trigger special exception handling.\n",
    "Alias": []
  },
  {
    "Name": "PUSHAD",
    "Brief": "Push all 32-bit general-purpose registers onto the stack",
    "Description": "\nPushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the following order:\n\n- For 32-bit operand size (PUSHAD): EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI\n- For 16-bit operand size (PUSHA): AX, CX, DX, BX, original SP, BP, SI, and DI\n\nThe value pushed for the ESP or SP register is its value before pushing the first register. These instructions perform the reverse operation of the POPA/POPAD instructions.\n\nThe PUSHA and PUSHAD mnemonics reference the same opcode, with the operand size determining the register width. Some assemblers may force the operand size to 16 for PUSHA and 32 for PUSHAD, while others may treat them as synonyms.\n\nThis instruction is valid only in compatibility and legacy modes. It is not valid in 64-bit mode and will generate an #UD (Undefined Opcode) exception if used.\n\nIn real-address mode, if the ESP or SP register has certain specific values when PUSHA/PUSHAD executes, it can trigger special exception handling.\n",
    "Alias": []
  },
  {
    "Name": "PUSHF",
    "Brief": "Push lower 16 bits of EFLAGS register onto the stack",
    "Description": "\nDecrements the stack pointer and pushes the contents of the flags register onto the stack:\n\n- PUSHF pushes the lower 16 bits of EFLAGS (FLAGS register)\n- PUSHFD pushes the entire 32-bit EFLAGS register\n- PUSHFQ pushes the 64-bit RFLAGS register in 64-bit mode\n\nWhen copying the entire EFLAGS/RFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, their values are cleared in the image stored on the stack.\n\nIn 64-bit mode, the default operation is to decrement the stack pointer (RSP) by 8 and push RFLAGS. 16-bit operation is supported using the operand size override prefix 66H.\n\nIn virtual-8086 mode:\n- Without virtual-8086 mode extensions (CR4.VME = 0), PUSHF/PUSHFD can only be used if IOPL = 3\n- With virtual-8086 mode extensions (CR4.VME = 1), PUSHF can be executed with IOPL < 3\n\nIf the ESP or SP register is 1 when the instruction executes in real-address mode, an #SS exception is generated, followed by a #DF exception.\n",
    "Alias": []
  },
  {
    "Name": "PUSHFD",
    "Brief": "Push entire EFLAGS register onto the stack",
    "Description": "\nDecrements the stack pointer and pushes the contents of the flags register onto the stack:\n\n- PUSHF pushes the lower 16 bits of EFLAGS (FLAGS register)\n- PUSHFD pushes the entire 32-bit EFLAGS register\n- PUSHFQ pushes the 64-bit RFLAGS register in 64-bit mode\n\nWhen copying the entire EFLAGS/RFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, their values are cleared in the image stored on the stack.\n\nIn 64-bit mode, the default operation is to decrement the stack pointer (RSP) by 8 and push RFLAGS. 16-bit operation is supported using the operand size override prefix 66H.\n\nIn virtual-8086 mode:\n- Without virtual-8086 mode extensions (CR4.VME = 0), PUSHF/PUSHFD can only be used if IOPL = 3\n- With virtual-8086 mode extensions (CR4.VME = 1), PUSHF can be executed with IOPL < 3\n\nIf the ESP or SP register is 1 when the instruction executes in real-address mode, an #SS exception is generated, followed by a #DF exception.\n",
    "Alias": []
  },
  {
    "Name": "PUSHFQ",
    "Brief": "Push RFLAGS register onto the stack",
    "Description": "\nDecrements the stack pointer and pushes the contents of the flags register onto the stack:\n\n- PUSHF pushes the lower 16 bits of EFLAGS (FLAGS register)\n- PUSHFD pushes the entire 32-bit EFLAGS register\n- PUSHFQ pushes the 64-bit RFLAGS register in 64-bit mode\n\nWhen copying the entire EFLAGS/RFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, their values are cleared in the image stored on the stack.\n\nIn 64-bit mode, the default operation is to decrement the stack pointer (RSP) by 8 and push RFLAGS. 16-bit operation is supported using the operand size override prefix 66H.\n\nIn virtual-8086 mode:\n- Without virtual-8086 mode extensions (CR4.VME = 0), PUSHF/PUSHFD can only be used if IOPL = 3\n- With virtual-8086 mode extensions (CR4.VME = 1), PUSHF can be executed with IOPL < 3\n\nIf the ESP or SP register is 1 when the instruction executes in real-address mode, an #SS exception is generated, followed by a #DF exception.\n",
    "Alias": []
  },
  {
    "Name": "PXOR",
    "Brief": "Performs a bitwise logical exclusive-OR (XOR) operation",
    "Description": "\nPerforms a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nThe instruction supports multiple variants:\n- Legacy SSE version: Operates on MMX and XMM registers with 64-bit or 128-bit operands\n- VEX.128 and VEX.256 versions: Operates on XMM and YMM registers with zeroing of upper bits\n- EVEX encoded versions: Supports ZMM/YMM/XMM registers with optional write-masking and broadcasting\n\nThe different variants (VPXORD and VPXORQ) support bitwise XOR on different integer sizes:\n- VPXORD operates on packed 32-bit (doubleword) integers\n- VPXORQ operates on packed 64-bit (quadword) integers\n\nThe instruction can perform the XOR operation with various register sizes (128-bit, 256-bit, and 512-bit) and supports different masking and broadcasting modes in its EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "VPXOR",
    "Brief": "Performs a bitwise logical exclusive-OR (XOR) operation with vector registers",
    "Description": "\nPerforms a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nThe instruction supports multiple variants:\n- Legacy SSE version: Operates on MMX and XMM registers with 64-bit or 128-bit operands\n- VEX.128 and VEX.256 versions: Operates on XMM and YMM registers with zeroing of upper bits\n- EVEX encoded versions: Supports ZMM/YMM/XMM registers with optional write-masking and broadcasting\n\nThe different variants (VPXORD and VPXORQ) support bitwise XOR on different integer sizes:\n- VPXORD operates on packed 32-bit (doubleword) integers\n- VPXORQ operates on packed 64-bit (quadword) integers\n\nThe instruction can perform the XOR operation with various register sizes (128-bit, 256-bit, and 512-bit) and supports different masking and broadcasting modes in its EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "VPXORD",
    "Brief": "Performs a bitwise logical exclusive-OR (XOR) operation on packed doubleword integers",
    "Description": "\nPerforms a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nThe instruction supports multiple variants:\n- Legacy SSE version: Operates on MMX and XMM registers with 64-bit or 128-bit operands\n- VEX.128 and VEX.256 versions: Operates on XMM and YMM registers with zeroing of upper bits\n- EVEX encoded versions: Supports ZMM/YMM/XMM registers with optional write-masking and broadcasting\n\nThe different variants (VPXORD and VPXORQ) support bitwise XOR on different integer sizes:\n- VPXORD operates on packed 32-bit (doubleword) integers\n- VPXORQ operates on packed 64-bit (quadword) integers\n\nThe instruction can perform the XOR operation with various register sizes (128-bit, 256-bit, and 512-bit) and supports different masking and broadcasting modes in its EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "VPXORQ",
    "Brief": "Performs a bitwise logical exclusive-OR (XOR) operation on packed quadword integers",
    "Description": "\nPerforms a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.\n\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nThe instruction supports multiple variants:\n- Legacy SSE version: Operates on MMX and XMM registers with 64-bit or 128-bit operands\n- VEX.128 and VEX.256 versions: Operates on XMM and YMM registers with zeroing of upper bits\n- EVEX encoded versions: Supports ZMM/YMM/XMM registers with optional write-masking and broadcasting\n\nThe different variants (VPXORD and VPXORQ) support bitwise XOR on different integer sizes:\n- VPXORD operates on packed 32-bit (doubleword) integers\n- VPXORQ operates on packed 64-bit (quadword) integers\n\nThe instruction can perform the XOR operation with various register sizes (128-bit, 256-bit, and 512-bit) and supports different masking and broadcasting modes in its EVEX-encoded versions.\n",
    "Alias": []
  },
  {
    "Name": "RCL",
    "Brief": "Rotate through carry left",
    "Description": "\nShifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).\n\nThe rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.\n\nThe RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.\n\nThe OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.\n",
    "Alias": []
  },
  {
    "Name": "RCR",
    "Brief": "Rotate through carry right",
    "Description": "\nShifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).\n\nThe rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.\n\nThe RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.\n\nThe OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.\n",
    "Alias": []
  },
  {
    "Name": "ROL",
    "Brief": "Rotate left",
    "Description": "\nShifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).\n\nThe rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.\n\nThe RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.\n\nThe OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.\n",
    "Alias": []
  },
  {
    "Name": "ROR",
    "Brief": "Rotate right",
    "Description": "\nShifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).\n\nThe rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.\n\nThe RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.\n\nThe OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.\n",
    "Alias": []
  },
  {
    "Name": "RCPPS",
    "Brief": "Compute approximate reciprocals of packed single precision floating-point values",
    "Description": "\nPerforms a SIMD computation of the approximate reciprocals of the four packed single precision floating-point values in the source operand and stores the packed single precision floating-point results in the destination operand.\n\nThe relative error for this approximation is: |Relative Error| ≤ 1.5 ∗ 2^-12\n\nThe RCPPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results are always flushed to 0.0, with the sign of the operand.\n\nWhen a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nThe instruction supports 128-bit legacy SSE, VEX.128, and VEX.256 versions, with different handling of upper bits of the destination register.\n",
    "Alias": []
  },
  {
    "Name": "RCPSS",
    "Brief": "Compute approximate reciprocal of scalar single precision floating-point value",
    "Description": "\nComputes an approximate reciprocal of the low single precision floating-point value in the source operand and stores the single precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.\n\nThe relative error for this approximation is: |Relative Error| ≤ 1.5 * 2^-12\n\nThe RCPSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results are always flushed to 0.0, with the sign of the operand.\n\nWhen a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n\nFor the 128-bit Legacy SSE version, the first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\n\nFor the VEX.128 encoded version, bits (MAXVL-1:128) of the destination YMM register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "RDFSBASE",
    "Brief": "Load the destination register with the FS segment base address",
    "Description": "\nLoads the general-purpose register indicated by the ModR/M:r/m field with the FS or GS segment base address.\n\nThe destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.\n\nThis instruction is supported only in 64-bit mode. It requires the FSGSBASE feature to be enabled in CR4 and supported by the processor's CPUID.\n\nThe instruction can be used to read the base address of the FS or GS segment registers, which can be useful for accessing thread-local storage or other segment-based memory access patterns in 64-bit mode.\n\nKey restrictions:\n- Only available in 64-bit mode\n- Generates an undefined opcode (#UD) exception if:\n  * LOCK prefix is used\n  * CR4.FSGSBASE[bit 16] = 0\n  * CPUID.07H.0H:EBX.FSGSBASE[bit 0] = 0\n",
    "Alias": []
  },
  {
    "Name": "RDGSBASE",
    "Brief": "Load the destination register with the GS segment base address",
    "Description": "\nLoads the general-purpose register indicated by the ModR/M:r/m field with the FS or GS segment base address.\n\nThe destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.\n\nThis instruction is supported only in 64-bit mode. It requires the FSGSBASE feature to be enabled in CR4 and supported by the processor's CPUID.\n\nThe instruction can be used to read the base address of the FS or GS segment registers, which can be useful for accessing thread-local storage or other segment-based memory access patterns in 64-bit mode.\n\nKey restrictions:\n- Only available in 64-bit mode\n- Generates an undefined opcode (#UD) exception if:\n  * LOCK prefix is used\n  * CR4.FSGSBASE[bit 16] = 0\n  * CPUID.07H.0H:EBX.FSGSBASE[bit 0] = 0\n",
    "Alias": []
  },
  {
    "Name": "RDMSR",
    "Brief": "Read from Model Specific Register",
    "Description": "\nReads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.\n\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception.\n\nThe MSRs control functions for testability, execution tracing, performance-monitoring, and machine check errors. Each processor family has its own set of MSRs.\n\nThe CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction.\n\nThe MSRs and the ability to read them with the RDMSR instruction were introduced into the IA-32 Architecture with the Pentium processor. Execution of this instruction by an IA-32 processor earlier than the Pentium processor results in an invalid opcode exception #UD.\n",
    "Alias": []
  },
  {
    "Name": "RDPID",
    "Brief": "Read Processor ID from IA32_TSC_AUX MSR",
    "Description": "\nReads the value of the IA32_TSC_AUX MSR (address C0000103H) into the destination register. The value of CS.D and operand-size prefixes (66H and REX.W) do not affect the behavior of the RDPID instruction.\n\nThe instruction can read the MSR value into a 32-bit or 64-bit register depending on the operand size. The CPUID feature flag RDPID must be set for the instruction to be valid.\n\nKey characteristics:\n- Reads from MSR address C0000103H\n- No flags are affected\n- Requires CPUID.7H.0:ECX.RDPID[bit 22] to be set\n- Cannot be used with a LOCK prefix\n",
    "Alias": []
  },
  {
    "Name": "RDPKRU",
    "Brief": "Read Protection Key Rights for User Pages",
    "Description": "\nReads the value of PKRU into EAX and clears EDX. ECX must be 0 when RDPKRU is executed; otherwise, a general-protection exception (#GP) occurs.\n\nRDPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].\n\nOn processors that support the Intel 64 Architecture, the high-order 32-bits of RCX are ignored and the high-order 32-bits of RDX and RAX are cleared.\n",
    "Alias": []
  },
  {
    "Name": "RDPMC",
    "Brief": "Read performance-monitoring counter specified by ECX into EDX:EAX",
    "Description": "\nReads the contents of the performance monitoring counter (PMC) specified in ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the PMC and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the PMC being read, unimplemented bits returned to EDX:EAX will have value zero.\n\nThe width of PMCs on processors supporting architectural performance monitoring (CPUID.0AH:EAX[7:0] ≠ 0) are reported by CPUID.0AH:EAX[23:16]. On processors that do not support architectural performance monitoring (CPUID.0AH:EAX[7:0]=0), the width of general-purpose performance PMCs is 40 bits, while the widths of special-purpose PMCs are implementation specific.\n\nUse of ECX to specify a PMC depends on whether the processor supports architectural performance monitoring:\n\n- If the processor does not support architectural performance monitoring, ECX[30:0] specifies the index of the PMC to be read. Setting ECX[31] selects \"fast\" read mode if supported.\n\n- If the processor supports architectural performance monitoring, ECX[31:16] specifies type of PMC while ECX[15:0] specifies the index of the PMC to be read within that type:\n  * General-purpose counters use type 0\n  * Fixed-function counters use type 4000H\n  * Performance metrics use type 2000H\n\nSpecifying an unsupported PMC encoding will cause a general protection exception #GP(0).\n\nWhen in protected or virtual 8086 mode, the Performance-monitoring Counters Enabled (PCE) flag in register CR4 restricts the use of the RDPMC instruction. When the PCE flag is set, the RDPMC instruction can be executed at any privilege level; when the flag is clear, the instruction can only be executed at privilege level 0.\n\nThe RDPMC instruction is not a serializing instruction. If an exact event count is desired, software must insert a serializing instruction (such as the CPUID instruction) before and/or after the RDPMC instruction.\n",
    "Alias": []
  },
  {
    "Name": "RDRAND",
    "Brief": "Read a hardware-generated random number",
    "Description": "\nLoads a hardware generated random value and store it in the destination register. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation.\n\nSoftware must check the state of CF=1 for determining if a valid random value has been returned, otherwise it is expected to loop and retry execution of RDRAND (see Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1, Section 7.3.17, \"Random Number Generator Instructions\").\n\nThis instruction is available at all privilege levels. In 64-bit mode, the instruction's default operand size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands.\n",
    "Alias": []
  },
  {
    "Name": "RDSEED",
    "Brief": "Read a hardware generated random value compliant to NIST SP800-90B & C",
    "Description": "\nLoads a hardware generated random value and store it in the destination register. The random value is generated from an Enhanced NRBG (Non Deterministic Random Bit Generator) that is compliant to NIST SP800-90B and NIST SP800-90C in the XOR construction mode. The size of the random value is determined by the destination register size and operating mode.\n\nThe Carry Flag indicates whether a random value is available at the time the instruction is executed:\n- CF=1 indicates that the data in the destination is valid\n- CF=0 means the destination operand will be returned as zeros for the specified width\n\nSoftware must check the state of CF=1 for determining if a valid random seed value has been returned, otherwise it is expected to loop and retry execution of RDSEED.\n\nThe RDSEED instruction is available at all privilege levels and executes normally inside or outside a transaction region. In 64-bit mode, the instruction's default operand size is 32 bits, with REX prefixes allowing access to additional registers and 64-bit operands.\n",
    "Alias": []
  },
  {
    "Name": "RDSSPD",
    "Brief": "Copy low 32 bits of shadow stack pointer (SSP) to r32",
    "Description": "\nCopies the current shadow stack pointer (SSP) register to the register destination. This opcode is a NOP when CET shadow stacks are not enabled and on processors that do not support CET.\n\nWhen executed at privilege level 3 (user mode), the instruction copies the SSP to the destination register only if Control Register 4 (CR4) CET is enabled and the IA32_U_CET.SH_STK_EN flag is set.\n\nWhen executed at privilege levels 0-2 (kernel/system modes), the instruction copies the SSP to the destination register only if CR4 CET is enabled and the IA32_S_CET.SH_STK_EN flag is set.\n\nThe RDSSPD instruction copies the low 32 bits of the SSP, while the RDSSPQ instruction copies the full 64-bit SSP value.\n",
    "Alias": []
  },
  {
    "Name": "RDSSPQ",
    "Brief": "Copy shadow stack pointer (SSP) to r64",
    "Description": "\nCopies the current shadow stack pointer (SSP) register to the register destination. This opcode is a NOP when CET shadow stacks are not enabled and on processors that do not support CET.\n\nWhen executed at privilege level 3 (user mode), the instruction copies the SSP to the destination register only if Control Register 4 (CR4) CET is enabled and the IA32_U_CET.SH_STK_EN flag is set.\n\nWhen executed at privilege levels 0-2 (kernel/system modes), the instruction copies the SSP to the destination register only if CR4 CET is enabled and the IA32_S_CET.SH_STK_EN flag is set.\n\nThe RDSSPD instruction copies the low 32 bits of the SSP, while the RDSSPQ instruction copies the full 64-bit SSP value.\n",
    "Alias": []
  },
  {
    "Name": "RDTSC",
    "Brief": "Read Time-Stamp Counter into EDX:EAX",
    "Description": "\nReads the current value of the processor's time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)\n\nThe processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset.\n\nThe time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction:\n- When the flag is clear, the RDTSC instruction can be executed at any privilege level\n- When the flag is set, the instruction can only be executed at privilege level 0\n\nThe RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions have been executed before reading the counter. Software can use LFENCE or MFENCE instructions to ensure proper ordering of execution.\n\nThis instruction was introduced by the Pentium processor and can be used to measure processor clock cycles or create high-resolution timing measurements.\n",
    "Alias": []
  },
  {
    "Name": "RDTSCP",
    "Brief": "Read Time-Stamp Counter and Processor ID",
    "Description": "\nReads the current value of the processor's time-stamp counter (a 64-bit MSR) into the EDX:EAX registers and also reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the ECX register. The EDX register is loaded with the high-order 32 bits of the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of the IA32_TSC MSR; and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR. On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.\n\nThe processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset.\n\nThe time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSCP instruction as follows. When the flag is clear, the RDTSCP instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0.\n\nThe RDTSCP instruction is not a serializing instruction, but it does wait until all previous instructions have executed and all previous loads are globally visible. However, it does not wait for previous stores to be globally visible, and subsequent instructions may begin execution before the read operation is performed.\n\nIf software requires additional ordering:\n- Execute MFENCE immediately before RDTSCP to ensure all previous stores are globally visible\n- Execute LFENCE immediately after RDTSCP to prevent execution of subsequent instructions before the read operation is complete\n",
    "Alias": []
  },
  {
    "Name": "REP",
    "Brief": "Repeat string instruction the specified number of times",
    "Description": "\nRepeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP, REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) are prefixes that can be added to string instructions.\n\nThe REP prefix can be added to INS, OUTS, MOVS, LODS, and STOS instructions, while REPE, REPNE, REPZ, and REPNZ prefixes can be added to CMPS and SCAS instructions.\n\nTermination conditions depend on the prefix:\n- REP: Stops when count register reaches zero\n- REPE/REPZ: Stops when count register reaches zero OR zero flag (ZF) is zero\n- REPNE/REPNZ: Stops when count register reaches zero OR zero flag (ZF) is one\n\nIn 64-bit mode, the default count register is RCX. A repeating string operation can be suspended by an exception or interrupt, with the processor preserving the state of registers to allow resumption.\n\nThe F3H prefix is defined for string and input/output instructions, and is also a mandatory prefix for POPCNT, LZCNT, and ADOX instructions.\n",
    "Alias": []
  },
  {
    "Name": "REPE/REPZ",
    "Brief": "Repeat string instruction while equal/zero",
    "Description": "\nRepeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP, REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) are prefixes that can be added to string instructions.\n\nThe REP prefix can be added to INS, OUTS, MOVS, LODS, and STOS instructions, while REPE, REPNE, REPZ, and REPNZ prefixes can be added to CMPS and SCAS instructions.\n\nTermination conditions depend on the prefix:\n- REP: Stops when count register reaches zero\n- REPE/REPZ: Stops when count register reaches zero OR zero flag (ZF) is zero\n- REPNE/REPNZ: Stops when count register reaches zero OR zero flag (ZF) is one\n\nIn 64-bit mode, the default count register is RCX. A repeating string operation can be suspended by an exception or interrupt, with the processor preserving the state of registers to allow resumption.\n\nThe F3H prefix is defined for string and input/output instructions, and is also a mandatory prefix for POPCNT, LZCNT, and ADOX instructions.\n",
    "Alias": []
  },
  {
    "Name": "REPNE/REPNZ",
    "Brief": "Repeat string instruction while not equal/not zero",
    "Description": "\nRepeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP, REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) are prefixes that can be added to string instructions.\n\nThe REP prefix can be added to INS, OUTS, MOVS, LODS, and STOS instructions, while REPE, REPNE, REPZ, and REPNZ prefixes can be added to CMPS and SCAS instructions.\n\nTermination conditions depend on the prefix:\n- REP: Stops when count register reaches zero\n- REPE/REPZ: Stops when count register reaches zero OR zero flag (ZF) is zero\n- REPNE/REPNZ: Stops when count register reaches zero OR zero flag (ZF) is one\n\nIn 64-bit mode, the default count register is RCX. A repeating string operation can be suspended by an exception or interrupt, with the processor preserving the state of registers to allow resumption.\n\nThe F3H prefix is defined for string and input/output instructions, and is also a mandatory prefix for POPCNT, LZCNT, and ADOX instructions.\n",
    "Alias": []
  },
  {
    "Name": "RET",
    "Brief": "Return from procedure",
    "Description": "\nTransfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.\n\nThe RET instruction can be used to execute three different types of returns:\n1. Near return - A return to a calling procedure within the current code segment\n2. Far return - A return to a calling procedure located in a different segment\n3. Inter-privilege-level far return - A far return to a different privilege level (only in protected mode)\n\nWhen executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack into the EIP/RIP register.\n\nWhen executing a far return, the processor pops the return instruction pointer into EIP/RIP and then pops the segment selector into the CS register.\n\nThe optional source operand specifies the number of stack bytes to be released after the return address is popped, which can be used to clean up parameters from the stack.\n\nIn 64-bit mode, the default operation size of this instruction is the stack-address size (64 bits) for near returns, and 32 bits for far returns.\n\nInstruction ordering is carefully controlled, with instructions following a far return being fetched but not speculatively executed until all prior instructions have completed.\n",
    "Alias": []
  },
  {
    "Name": "RORX",
    "Brief": "Rotate bits right without affecting arithmetic flags",
    "Description": "\nRotates the bits of second operand right by the count value specified in imm8 without affecting arithmetic flags. The RORX instruction does not read or write the arithmetic flags.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nThe instruction performs the following operation:\n- For 32-bit operands: Rotate right by (imm8 AND 0x1F)\n- For 64-bit operands: Rotate right by (imm8 AND 0x3F)\n\nThe rotation is done by shifting the bits right and wrapping the shifted-out bits to the left side of the result.\n",
    "Alias": []
  },
  {
    "Name": "ROUNDPD",
    "Brief": "Round packed double precision floating-point values",
    "Description": "\nRound the 2 double precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a double precision floating-point value.\n\nThe immediate operand specifies control fields for the rounding operation:\n- Bit 3 controls precision exception handling\n- Bit 2 selects the source of rounding mode control\n- Bits 1:0 specify a non-sticky rounding-mode value\n\nRounding modes include:\n- Round to nearest (even)\n- Round down (toward -∞)\n- Round up (toward +∞)\n- Round toward zero (truncate)\n\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN, it will be converted to a QNaN. If DAZ is set to '1', denormals will be converted to zero before rounding.\n\nAvailable in different variants:\n- 128-bit Legacy SSE version\n- VEX.128 encoded version\n- VEX.256 encoded version\n",
    "Alias": []
  },
  {
    "Name": "ROUNDPS",
    "Brief": "Round packed single precision floating-point values",
    "Description": "\nRound the 4 single precision floating-point values in the source operand using the rounding mode specified in the immediate operand and place the results in the destination operand. The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single precision floating-point value.\n\nThe immediate operand specifies control fields for the rounding operation, with three bit fields defined:\n- Bit 3 controls processor behavior for a precision exception\n- Bit 2 selects the source of rounding mode control\n- Bits 1:0 specify a non-sticky rounding-mode value\n\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN, it will be converted to a QNaN. If DAZ is set to '1', then denormals will be converted to zero before rounding.\n\nVersions:\n- 128-bit Legacy SSE: Source can be an XMM register or 128-bit memory location\n- VEX.128: Source is a 128-bit memory location, destination is an XMM register\n- VEX.256: Source is a YMM register or 256-bit memory location, destination is a YMM register\n\nNote: In VEX-encoded versions, VEX.vvvv must be 1111b, otherwise an #UD exception will be raised.\n",
    "Alias": []
  },
  {
    "Name": "ROUNDSD",
    "Brief": "Round Scalar Double Precision Floating-Point Values",
    "Description": "\nRound the double precision floating-point value in the lower qword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a double precision floating-point input to an integer value and returns the integer result as a double precision floating-point value in the lowest position. The upper double precision floating-point value in the destination is retained.\n\nThe immediate operand specifies control fields for the rounding operation, three bit fields are defined. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value.\n\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before rounding.\n\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "ROUNDSS",
    "Brief": "Round scalar single precision floating-point values",
    "Description": "\nRound the single precision floating-point value in the lowest dword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a single precision floating-point input to an integer value and returns the result as a single precision floating-point value in the lowest position. The upper three single precision floating-point values in the destination are retained.\n\nThe immediate operand specifies control fields for the rounding operation, with three bit fields defined. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control, and bits 1:0 specify a non-sticky rounding-mode value.\n\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before rounding.\n\nFor the 128-bit Legacy SSE version, the first source operand and the destination operand are the same, and bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged. In the VEX.128 encoded version, bits (MAXVL-1:128) of the destination YMM register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "RSM",
    "Brief": "Resume From System Management Mode",
    "Description": "\nReturns program control from system management mode (SMM) to the application program or operating-system procedure that was interrupted when the processor received an SMM interrupt. The processor's state is restored from the dump created upon entering SMM. If the processor detects invalid state information during state restoration, it enters the shutdown state.\n\nThe following invalid information can cause a shutdown:\n- Any reserved bit of CR4 is set to 1\n- Any illegal combination of bits in CR0, such as (PG=1 and PE=0) or (NW=1 and CD=0)\n- (Intel Pentium and Intel486™ processors only) The value stored in the state dump base field is not a 32-KByte aligned address\n\nThe contents of the model-specific registers are not affected by a return from SMM.\n\nThe SMM state map used by RSM supports resuming processor context for non-64-bit modes and 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "RSQRTPS",
    "Brief": "Compute approximate reciprocals of square roots of packed single precision floating-point values",
    "Description": "\nPerforms a SIMD computation of the approximate reciprocals of the square roots of the four packed single precision floating-point values in the source operand and stores the packed single precision floating-point results in the destination operand.\n\nThe relative error for this approximation is: |Relative Error| ≤ 1.5 ∗ 2^-12\n\nThe RSQRTPS instruction is not affected by the rounding control bits in the MXCSR register. Special cases include:\n- For a 0.0 source value, an ∞ of the sign of the source value is returned\n- A denormal source value is treated as a 0.0 (of the same sign)\n- For a negative value (other than −0.0), a floating-point indefinite is returned\n- For an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned\n\nThe instruction supports different versions:\n- 128-bit Legacy SSE: The destination is not distinct from the first source XMM register\n- VEX.128 encoded: The destination is an XMM register with upper bits zeroed\n- VEX.256 encoded: The source can be a YMM register or 256-bit memory location, and the destination is a YMM register\n\nNote: In VEX-encoded versions, VEX.vvvv must be 1111b, otherwise an undefined instruction (#UD) will occur.\n",
    "Alias": []
  },
  {
    "Name": "RSQRTSS",
    "Brief": "Compute approximate reciprocal of square root of scalar single precision floating-point value",
    "Description": "\nComputes an approximate reciprocal of the square root of the low single precision floating-point value in the source operand and stores the single precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged.\n\nThe relative error for this approximation is: |Relative Error| ≤ 1.5 * 2^-12\n\nThe RSQRTSS instruction is not affected by the rounding control bits in the MXCSR register. \n\nSpecial cases:\n- When a source value is 0.0, an ∞ of the sign of the source value is returned\n- A denormal source value is treated as a 0.0 (of the same sign)\n- When a source value is a negative value (other than −0.0), a floating-point indefinite is returned\n- When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n",
    "Alias": []
  },
  {
    "Name": "RSTORSSP",
    "Brief": "Restore Saved Shadow Stack Pointer",
    "Description": "\nRestores SSP (Shadow Stack Pointer) from the shadow-stack-restore token pointed to by m64. If the SSP restore was successful, the instruction replaces the shadow-stack-restore token with a previous-ssp token. \n\nThe instruction sets the CF flag to indicate whether the SSP address recorded in the shadow-stack-restore token that was processed was 4 byte aligned, i.e., whether an alignment hole was created when the restore-shadow-stack token was pushed on this shadow stack.\n\nAfter RSTORSSP, if a restore-shadow-stack token needs to be saved on the previous shadow stack, use the SAVEPREVSSP instruction. \n\nIf pushing a restore-shadow-stack token on the previous shadow stack is not required, the previous-ssp token can be popped using the INCSSPQ instruction. If the CF flag was set to indicate presence of an alignment hole, an additional INCSSPD instruction is needed to advance the SSP past the alignment hole.\n\nThe instruction is part of the Control-flow Enforcement Technology (CET) and is subject to various checks and conditions related to the current privilege level (CPL) and CET configuration.\n",
    "Alias": []
  },
  {
    "Name": "SAHF",
    "Brief": "Store AH Into Flags",
    "Description": "\nLoads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits (1, 3, and 5) in the EFLAGS register remain unchanged.\n\nThis instruction executes as described in compatibility mode and legacy mode. In 64-bit mode, it is only valid if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.\n\nWhen executed in 64-bit mode:\n- If CPUID.80000001H.ECX[0] = 1, the flags are loaded from AH\n- If CPUID.80000001H.ECX[0] = 0, an Undefined Instruction (#UD) exception is raised\n\nThe SF (Sign Flag), ZF (Zero Flag), AF (Auxiliary Carry Flag), PF (Parity Flag), and CF (Carry Flag) are directly loaded from the corresponding bits in the AH register.\n",
    "Alias": []
  },
  {
    "Name": "SAL",
    "Brief": "Shift arithmetic left (multiply by 2)",
    "Description": "\nShifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded.\n\nThe destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits with a 64-bit operand). The count range is limited to 0 to 31 (or 63 with a 64-bit operand).\n\nSAL/SHL (Shift Arithmetic/Logical Left) instructions shift bits to the left, with the most significant bit shifted into the CF flag and the least significant bit cleared.\n\nSAR/SHR (Shift Arithmetic/Logical Right) instructions shift bits to the right:\n- SAR preserves the sign bit (most significant bit)\n- SHR clears the most significant bit\n\nThese instructions can be used to perform signed (SAR) or unsigned (SHR) division by powers of 2. For example, SAR shifting a signed integer 1 bit to the right divides the value by 2.\n\nNote that SAR division differs from IDIV:\n- IDIV rounds toward zero\n- SAR rounds toward negative infinity\n\nThe OF flag is affected only on 1-bit shifts:\n- For left shifts, OF is set based on the top two bits of the original operand\n- For SAR, OF is always cleared\n- For SHR, OF is set to the most-significant bit of the original operand\n",
    "Alias": []
  },
  {
    "Name": "SAR",
    "Brief": "Shift arithmetic right (signed divide by 2)",
    "Description": "\nShifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded.\n\nThe destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits with a 64-bit operand). The count range is limited to 0 to 31 (or 63 with a 64-bit operand).\n\nSAL/SHL (Shift Arithmetic/Logical Left) instructions shift bits to the left, with the most significant bit shifted into the CF flag and the least significant bit cleared.\n\nSAR/SHR (Shift Arithmetic/Logical Right) instructions shift bits to the right:\n- SAR preserves the sign bit (most significant bit)\n- SHR clears the most significant bit\n\nThese instructions can be used to perform signed (SAR) or unsigned (SHR) division by powers of 2. For example, SAR shifting a signed integer 1 bit to the right divides the value by 2.\n\nNote that SAR division differs from IDIV:\n- IDIV rounds toward zero\n- SAR rounds toward negative infinity\n\nThe OF flag is affected only on 1-bit shifts:\n- For left shifts, OF is set based on the top two bits of the original operand\n- For SAR, OF is always cleared\n- For SHR, OF is set to the most-significant bit of the original operand\n",
    "Alias": []
  },
  {
    "Name": "SHL",
    "Brief": "Shift logical left (multiply by 2)",
    "Description": "\nShifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded.\n\nThe destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits with a 64-bit operand). The count range is limited to 0 to 31 (or 63 with a 64-bit operand).\n\nSAL/SHL (Shift Arithmetic/Logical Left) instructions shift bits to the left, with the most significant bit shifted into the CF flag and the least significant bit cleared.\n\nSAR/SHR (Shift Arithmetic/Logical Right) instructions shift bits to the right:\n- SAR preserves the sign bit (most significant bit)\n- SHR clears the most significant bit\n\nThese instructions can be used to perform signed (SAR) or unsigned (SHR) division by powers of 2. For example, SAR shifting a signed integer 1 bit to the right divides the value by 2.\n\nNote that SAR division differs from IDIV:\n- IDIV rounds toward zero\n- SAR rounds toward negative infinity\n\nThe OF flag is affected only on 1-bit shifts:\n- For left shifts, OF is set based on the top two bits of the original operand\n- For SAR, OF is always cleared\n- For SHR, OF is set to the most-significant bit of the original operand\n",
    "Alias": []
  },
  {
    "Name": "SHR",
    "Brief": "Shift logical right (unsigned divide by 2)",
    "Description": "\nShifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded.\n\nThe destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits with a 64-bit operand). The count range is limited to 0 to 31 (or 63 with a 64-bit operand).\n\nSAL/SHL (Shift Arithmetic/Logical Left) instructions shift bits to the left, with the most significant bit shifted into the CF flag and the least significant bit cleared.\n\nSAR/SHR (Shift Arithmetic/Logical Right) instructions shift bits to the right:\n- SAR preserves the sign bit (most significant bit)\n- SHR clears the most significant bit\n\nThese instructions can be used to perform signed (SAR) or unsigned (SHR) division by powers of 2. For example, SAR shifting a signed integer 1 bit to the right divides the value by 2.\n\nNote that SAR division differs from IDIV:\n- IDIV rounds toward zero\n- SAR rounds toward negative infinity\n\nThe OF flag is affected only on 1-bit shifts:\n- For left shifts, OF is set based on the top two bits of the original operand\n- For SAR, OF is always cleared\n- For SHR, OF is set to the most-significant bit of the original operand\n",
    "Alias": []
  },
  {
    "Name": "SARX",
    "Brief": "Shift arithmetic right without affecting flags",
    "Description": "\nShifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).\n\nThe shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations):\n- SARX keeps and propagates the most significant bit (sign bit) while shifting\n- SHRX shifts bits without preserving the sign bit\n\nThe logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode, 64-bit operand size requires VEX.W1.\n\nIf the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.\n\nThese instructions do not update flags.\n",
    "Alias": []
  },
  {
    "Name": "SHLX",
    "Brief": "Shift logical left without affecting flags",
    "Description": "\nShifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).\n\nThe shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations):\n- SARX keeps and propagates the most significant bit (sign bit) while shifting\n- SHRX shifts bits without preserving the sign bit\n\nThe logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode, 64-bit operand size requires VEX.W1.\n\nIf the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.\n\nThese instructions do not update flags.\n",
    "Alias": []
  },
  {
    "Name": "SHRX",
    "Brief": "Shift logical right without affecting flags",
    "Description": "\nShifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).\n\nThe shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations):\n- SARX keeps and propagates the most significant bit (sign bit) while shifting\n- SHRX shifts bits without preserving the sign bit\n\nThe logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode, 64-bit operand size requires VEX.W1.\n\nIf the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.\n\nThese instructions do not update flags.\n",
    "Alias": []
  },
  {
    "Name": "SAVEPREVSSP",
    "Brief": "Save a restore-shadow-stack token on previous shadow stack",
    "Description": "\nPush a restore-shadow-stack token on the previous shadow stack at the next 8 byte aligned boundary. The previous SSP is obtained from the previous-ssp token at the top of the current shadow stack.\n\nThe instruction involves several checks and operations:\n1. Verifies Control Flow Enforcement Technology (CET) is enabled based on the current privilege level (CPL)\n2. Checks shadow stack pointer (SSP) alignment\n3. Pops the \"previous-ssp\" token from the current shadow stack\n4. Validates the previous SSP token\n5. Saves the previous SSP to the old shadow stack at the next 8-byte aligned address\n\nThe instruction is part of the Control Flow Enforcement Technology (CET) and is used to manage shadow stack pointers, which helps prevent return-oriented programming (ROP) attacks.\n",
    "Alias": []
  },
  {
    "Name": "SBB",
    "Brief": "Subtract with borrow",
    "Description": "\nAdds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location.\n\n(However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction.\n\nWhen an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\n\nThe SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\n\nThe SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction is followed by a SBB instruction.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n",
    "Alias": []
  },
  {
    "Name": "SCAS",
    "Brief": "Compare a byte, word, doubleword, or quadword from memory with AL, AX, EAX, or RAX",
    "Description": "\nIn non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operand form (SCAS mnemonic): allows a memory operand to be specified explicitly.\n2. No-operands form: uses a short form of SCAS, where ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand.\n\nAfter the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register:\n- If DF flag is 0, the (E)DI register is incremented\n- If DF flag is 1, the (E)DI register is decremented\n\nThe register is incremented or decremented by:\n- 1 for byte operations\n- 2 for word operations\n- 4 for doubleword operations\n- 8 for quadword operations\n\nSCAS instructions can be preceded by the REP prefix for block comparisons. In 64-bit mode, the instruction's default address size is 64-bits, with 32-bit address size supported using the 67H prefix.\n",
    "Alias": []
  },
  {
    "Name": "SCASB",
    "Brief": "Compare a byte from memory with AL",
    "Description": "\nIn non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operand form (SCAS mnemonic): allows a memory operand to be specified explicitly.\n2. No-operands form: uses a short form of SCAS, where ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand.\n\nAfter the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register:\n- If DF flag is 0, the (E)DI register is incremented\n- If DF flag is 1, the (E)DI register is decremented\n\nThe register is incremented or decremented by:\n- 1 for byte operations\n- 2 for word operations\n- 4 for doubleword operations\n- 8 for quadword operations\n\nSCAS instructions can be preceded by the REP prefix for block comparisons. In 64-bit mode, the instruction's default address size is 64-bits, with 32-bit address size supported using the 67H prefix.\n",
    "Alias": []
  },
  {
    "Name": "SCASW",
    "Brief": "Compare a word from memory with AX",
    "Description": "\nIn non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operand form (SCAS mnemonic): allows a memory operand to be specified explicitly.\n2. No-operands form: uses a short form of SCAS, where ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand.\n\nAfter the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register:\n- If DF flag is 0, the (E)DI register is incremented\n- If DF flag is 1, the (E)DI register is decremented\n\nThe register is incremented or decremented by:\n- 1 for byte operations\n- 2 for word operations\n- 4 for doubleword operations\n- 8 for quadword operations\n\nSCAS instructions can be preceded by the REP prefix for block comparisons. In 64-bit mode, the instruction's default address size is 64-bits, with 32-bit address size supported using the 67H prefix.\n",
    "Alias": []
  },
  {
    "Name": "SCASD",
    "Brief": "Compare a doubleword from memory with EAX",
    "Description": "\nIn non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operand form (SCAS mnemonic): allows a memory operand to be specified explicitly.\n2. No-operands form: uses a short form of SCAS, where ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand.\n\nAfter the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register:\n- If DF flag is 0, the (E)DI register is incremented\n- If DF flag is 1, the (E)DI register is decremented\n\nThe register is incremented or decremented by:\n- 1 for byte operations\n- 2 for word operations\n- 4 for doubleword operations\n- 8 for quadword operations\n\nSCAS instructions can be preceded by the REP prefix for block comparisons. In 64-bit mode, the instruction's default address size is 64-bits, with 32-bit address size supported using the 67H prefix.\n",
    "Alias": []
  },
  {
    "Name": "SCASQ",
    "Brief": "Compare a quadword from memory with RAX",
    "Description": "\nIn non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operand form (SCAS mnemonic): allows a memory operand to be specified explicitly.\n2. No-operands form: uses a short form of SCAS, where ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand.\n\nAfter the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register:\n- If DF flag is 0, the (E)DI register is incremented\n- If DF flag is 1, the (E)DI register is decremented\n\nThe register is incremented or decremented by:\n- 1 for byte operations\n- 2 for word operations\n- 4 for doubleword operations\n- 8 for quadword operations\n\nSCAS instructions can be preceded by the REP prefix for block comparisons. In 64-bit mode, the instruction's default address size is 64-bits, with 32-bit address size supported using the 67H prefix.\n",
    "Alias": []
  },
  {
    "Name": "SENDUIPI",
    "Brief": "Send user interprocessor interrupt",
    "Description": "\nThe SENDUIPI instruction sends the user interprocessor interrupt (IPI) indicated by its register operand. (The operand always has 64 bits; operand-size overrides such as the prefix 66 are ignored.)\n\nSENDUIPI uses a data structure called the user-interrupt target table (UITT). This table is located at the linear address UITTADDR (in the IA32_UINTR_TT MSR); it comprises UITTSZ+1 16-byte entries, where UITTSZ = IA32_UINT_MISC[31:0]. SENDUIPI uses the UITT entry (UITTE) indexed by the instruction's register operand.\n\nThe instruction involves accessing a User Interrupt Target Table (UITT) entry and a User Posted Interrupt Descriptor (UPID). It performs the following key actions:\n1. Validates the UITT entry and UPID\n2. Sets the posted interrupt request (PIR) bit for the specific vector\n3. If notifications are not suppressed, sets the outstanding notification (ON) bit\n4. Sends a notification interrupt if required\n\nAlthough SENDUIPI may be executed at any privilege level, all of the instruction's memory accesses are performed with supervisor privilege.\n\nSENDUIPI sends a user interrupt by posting a user interrupt with vector V in the UPID referenced by UPIDADDR and then sending, as an ordinary IPI, any notification interrupt specified in that UPID.\n",
    "Alias": []
  },
  {
    "Name": "SERIALIZE",
    "Brief": "Serialize instruction fetch and execution",
    "Description": "\nSerializes instruction execution. Before the next instruction is fetched and executed, the SERIALIZE instruction ensures that all modifications to flags, registers, and memory by previous instructions are completed, draining all buffered writes to memory. This instruction is also a serializing instruction as defined in the section \"Serializing Instructions\" in Chapter 9 of the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A.\n\nSERIALIZE does not modify registers, arithmetic flags, or memory.\n\nThe instruction waits on the fetch and execution of the next instruction until preceding instructions are complete and preceding stores are globally visible.\n",
    "Alias": []
  },
  {
    "Name": "SETSSBSY",
    "Brief": "Mark Shadow Stack Busy",
    "Description": "\nThe SETSSBSY instruction verifies the presence of a non-busy supervisor shadow stack token at the address in the IA32_PL0_SSP MSR and marks it busy. Following successful execution of the instruction, the SSP is set to the value of the IA32_PL0_SSP MSR.\n\nSpecifically, the instruction performs the following checks and actions:\n- Checks if CR4.CET is set\n- Checks if IA32_S_CET.SH_STK_EN is enabled\n- Verifies the current privilege level is 0\n- Checks if the SSP address is 8-byte aligned\n- Attempts to set the busy bit in the shadow stack token using a compare-and-exchange operation\n- Sets the Shadow Stack Pointer (SSP) to the IA32_PL0_SSP value\n\nIf any of these checks fail, the instruction will raise an appropriate exception such as #UD (Undefined Opcode), #GP (General Protection), or #CP (Control Protection).\n",
    "Alias": []
  },
  {
    "Name": "SETcc",
    "Brief": "Set byte to 0 or 1 based on condition flags",
    "Description": "\nSets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.\n\nThe terms \"above\" and \"below\" are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms \"greater\" and \"less\" are associated with the SF and OF flags and refer to the relationship between two signed integer values.\n\nMany of the SETcc instruction opcodes have alternate mnemonics to make code more intelligible. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF.\n\nSome languages represent a logical one as an integer with all bits set. This can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.\n\nIn 64-bit mode, the operand size is fixed at 8 bits, and the REX prefix enables uniform addressing to additional byte registers.\n",
    "Alias": []
  },
  {
    "Name": "SFENCE",
    "Brief": "Store Fence, orders processor execution relative to memory stores",
    "Description": "\nOrders processor execution relative to all memory stores prior to the SFENCE instruction. The processor ensures that every store prior to SFENCE is globally visible before any store after SFENCE becomes globally visible. \n\nThe SFENCE instruction is ordered with respect to:\n- Memory stores\n- Other SFENCE instructions\n- MFENCE instructions\n- Serializing instructions (such as CPUID)\n\nIt is NOT ordered with respect to:\n- Memory loads\n- LFENCE instruction\n\nWeakly ordered memory types can achieve higher processor performance through techniques like out-of-order issue, write-combining, and write-collapsing. The SFENCE instruction provides a performance-efficient way of ensuring store ordering between routines that produce weakly-ordered results and routines that consume this data.\n\nThe instruction's operation is the same in both non-64-bit and 64-bit modes. The processor ignores the r/m field of the ModR/M byte, so SFENCE can be encoded by any opcode of the form 0F AE Fx, where x is in the range 8-F.\n",
    "Alias": []
  },
  {
    "Name": "SGDT",
    "Brief": "Store Global Descriptor Table Register",
    "Description": "\nStores the content of the global descriptor table register (GDTR) in the destination operand. The destination operand specifies a memory location.\n\nIn legacy or compatibility mode, the destination operand is a 6-byte memory location. If the operand-size attribute is 16 or 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.\n\nIn 64-bit mode, the operand size is fixed at 8+2 bytes. The instruction stores an 8-byte base and a 2-byte limit.\n\nSGDT is useful only by operating-system software. However, it can be used in application programs without causing an exception to be generated if CR4.UMIP = 0. See \"LGDT/LIDT—Load Global/Interrupt Descriptor Table Register\" in Chapter 3, Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 2A, for information on loading the GDTR and IDTR.\n\nThe 16-bit form of the SGDT is compatible with the Intel 286 processor if the upper 8 bits are not referenced. The Intel 286 processor fills these bits with 1s; processor generations later than the Intel 286 processor fill these bits with 0s.\n",
    "Alias": []
  },
  {
    "Name": "SHA1MSG1",
    "Brief": "Perform an intermediate calculation for the next four SHA1 message dwords",
    "Description": "\nThe SHA1MSG1 instruction is one of two SHA1 message scheduling instructions. The instruction performs an intermediate calculation for the next four SHA1 message dwords.\n\nThe instruction takes two source operands, breaks them down into 32-bit words, and performs a series of XOR operations to compute intermediate values for the next four SHA1 message dwords. Specifically:\n\n- It extracts words W0-W3 from the first source operand (SRC1)\n- It extracts words W4-W5 from the second source operand (SRC2)\n- It computes the destination dwords by XORing specific words:\n  * DEST[127:96] = W2 XOR W0\n  * DEST[95:64] = W3 XOR W1\n  * DEST[63:32] = W4 XOR W2\n  * DEST[31:0] = W5 XOR W3\n\nThis is part of the message scheduling process used in the SHA-1 cryptographic hash algorithm.\n",
    "Alias": []
  },
  {
    "Name": "SHA1MSG2",
    "Brief": "Perform a final calculation for the next four SHA1 message dwords",
    "Description": "\nThe SHA1MSG2 instruction is one of two SHA1 message scheduling instructions. The instruction performs the final calculation to derive the next four SHA1 message dwords.\n\nThe instruction works by:\n1. Loading three dwords from the source operand (SRC2)\n2. XORing specific dwords from the source and destination operands\n3. Performing a left rotate by 1 bit\n4. Storing the resulting four dwords in the destination operand\n\nThe calculation follows a specific pattern for message scheduling in the SHA-1 hashing algorithm, helping to prepare message words for the compression function.\n",
    "Alias": []
  },
  {
    "Name": "SHA1NEXTE",
    "Brief": "Calculate SHA1 State Variable E After Four Rounds",
    "Description": "\nThe SHA1NEXTE calculates the SHA1 state variable E after four rounds of operation from the current SHA1 state variable A in the destination operand. The calculated value of the SHA1 state variable E is added to the source operand, which contains the scheduled dwords.\n\nThe instruction performs the following operation:\n1. Rotate the first 32 bits of the first source operand left by 30 bits\n2. Add the rotated value to the first 32 bits of the second source operand\n3. Store the result in the first 32 bits of the destination operand\n4. Copy the remaining 96 bits from the second source operand to the destination operand\n\nThis instruction is part of the SHA instruction set and is used in the implementation of the SHA-1 cryptographic hash algorithm.\n",
    "Alias": []
  },
  {
    "Name": "SHA1RNDS4",
    "Brief": "Perform four rounds of SHA1 operation",
    "Description": "\nThe SHA1RNDS4 instruction performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D) from the first operand (which is a source operand and the destination operand) and some pre-computed sum of the next 4 round message dwords, and state variable E from the second operand (a source operand). The updated SHA1 state (A,B,C,D) after four rounds of processing is stored in the destination operand.\n\nThe instruction uses an 8-bit immediate value to select different logic functions and round constants:\n- When imm8[1:0] = 0, it uses f0() function and K0 constant\n- When imm8[1:0] = 1, it uses f1() function and K1 constant\n- When imm8[1:0] = 2, it uses f2() function and K2 constant\n- When imm8[1:0] = 3, it uses f3() function and K3 constant\n\nThe operation involves performing four rounds of SHA1 processing, which includes rotating bits, applying specific logic functions, and combining state variables with message words and constants.\n",
    "Alias": []
  },
  {
    "Name": "SHA256MSG1",
    "Brief": "Perform an intermediate calculation for the next four SHA256 message dwords",
    "Description": "\nThe SHA256MSG1 instruction is one of two SHA256 message scheduling instructions. The instruction performs an intermediate calculation for the next four SHA256 message dwords.\n\nThe instruction works on 128-bit XMM registers, taking two source operands. It performs the following steps:\n1. Extract the 32-bit words (W0-W4) from the source operands\n2. Apply the σ₀ (sigma zero) function to each subsequent word\n3. Add the transformed words to create the next set of message schedule words\n4. Store the result in the destination XMM register\n\nThis is part of the SHA-256 message scheduling algorithm used in cryptographic hash computations.\n",
    "Alias": []
  },
  {
    "Name": "SHA256MSG2",
    "Brief": "Perform a final calculation for the next four SHA256 message dwords",
    "Description": "\nThe SHA256MSG2 instruction is one of two SHA2 message scheduling instructions. The instruction performs the final calculation for the next four SHA256 message dwords.\n\nThe instruction takes two 128-bit XMM registers: the first source and destination register (xmm1) and the second source register (xmm2/m128). It calculates the next four message dwords by performing specific message scheduling operations, specifically applying the σ1 (sigma1) function to the previous message dwords and adding them to the corresponding source dwords.\n\nThe operation involves:\n1. Extracting specific 32-bit words from the source registers\n2. Applying the σ1 message scheduling function to prepare the next set of message dwords\n3. Adding the transformed words to the corresponding source words\n4. Storing the resulting four dwords back into the destination register\n\nThis instruction is part of the SHA extensions and is used in the SHA-256 cryptographic hash algorithm's message preparation stage.\n",
    "Alias": []
  },
  {
    "Name": "SHA256RNDS2",
    "Brief": "Perform 2 rounds of SHA256 operation",
    "Description": "\nThe SHA256RNDS2 instruction performs 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from the first operand, an initial SHA256 state (A,B,E,F) from the second operand, and a pre-computed sum of the next 2 round message dwords and the corresponding round constants from the implicit operand xmm0.\n\nNote that only the two lower dwords of XMM0 are used by the instruction.\n\nThe updated SHA256 state (A,B,E,F) is written to the first operand, and the second operand can be used as the updated state (C,D,G,H) in later rounds.\n\nThe instruction uses several SHA256 specific operations:\n- Ch (Choose) function\n- Σ0 (Sigma 0) function\n- Σ1 (Sigma 1) function\n- Maj (Majority) function\n\nThese operations are part of the SHA256 round computation, which involves complex bit manipulation and rotation operations on the input state variables.\n",
    "Alias": []
  },
  {
    "Name": "SHLD",
    "Brief": "Double Precision Shift Left",
    "Description": "\nThe SHLD instruction is used for multi-precision shifts of 64 bits or more.\n\nThe instruction shifts the first operand (destination operand) to the left the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting with bit 0 of the destination operand).\n\nThe destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an immediate byte or in the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode; only bits 0 through 4 of the count are used. This masks the count to a value between 0 and 31. If a count is greater than the operand size, the result is undefined.\n\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits).\n",
    "Alias": []
  },
  {
    "Name": "SHRD",
    "Brief": "Double Precision Shift Right",
    "Description": "\nThe SHRD instruction is useful for multi-precision shifts of 64 bits or more.\n\nThe instruction shifts the first operand (destination operand) to the right the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with the most significant bit of the destination operand).\n\nThe destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an immediate byte or the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode, the width of the count mask is 5 bits. Only bits 0 through 4 of the count register are used (masking the count to a value between 0 and 31). If the count is greater than the operand size, the result is undefined.\n\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits).\n",
    "Alias": []
  },
  {
    "Name": "SHUFPD",
    "Brief": "Packed Interleave Shuffle of Pairs of Double Precision Floating-Point Values",
    "Description": "\nSelects a double precision floating-point value of an input pair using a bit control and moves it to a designated element of the destination operand. The low-to-high order of double precision elements of the destination operand is interleaved between the first source operand and the second source operand at the granularity of input pair of 128 bits.\n\nEach bit in the imm8 byte, starting from bit 0, is the select control of the corresponding element of the destination to receive the shuffled result of an input pair.\n\nEVEX encoded versions:\n- The first source operand is a ZMM/YMM/XMM register\n- The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location\n- The destination operand is a ZMM/YMM/XMM register updated according to the writemask\n- The select controls are the lower 8/4/2 bits of the imm8 byte\n\nVEX.256 encoded version:\n- First source operand is a YMM register\n- Second source operand can be a YMM register or a 256-bit memory location\n- Destination operand is a YMM register\n- Select controls are bits 3:0 of the imm8 byte, imm8[7:4] are ignored\n\nVEX.128 and Legacy SSE versions:\n- First source operand is an XMM register\n- Second source operand can be an XMM register or a 128-bit memory location\n- Select controls are bits 1:0 of the imm8 byte, imm8[7:2] are ignored\n",
    "Alias": []
  },
  {
    "Name": "VSHUFPD",
    "Brief": "Packed Interleave Shuffle of Pairs of Double Precision Floating-Point Values with Vector Extensions",
    "Description": "\nSelects a double precision floating-point value of an input pair using a bit control and moves it to a designated element of the destination operand. The low-to-high order of double precision elements of the destination operand is interleaved between the first source operand and the second source operand at the granularity of input pair of 128 bits.\n\nEach bit in the imm8 byte, starting from bit 0, is the select control of the corresponding element of the destination to receive the shuffled result of an input pair.\n\nEVEX encoded versions:\n- The first source operand is a ZMM/YMM/XMM register\n- The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location\n- The destination operand is a ZMM/YMM/XMM register updated according to the writemask\n- The select controls are the lower 8/4/2 bits of the imm8 byte\n\nVEX.256 encoded version:\n- First source operand is a YMM register\n- Second source operand can be a YMM register or a 256-bit memory location\n- Destination operand is a YMM register\n- Select controls are bits 3:0 of the imm8 byte, imm8[7:4] are ignored\n\nVEX.128 and Legacy SSE versions:\n- First source operand is an XMM register\n- Second source operand can be an XMM register or a 128-bit memory location\n- Select controls are bits 1:0 of the imm8 byte, imm8[7:2] are ignored\n",
    "Alias": []
  },
  {
    "Name": "SHUFPS",
    "Brief": "Packed Interleave Shuffle of Quadruplets of Single Precision Floating-Point Values",
    "Description": "\nSelects a single precision floating-point value of an input quadruplet using a two-bit control and moves it to a designated element of the destination operand. Each 64-bit element-pair of a 128-bit lane of the destination operand is interleaved between the corresponding lane of the first source operand and the second source operand at the granularity of 128 bits.\n\nEach two bits in the imm8 byte, starting from bit 0, is the select control of the corresponding element of a 128-bit lane of the destination to receive the shuffled result of an input quadruplet. The two lower elements of a 128-bit lane in the destination receive shuffle results from the quadruple of the first source operand. The next two elements of the destination receive shuffle results from the quadruple of the second source operand.\n\nEVEX encoded versions support:\n- First source operand as a ZMM/YMM/XMM register\n- Second source operand as a ZMM/YMM/XMM register, memory location, or broadcasted from a 32-bit memory location\n- Destination operand as a ZMM/YMM/XMM register with optional writemask\n\nVEX.256 version operates on YMM registers with 256-bit vectors.\nVEX.128 version operates on XMM registers with 128-bit vectors.\nLegacy SSE version operates in-place on the first source XMM register.\n",
    "Alias": []
  },
  {
    "Name": "VSHUFPS",
    "Brief": "Vector Packed Interleave Shuffle of Quadruplets of Single Precision Floating-Point Values",
    "Description": "\nSelects a single precision floating-point value of an input quadruplet using a two-bit control and moves it to a designated element of the destination operand. Each 64-bit element-pair of a 128-bit lane of the destination operand is interleaved between the corresponding lane of the first source operand and the second source operand at the granularity of 128 bits.\n\nEach two bits in the imm8 byte, starting from bit 0, is the select control of the corresponding element of a 128-bit lane of the destination to receive the shuffled result of an input quadruplet. The two lower elements of a 128-bit lane in the destination receive shuffle results from the quadruple of the first source operand. The next two elements of the destination receive shuffle results from the quadruple of the second source operand.\n\nEVEX encoded versions support:\n- First source operand as a ZMM/YMM/XMM register\n- Second source operand as a ZMM/YMM/XMM register, memory location, or broadcasted from a 32-bit memory location\n- Destination operand as a ZMM/YMM/XMM register with optional writemask\n\nVEX.256 version operates on YMM registers with 256-bit vectors.\nVEX.128 version operates on XMM registers with 128-bit vectors.\nLegacy SSE version operates in-place on the first source XMM register.\n",
    "Alias": []
  },
  {
    "Name": "SIDT",
    "Brief": "Store Interrupt Descriptor Table Register",
    "Description": "\nStores the content of the interrupt descriptor table register (IDTR) in the destination operand. The destination operand specifies a 6-byte memory location.\n\nIn non-64-bit modes, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.\n\nIn 64-bit mode, the operand size is fixed at 8+2 bytes. The instruction stores 8-byte base and 2-byte limit values.\n\nSIDT is only useful in operating-system software; however, it can be used in application programs without causing an exception to be generated if CR4.UMIP = 0. See \"LGDT/LIDT—Load Global/Interrupt Descriptor Table Register\" in Chapter 3, Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 2A, for information on loading the GDTR and IDTR.\n\nThe 16-bit form of SIDT is compatible with the Intel 286 processor if the upper 8 bits are not referenced. The Intel 286 processor fills these bits with 1s; processor generations later than the Intel 286 processor fill these bits with 0s.\n",
    "Alias": []
  },
  {
    "Name": "SLDT",
    "Brief": "Store Local Descriptor Table Register segment selector",
    "Description": "\nStores the segment selector from the local descriptor table register (LDTR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the segment descriptor (located in the GDT) for the current LDT.\n\nThis instruction can only be executed in protected mode.\n\nOutside IA-32e mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared for the Pentium 4, Intel Xeon, and P6 family processors. They are undefined for Pentium, Intel486, and Intel386 processors.\n\nWhen the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). The behavior of SLDT with a 64-bit register is to zero-extend the 16-bit selector and store it in the register. If the destination is memory and operand size is 64, SLDT will write the 16-bit selector to memory as a 16-bit quantity, regardless of the operand size.\n",
    "Alias": []
  },
  {
    "Name": "SMSW",
    "Brief": "Store machine status word",
    "Description": "\nStores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The destination operand can be a general-purpose register or a memory location.\n\nIn non-64-bit modes, when the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are copied into the low-order 16 bits of the register and the high-order 16 bits are undefined. When the destination operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity, regardless of the operand size.\n\nIn 64-bit mode, the behavior of the SMSW instruction is defined by the following examples:\n- SMSW r16 operand size 16, store CR0[15:0] in r16\n- SMSW r32 operand size 32, zero-extend CR0[31:0], and store in r32\n- SMSW r64 operand size 64, zero-extend CR0[63:0], and store in r64\n- SMSW m16 operand size 16, store CR0[15:0] in m16\n- SMSW m16 operand size 32, store CR0[15:0] in m16 (not m32)\n- SMSW m16 operands size 64, store CR0[15:0] in m16 (not m64)\n\nSMSW is only useful in operating-system software. However, it is not a privileged instruction and can be used in application programs if CR4.UMIP = 0. It is provided for compatibility with the Intel 286 processor. Programs and procedures intended to run on IA-32 and Intel 64 processors beginning with the Intel386 processors should use the MOV CR instruction to load the machine status word.\n",
    "Alias": []
  },
  {
    "Name": "SQRTPD",
    "Brief": "Compute Square Roots of Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms a SIMD computation of the square roots of the two, four or eight packed double precision floating-point values in the source operand (the second operand) stores the packed double precision floating-point results in the destination operand (the first operand).\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\n\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "SQRTPS",
    "Brief": "Compute square roots of packed single precision floating-point values",
    "Description": "\nPerforms a SIMD computation of the square roots of the four, eight or sixteen packed single precision floating-point values in the source operand (second operand) and stores the packed single precision floating-point results in the destination operand.\n\nEVEX.512 encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\n\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VSQRTPS",
    "Brief": "Compute square roots of packed single precision floating-point values with vector extensions",
    "Description": "\nPerforms a SIMD computation of the square roots of the four, eight or sixteen packed single precision floating-point values in the source operand (second operand) and stores the packed single precision floating-point results in the destination operand.\n\nEVEX.512 encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\n\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 encoded version: The source operand is an XMM register or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "SQRTSD",
    "Brief": "Compute square root of scalar double precision floating-point value",
    "Description": "\nComputes the square root of the low double precision floating-point value in the second source operand and stores the double precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. The quadword at bits 127:64 of the destination operand remains unchanged. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX encoded versions: Bits 127:64 of the destination operand are copied from the corresponding bits of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX encoded version: The low quadword element of the destination operand is updated according to the write-mask.\n\nSoftware should ensure VSQRTSD is encoded with VEX.L=0. Encoding VSQRTSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "SQRTSS",
    "Brief": "Compute square root of the low single precision floating-point value",
    "Description": "\nComputes the square root of the low single precision floating-point value in the second source operand and stores the single precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands is an XMM register.\n\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\n\nVEX.128 and EVEX encoded versions: Bits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the write-mask.\n\nSoftware should ensure VSQRTSS is encoded with VEX.L=0. Encoding VSQRTSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "STAC",
    "Brief": "Set AC Flag in EFLAGS Register",
    "Description": "\nSets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute STAC when CPL > 0 cause #UD (Undefined Opcode exception).\n\nThe instruction simply sets the AC flag in the EFLAGS register, with the following key characteristics:\n- Only executable in supervisor mode (CPL = 0)\n- Requires SMAP (Supervisor Mode Access Prevention) feature to be supported\n- Cannot be used with a LOCK prefix\n- Not recognized in virtual-8086 mode\n\nExceptions will be raised if:\n- The LOCK prefix is used\n- The Current Privilege Level (CPL) is greater than 0\n- The SMAP feature is not supported by the processor\n",
    "Alias": []
  },
  {
    "Name": "STC",
    "Brief": "Set Carry Flag",
    "Description": "\nSets the CF flag in the EFLAGS register. Operation is the same in all modes.\n\nThe instruction performs a simple operation of setting the Carry Flag (CF) to 1. When executed, it does not affect other flags like Overflow Flag (OF), Zero Flag (ZF), Sign Flag (SF), Auxiliary Carry Flag (AF), and Parity Flag (PF).\n\nThis instruction is typically used in scenarios where you want to explicitly set the carry flag, which can be useful in arithmetic operations, conditional branching, or other low-level programming tasks that rely on the carry flag's state.\n",
    "Alias": []
  },
  {
    "Name": "STD",
    "Brief": "Set Direction Flag",
    "Description": "\nSets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index registers (ESI and/or EDI). Operation is the same in all modes.\n\nWhen the DF flag is set:\n- String operations (such as MOVS, SCAS, STOS) will decrement the index registers (ESI and/or EDI) after each operation\n- This causes string operations to process memory from high address to low address (backwards)\n\nThe instruction simply sets the Direction Flag (DF) to 1 in the EFLAGS register.\n",
    "Alias": []
  },
  {
    "Name": "STI",
    "Brief": "Set Interrupt Flag",
    "Description": "\nIn most cases, STI sets the interrupt flag (IF) in the EFLAGS register. This allows the processor to respond to maskable hardware interrupts.\n\nIf IF = 0, maskable hardware interrupts remain inhibited on the instruction boundary following an execution of STI. (The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning from a procedure or subroutine. For instance, if an STI instruction is followed by an RET instruction, the RET instruction is allowed to execute before external interrupts are recognized. No interrupts can be recognized if an execution of CLI immediately follow such an execution of STI.) The inhibition ends after delivery of another event (e.g., exception) or the execution of the next instruction.\n\nThe IF flag and the STI and CLI instructions do not prohibit the generation of exceptions and nonmaskable interrupts (NMIs). However, NMIs (and system-management interrupts) may be inhibited on the instruction boundary following an execution of STI that begins with IF = 0.\n\nOperation is different in two modes:\n- PVI mode (protected-mode virtual interrupts): CR0.PE = 1, EFLAGS.VM = 0, CPL = 3, and CR4.PVI = 1\n- VME mode (virtual-8086 mode extensions): CR0.PE = 1, EFLAGS.VM = 1, and CR4.VME = 1\n\nIf IOPL < 3, EFLAGS.VIP = 1, and either VME mode or PVI mode is active, STI sets the VIF flag in the EFLAGS register, leaving IF unaffected.\n\nThe exact behavior depends on the processor operating mode, IOPL, CPL, and EFLAGS.VIP, as detailed in the decision table in the documentation.\n",
    "Alias": []
  },
  {
    "Name": "STMXCSR",
    "Brief": "Store contents of MXCSR control and status register to a 32-bit memory location",
    "Description": "\nStores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nFor VEX-encoded versions:\n- VEX.L must be 0, otherwise the instruction will cause an Undefined (UD) exception.\n- VEX.vvvv is reserved and must be 1111b, otherwise the instruction will cause an Undefined (UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VSTMXCSR",
    "Brief": "Store contents of MXCSR control and status register to a 32-bit memory location (VEX-encoded version)",
    "Description": "\nStores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nFor VEX-encoded versions:\n- VEX.L must be 0, otherwise the instruction will cause an Undefined (UD) exception.\n- VEX.vvvv is reserved and must be 1111b, otherwise the instruction will cause an Undefined (UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "STOS",
    "Brief": "Store a value from the AL, AX, EAX, or RAX register to memory",
    "Description": "\nIn non-64-bit and default 64-bit mode, these instructions store a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of the instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the destination operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, doubleword, and quadword versions of the STOS instructions.\n\nAfter the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented.\n\nIn 64-bit mode, the default address size is 64 bits, and 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits.\n\nThese instructions can be preceded by the REP prefix for block stores of ECX bytes, words, or doublewords. More often, they are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored.\n",
    "Alias": []
  },
  {
    "Name": "STOSB",
    "Brief": "Store a byte from AL register to memory",
    "Description": "\nIn non-64-bit and default 64-bit mode, these instructions store a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of the instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the destination operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, doubleword, and quadword versions of the STOS instructions.\n\nAfter the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented.\n\nIn 64-bit mode, the default address size is 64 bits, and 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits.\n\nThese instructions can be preceded by the REP prefix for block stores of ECX bytes, words, or doublewords. More often, they are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored.\n",
    "Alias": []
  },
  {
    "Name": "STOSW",
    "Brief": "Store a word from AX register to memory",
    "Description": "\nIn non-64-bit and default 64-bit mode, these instructions store a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of the instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the destination operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, doubleword, and quadword versions of the STOS instructions.\n\nAfter the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented.\n\nIn 64-bit mode, the default address size is 64 bits, and 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits.\n\nThese instructions can be preceded by the REP prefix for block stores of ECX bytes, words, or doublewords. More often, they are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored.\n",
    "Alias": []
  },
  {
    "Name": "STOSD",
    "Brief": "Store a doubleword from EAX register to memory",
    "Description": "\nIn non-64-bit and default 64-bit mode, these instructions store a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of the instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the destination operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, doubleword, and quadword versions of the STOS instructions.\n\nAfter the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented.\n\nIn 64-bit mode, the default address size is 64 bits, and 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits.\n\nThese instructions can be preceded by the REP prefix for block stores of ECX bytes, words, or doublewords. More often, they are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored.\n",
    "Alias": []
  },
  {
    "Name": "STOSQ",
    "Brief": "Store a quadword from RAX register to memory",
    "Description": "\nIn non-64-bit and default 64-bit mode, these instructions store a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of the instruction are allowed: the \"explicit-operands\" form and the \"no-operands\" form. The explicit-operands form allows the destination operand to be specified explicitly, while the no-operands form provides \"short forms\" of the byte, word, doubleword, and quadword versions of the STOS instructions.\n\nAfter the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented.\n\nIn 64-bit mode, the default address size is 64 bits, and 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits.\n\nThese instructions can be preceded by the REP prefix for block stores of ECX bytes, words, or doublewords. More often, they are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored.\n",
    "Alias": []
  },
  {
    "Name": "STR",
    "Brief": "Store segment selector from Task Register",
    "Description": "\nStores the segment selector from the task register (TR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the task state segment (TSS) for the currently running task.\n\nWhen the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower 16 bits of the register and the upper 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of operand size.\n\nIn 64-bit mode, operation is the same. The size of the memory operand is fixed at 16 bits. In register stores, the 2-byte TR is zero extended if stored to a 64-bit register.\n\nThe STR instruction is useful only in operating-system software. It can only be executed in protected mode.\n",
    "Alias": []
  },
  {
    "Name": "STTILECFG",
    "Brief": "Store tile configuration in memory",
    "Description": "\nThe STTILECFG instruction takes a pointer to a 64-byte memory location that will, after successful execution of this instruction, contain the description of the tiles that were configured. \n\nIn order to configure tiles, the AMX-TILE bit in CPUID must be set and the operating system has to have enabled the tiles architecture.\n\nIf the tiles are not configured, then STTILECFG stores 64B of zeros to the indicated memory location.\n\nAny attempt to execute the STTILECFG instruction inside an Intel TSX transaction will result in a transaction abort.\n\nWhen tiles are configured, the instruction stores:\n- Palette ID (1 byte)\n- Start row (1 byte)\n- Tile column sizes (2 bytes per tile)\n- Tile row sizes (1 byte per tile)\n\nIf no tiles are configured, 64 bytes of zeros are written to memory.\n",
    "Alias": []
  },
  {
    "Name": "STUI",
    "Brief": "Set user interrupt flag",
    "Description": "\nSTUI sets the user interrupt flag (UIF). Its effect takes place immediately; a user interrupt may be delivered on the instruction boundary following STUI. (This is in contrast with STI, whose effect is delayed by one instruction).\n\nAn execution of STUI inside a transactional region causes a transactional abort; the abort loads EAX as it would have been had it been due to an execution of STI.\n\nThe instruction is only valid in 64-bit mode and requires specific conditions:\n- CR4.UINTR must be set to 1\n- CPUID.07H.0H:EDX.UINTR[bit 5] must be set to 1\n- Cannot be used with the LOCK prefix\n- Cannot be executed inside an enclave\n\nIf these conditions are not met, the instruction will generate an Undefined Opcode (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "SUB",
    "Brief": "Subtract the source operand from the destination operand",
    "Description": "\nSubtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\n\nThe SUB instruction performs integer subtraction. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate an overflow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n",
    "Alias": []
  },
  {
    "Name": "SUBPD",
    "Brief": "Subtract packed double precision floating-point values",
    "Description": "\nPerforms a SIMD subtract of the two, four or eight packed double precision floating-point values of the second Source operand from the first Source operand, and stores the packed double precision floating-point results in the destination operand.\n\nVEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The first source operand and destination operands are ZMM registers. The destination operand is conditionally updated according to the writemask.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "SUBPS",
    "Brief": "Subtract packed single precision floating-point values",
    "Description": "\nPerforms a SIMD subtract of the packed single precision floating-point values in the second Source operand from the First Source operand, and stores the packed single precision floating-point results in the destination operand.\n\nVEX.128 and EVEX.128 encoded versions:\n- The second source operand is an XMM register or a 128-bit memory location\n- The first source operand and destination operands are XMM registers\n- Bits (MAXVL-1:128) of the corresponding destination register are zeroed\n\nVEX.256 and EVEX.256 encoded versions:\n- The second source operand is a YMM register or a 256-bit memory location\n- The first source operand and destination operands are YMM registers\n- Bits (MAXVL-1:256) of the corresponding destination register are zeroed\n\nEVEX.512 encoded version:\n- The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location\n- The first source operand and destination operands are ZMM registers\n- The destination operand is conditionally updated according to the writemask\n\n128-bit Legacy SSE version:\n- The second source can be an XMM register or a 128-bit memory location\n- The destination is not distinct from the first source XMM register\n- The upper bits (MAXVL-1:128) of the corresponding register destination are unmodified\n",
    "Alias": []
  },
  {
    "Name": "SUBSD",
    "Brief": "Subtract scalar double precision floating-point values",
    "Description": "\nSubtract the low double precision floating-point value in the second source operand from the first source operand and stores the double precision floating-point result in the low quadword of the destination operand.\n\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX encoded versions: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX encoded version: The low quadword element of the destination operand is updated according to the write-mask.\n\nSoftware should ensure VSUBSD is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "SUBSS",
    "Brief": "Subtract scalar single precision floating-point value",
    "Description": "\nSubtract the low single precision floating-point value from the second source operand and the first source operand and store the double precision floating-point result in the low doubleword of the destination operand.\n\nThe second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged.\n\nVEX.128 and EVEX encoded versions: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the write-mask.\n\nSoftware should ensure VSUBSS is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "SWAPGS",
    "Brief": "Exchanges the current GS base register value with the value in MSR address C0000102H",
    "Description": "\nSWAPGS exchanges the current GS base register value with the value contained in MSR address C0000102H (IA32_KERNEL_GS_BASE). The SWAPGS instruction is a privileged instruction intended for use by system software.\n\nWhen using SYSCALL to implement system calls, there is no kernel stack at the OS entry point. Neither is there a straightforward method to obtain a pointer to kernel structures from which the kernel stack pointer could be read. Thus, the kernel cannot save general purpose registers or reference memory.\n\nBy design, SWAPGS does not require any general purpose registers or memory operands. No registers need to be saved before using the instruction. SWAPGS exchanges the CPL 0 data pointer from the IA32_KERNEL_GS_BASE MSR with the GS base register. The kernel can then use the GS prefix on normal memory references to access kernel data structures. Similarly, when the OS kernel is entered using an interrupt or exception (where the kernel stack is already set up), SWAPGS can be used to quickly get a pointer to the kernel data structures.\n\nThe IA32_KERNEL_GS_BASE MSR itself is only accessible using RDMSR/WRMSR instructions. Those instructions are only accessible at privilege level 0. The WRMSR instruction ensures that the IA32_KERNEL_GS_BASE MSR contains a canonical address.\n",
    "Alias": []
  },
  {
    "Name": "SYSCALL",
    "Brief": "Fast call to privilege level 0 system procedures",
    "Description": "\nSYSCALL invokes an OS system-call handler at privilege level 0. It does this by:\n\n1. Loading RIP from the IA32_LSTAR MSR (saving the next instruction's address in RCX)\n2. Saving RFLAGS into R11\n3. Masking RFLAGS using the IA32_FMASK MSR\n4. Loading CS and SS selectors with values from IA32_STAR MSR\n\nKey characteristics:\n- Only valid in 64-bit mode when SYSCALL/SYSRET is enabled\n- Does not save the stack pointer (RSP)\n- When shadow stacks are enabled, it handles SSP (Shadow Stack Pointer)\n- Ensures the system-call handler runs at privilege level 0\n\nInstruction ordering notes:\n- Instructions following SYSCALL may be prefetched\n- But they will not execute until all prior instructions have completed\n\nThe instruction is designed for fast system calls, providing a quick transition from user to kernel mode with minimal overhead.\n",
    "Alias": []
  },
  {
    "Name": "SYSENTER",
    "Brief": "Fast call to privilege level 0 system procedures",
    "Description": "\nExecutes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT. The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to operating system or executive procedures running at privilege level 0.\n\nWhen executed in IA-32e mode, the SYSENTER instruction transitions the logical processor to 64-bit mode; otherwise, the logical processor remains in protected mode.\n\nPrior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:\n\n- IA32_SYSENTER_CS (MSR address 174H): The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment.\n- IA32_SYSENTER_EIP (MSR address 176H): The value of this MSR is loaded into RIP, referencing the first instruction of the selected operating procedure or routine.\n- IA32_SYSENTER_ESP (MSR address 175H): The value of this MSR is loaded into RSP, containing the stack pointer for the privilege level 0 stack.\n\nThe SYSENTER instruction can be invoked from all operating modes except real-address mode. It does not save state information for the user code and does not support passing parameters on the stack.\n\nThe availability of these instructions is indicated by the SYSENTER/SYSEXIT present (SEP) feature flag returned by the CPUID instruction.\n",
    "Alias": []
  },
  {
    "Name": "SYSEXIT",
    "Brief": "Fast return to privilege level 3 user code",
    "Description": "\nExecutes a fast return to privilege level 3 user code. SYSEXIT is a companion instruction to the SYSENTER instruction. The instruction is optimized to provide the maximum performance for returns from system procedures executing at protection levels 0 to user procedures executing at protection level 3. It must be executed from code executing at privilege level 0.\n\nWith a 64-bit operand size, SYSEXIT remains in 64-bit mode; otherwise, it either enters compatibility mode (if the logical processor is in IA-32e mode) or remains in protected mode (if it is not).\n\nPrior to executing SYSEXIT, software must specify the privilege level 3 code segment and code entry point, and the privilege level 3 stack segment and stack pointer by writing values into the following MSR and general-purpose registers:\n\n- IA32_SYSENTER_CS (MSR address 174H) — Contains a 32-bit value that is used to determine the segment selectors for the privilege level 3 code and stack segments\n- RDX — The canonical address in this register is loaded into RIP (references the first instruction to be executed in the user code)\n- ECX — The canonical address in this register is loaded into RSP (contains the stack pointer for the privilege level 3 stack)\n\nWhile SYSEXIT loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and SS descriptor caches are not loaded from the descriptors. Instead, the descriptor caches are loaded with fixed values.\n\nThe SYSEXIT instruction can be invoked from all operating modes except real-address mode and virtual-8086 mode.\n",
    "Alias": []
  },
  {
    "Name": "SYSRET",
    "Brief": "Return from fast system call to user code at privilege level 3",
    "Description": "\nSYSRET is a companion instruction to the SYSCALL instruction. It returns from an OS system-call handler to user code at privilege level 3. It does so by loading RIP from RCX and loading RFLAGS from R11.\n\nWith a 64-bit operand size, SYSRET remains in 64-bit mode; otherwise, it enters compatibility mode and only the low 32 bits of the registers are loaded.\n\nSYSRET loads the CS and SS selectors with values derived from bits 63:48 of the IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values.\n\nThe SYSRET instruction does not modify the stack pointer (ESP or RSP). It is the responsibility of the OS or user code to switch to the user stack.\n\nWhen shadow stacks are enabled at privilege level 3, the instruction loads SSP with the value from IA32_PL3_SSP MSR.\n\nInstruction ordering: Instructions following a SYSRET may be fetched from memory before earlier instructions complete execution, but they will not execute until all instructions prior to the SYSRET have completed execution.\n",
    "Alias": []
  },
  {
    "Name": "TDPBF16PS",
    "Brief": "Dot Product of BF16 Tiles Accumulated into Packed Single Precision Tile",
    "Description": "\nThis instruction performs a set of SIMD dot-products of two BF16 elements and accumulates the results into a packed single precision tile. Each dword element in input tiles tmm2 and tmm3 is interpreted as a BF16 pair. For each possible combination of (row of tmm2, column of tmm3), the instruction performs a set of SIMD dot-products on all corresponding BF16 pairs (one pair from tmm2 and one pair from tmm3), adds the results of those dot-products, and then accumulates the result into the corresponding row and column of tmm1.\n\n\"Round to nearest even\" rounding mode is used when doing each accumulation of the FMA. Output denormals are always flushed to zero and input denormals are always treated as zero. MXCSR is not consulted nor updated.\n\nAny attempt to execute the TDPBF16PS instruction inside a TSX transaction will result in a transaction abort.\n\nThe instruction supports matrix multiplication of BF16 elements, converting them to single precision floating-point values during the dot product calculation, and accumulating the results into a destination tile.\n",
    "Alias": []
  },
  {
    "Name": "TDPBSSD",
    "Brief": "Matrix multiply signed byte elements from tmm2 by signed byte elements from tmm3 and accumulate the dword elements in tmm1",
    "Description": "\nFor each possible combination of (row of tmm2, column of tmm3), the instruction performs a set of SIMD dot-products on all corresponding four byte elements, one from tmm2 and one from tmm3, adds the results of those dot-products, and then accumulates the result into the corresponding row and column of tmm1. Each dword in input tiles tmm2 and tmm3 is interpreted as four byte elements. These may be signed or unsigned. Each letter in the two-letter pattern SU, US, SS, UU indicates the signed/unsigned nature of the values in tmm2 and tmm3, respectively.\n\nAny attempt to execute the TDPBSSD/TDPBSUD/TDPBUSD/TDPBUUD instructions inside an Intel TSX transaction will result in a transaction abort.\n\nThe instructions perform a matrix multiplication where:\n- For TDPBSSD: Both tmm2 and tmm3 use signed byte interpretation\n- For TDPBSUD: tmm2 uses signed bytes, tmm3 uses unsigned bytes\n- For TDPBUSD: tmm2 uses unsigned bytes, tmm3 uses signed bytes\n- For TDPBUUD: Both tmm2 and tmm3 use unsigned byte interpretation\n\nThe result is accumulated in tmm1, which means the previous values in tmm1 are added to the new dot product results.\n",
    "Alias": []
  },
  {
    "Name": "TDPBSUD",
    "Brief": "Matrix multiply signed byte elements from tmm2 by unsigned byte elements from tmm3 and accumulate the dword elements in tmm1",
    "Description": "\nFor each possible combination of (row of tmm2, column of tmm3), the instruction performs a set of SIMD dot-products on all corresponding four byte elements, one from tmm2 and one from tmm3, adds the results of those dot-products, and then accumulates the result into the corresponding row and column of tmm1. Each dword in input tiles tmm2 and tmm3 is interpreted as four byte elements. These may be signed or unsigned. Each letter in the two-letter pattern SU, US, SS, UU indicates the signed/unsigned nature of the values in tmm2 and tmm3, respectively.\n\nAny attempt to execute the TDPBSSD/TDPBSUD/TDPBUSD/TDPBUUD instructions inside an Intel TSX transaction will result in a transaction abort.\n\nThe instructions perform a matrix multiplication where:\n- For TDPBSSD: Both tmm2 and tmm3 use signed byte interpretation\n- For TDPBSUD: tmm2 uses signed bytes, tmm3 uses unsigned bytes\n- For TDPBUSD: tmm2 uses unsigned bytes, tmm3 uses signed bytes\n- For TDPBUUD: Both tmm2 and tmm3 use unsigned byte interpretation\n\nThe result is accumulated in tmm1, which means the previous values in tmm1 are added to the new dot product results.\n",
    "Alias": []
  },
  {
    "Name": "TDPBUSD",
    "Brief": "Matrix multiply unsigned byte elements from tmm2 by signed byte elements from tmm3 and accumulate the dword elements in tmm1",
    "Description": "\nFor each possible combination of (row of tmm2, column of tmm3), the instruction performs a set of SIMD dot-products on all corresponding four byte elements, one from tmm2 and one from tmm3, adds the results of those dot-products, and then accumulates the result into the corresponding row and column of tmm1. Each dword in input tiles tmm2 and tmm3 is interpreted as four byte elements. These may be signed or unsigned. Each letter in the two-letter pattern SU, US, SS, UU indicates the signed/unsigned nature of the values in tmm2 and tmm3, respectively.\n\nAny attempt to execute the TDPBSSD/TDPBSUD/TDPBUSD/TDPBUUD instructions inside an Intel TSX transaction will result in a transaction abort.\n\nThe instructions perform a matrix multiplication where:\n- For TDPBSSD: Both tmm2 and tmm3 use signed byte interpretation\n- For TDPBSUD: tmm2 uses signed bytes, tmm3 uses unsigned bytes\n- For TDPBUSD: tmm2 uses unsigned bytes, tmm3 uses signed bytes\n- For TDPBUUD: Both tmm2 and tmm3 use unsigned byte interpretation\n\nThe result is accumulated in tmm1, which means the previous values in tmm1 are added to the new dot product results.\n",
    "Alias": []
  },
  {
    "Name": "TDPBUUD",
    "Brief": "Matrix multiply unsigned byte elements from tmm2 by unsigned byte elements from tmm3 and accumulate the dword elements in tmm1",
    "Description": "\nFor each possible combination of (row of tmm2, column of tmm3), the instruction performs a set of SIMD dot-products on all corresponding four byte elements, one from tmm2 and one from tmm3, adds the results of those dot-products, and then accumulates the result into the corresponding row and column of tmm1. Each dword in input tiles tmm2 and tmm3 is interpreted as four byte elements. These may be signed or unsigned. Each letter in the two-letter pattern SU, US, SS, UU indicates the signed/unsigned nature of the values in tmm2 and tmm3, respectively.\n\nAny attempt to execute the TDPBSSD/TDPBSUD/TDPBUSD/TDPBUUD instructions inside an Intel TSX transaction will result in a transaction abort.\n\nThe instructions perform a matrix multiplication where:\n- For TDPBSSD: Both tmm2 and tmm3 use signed byte interpretation\n- For TDPBSUD: tmm2 uses signed bytes, tmm3 uses unsigned bytes\n- For TDPBUSD: tmm2 uses unsigned bytes, tmm3 uses signed bytes\n- For TDPBUUD: Both tmm2 and tmm3 use unsigned byte interpretation\n\nThe result is accumulated in tmm1, which means the previous values in tmm1 are added to the new dot product results.\n",
    "Alias": []
  },
  {
    "Name": "TEST",
    "Brief": "Perform bitwise logical AND and set status flags",
    "Description": "\nComputes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result. The result is then discarded.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nSpecific variations include:\n- TEST with AL/AX/EAX/RAX and an immediate value\n- TEST with a register/memory operand and an immediate value\n- TEST between two registers or between a register and a memory operand\n\nThe instruction sets the following flags:\n- OF and CF are set to 0\n- SF is set to the most significant bit of the result\n- ZF is set to 1 if the result is zero, 0 otherwise\n- PF is set based on the bit-wise XNOR of the least significant byte\n- AF is left in an undefined state\n",
    "Alias": []
  },
  {
    "Name": "TESTUI",
    "Brief": "Determine User Interrupt Flag",
    "Description": "\nTESTUI copies the current value of the user interrupt flag (UIF) into EFLAGS.CF. This instruction can be executed regardless of CPL.\n\nThe instruction performs the following operations:\n- Copies the current value of the user interrupt flag (UIF) into the Carry Flag (CF)\n- Clears the Zero Flag (ZF)\n- Clears the Auxiliary Carry Flag (AF)\n- Clears the Overflow Flag (OF)\n- Clears the Parity Flag (PF)\n- Clears the Sign Flag (SF)\n\nTESTUI may be executed normally inside a transactional region. However, it has several restrictions in different modes and can trigger an Undefined Instruction (#UD) exception under certain conditions, such as:\n- Using the LOCK prefix\n- Executing inside an enclave\n- When CR4.UINTR = 0\n- When CPUID.07H.0H:EDX.UINTR[bit 5] = 0\n",
    "Alias": []
  },
  {
    "Name": "TILELOADD",
    "Brief": "Load data into tile register with full caching",
    "Description": "\nThis instruction is required to use SIB addressing. The index register serves as a stride indicator. If the SIB encoding omits an index register, the value zero is assumed for the content of the index register.\n\nThe instruction loads a tile destination with rows and columns as specified by the tile configuration. The \"T1\" version provides a hint to the implementation that the data would be reused but does not need to be resident in the nearest cache levels.\n\nThe TILECFG.start_row in the TILECFG data should be initialized to '0' in order to load the entire tile and is set to zero on successful completion of the TILELOADD instruction. TILELOADD is a restartable instruction and the TILECFG.start_row will be non-zero when restartable events occur during the instruction execution.\n\nOnly memory operands are supported and they can only be accessed using a SIB addressing mode, similar to the V[P]GATHER*/V[P]SCATTER* instructions.\n\nAny attempt to execute the TILELOADD/TILELOADDT1 instructions inside an Intel TSX transaction will result in a transaction abort.\n",
    "Alias": []
  },
  {
    "Name": "TILELOADDT1",
    "Brief": "Load data into tile register with data caching optimization hint",
    "Description": "\nThis instruction is required to use SIB addressing. The index register serves as a stride indicator. If the SIB encoding omits an index register, the value zero is assumed for the content of the index register.\n\nThe instruction loads a tile destination with rows and columns as specified by the tile configuration. The \"T1\" version provides a hint to the implementation that the data would be reused but does not need to be resident in the nearest cache levels.\n\nThe TILECFG.start_row in the TILECFG data should be initialized to '0' in order to load the entire tile and is set to zero on successful completion of the TILELOADD instruction. TILELOADD is a restartable instruction and the TILECFG.start_row will be non-zero when restartable events occur during the instruction execution.\n\nOnly memory operands are supported and they can only be accessed using a SIB addressing mode, similar to the V[P]GATHER*/V[P]SCATTER* instructions.\n\nAny attempt to execute the TILELOADD/TILELOADDT1 instructions inside an Intel TSX transaction will result in a transaction abort.\n",
    "Alias": []
  },
  {
    "Name": "TILERELEASE",
    "Brief": "Returns TILECFG and TILEDATA to the INIT state",
    "Description": "\nThis instruction returns TILECFG and TILEDATA to the INIT state.\n\nAny attempt to execute the TILERELEASE instruction inside an Intel TSX transaction will result in a transaction abort.\n\nThe instruction performs the following operations:\n- Zeros all tile data\n- Sets the tile configuration to zero (equivalent to 64 bytes of zeros)\n- Resets the number of configured tiles to zero\n\nThis instruction is part of the Intel Advanced Matrix Extensions (AMX) instruction set, which provides hardware support for matrix multiplication and other matrix operations.\n",
    "Alias": []
  },
  {
    "Name": "TILESTORED",
    "Brief": "Store a tile from a tile register to memory using SIB addressing",
    "Description": "\nThis instruction stores a tile source of rows and columns as specified by the tile configuration.\n\nKey characteristics:\n- Requires SIB addressing\n- Only memory operands are supported\n- Index register serves as a stride indicator\n- If no index register is specified, zero is assumed\n- The TILECFG.start_row should be initialized to '0' to store the entire tile\n- Restartable instruction where TILECFG.start_row will be non-zero during restartable events\n- Executing inside an Intel TSX transaction will result in a transaction abort\n\nThe instruction works by:\n1. Determining the memory base and stride\n2. Writing each row of the tile to memory based on the configuration\n3. Zeroing the TILECFG start row on successful completion\n4. Handling potential memory faults by tracking the current row\n\nSupported in 64-bit mode with the AMX-TILE CPUID feature flag.\n",
    "Alias": []
  },
  {
    "Name": "TILEZERO",
    "Brief": "Zero the destination tile",
    "Description": "\nThis instruction zeroes the destination tile.\n\nThe operation involves:\n- Determining the number of bytes per row from the palette table\n- Iterating through each row and byte of the tile\n- Setting each byte to zero\n- Calling zero_tilecfg_start()\n\nAny attempt to execute the TILEZERO instruction inside an Intel TSX transaction will result in a transaction abort.\n\nThe instruction is part of the Intel Advanced Matrix Extensions (AMX) instruction set, and uses the CPUID feature flag AMX-TILE.\n",
    "Alias": []
  },
  {
    "Name": "TPAUSE",
    "Brief": "Directs the processor to enter an implementation-dependent optimized state",
    "Description": "\nTPAUSE instructs the processor to enter an implementation-dependent optimized state. There are two such optimized states to choose from: \n\n1. Light-weight power/performance optimized state (C0.2):\n- Slower wakeup time\n- Larger power savings\n- Improves performance of other SMT threads on the same core\n- Selected when input register bit[0] = 0\n\n2. Improved power/performance optimized state (C0.1):\n- Faster wakeup time\n- Smaller power savings\n- Selected when input register bit[0] = 1\n\nThe instruction is available when CPUID.7.0:ECX.WAITPKG[bit 5] is set to 1. It can be executed at any privilege level and operates the same in both 64-bit and non-64-bit modes.\n\nThe processor wakes up when the time-stamp counter reaches or exceeds the 64-bit input value in EDX:EAX. An operating system can specify a maximum delay by writing to the IA32_UMWAIT_CONTROL MSR.\n\nThe instruction can be interrupted by various events such as:\n- Store to read-set range within a transactional region\n- NMI or SMI\n- Debug exception\n- Machine check exception\n- External interrupts\n- Other implementation-dependent events\n\nIf the processor wakes due to the operating system time limit, the RFLAGS.CF is set; otherwise, it is cleared.\n",
    "Alias": []
  },
  {
    "Name": "TZCNT",
    "Brief": "Count the number of trailing zero bits",
    "Description": "\nTZCNT counts the number of trailing least significant zero bits in source operand (second operand) and returns the result in destination operand (first operand). TZCNT is an extension of the BSF instruction. \n\nThe key difference between TZCNT and BSF instruction is that TZCNT provides operand size as output when source operand is zero, while in the case of BSF instruction, if source operand is zero, the content of destination operand are undefined. \n\nOn processors that do not support TZCNT, the instruction byte encoding is executed as BSF.\n\nThe instruction works on 16-bit, 32-bit, and 64-bit operands. When the source operand is zero:\n- The destination operand will be set to the operand size\n- The Carry Flag (CF) is set to 1\n- The Zero Flag (ZF) is set to 1\n\nOther flags (OF, SF, PF, and AF) are left undefined.\n",
    "Alias": []
  },
  {
    "Name": "UCOMISD",
    "Brief": "Unordered compare scalar double precision floating-point values and set EFLAGS",
    "Description": "\nPerforms an unordered compare of the double precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\n\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory location.\n\nThe UCOMISD instruction differs from the COMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) only when a source operand is an SNaN. The COMISD instruction signals an invalid operation exception only if a source operand is either an SNaN or a QNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n\nSoftware should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "UCOMISS",
    "Brief": "Unordered Compare Scalar Single Precision Floating-Point Values and Set EFLAGS",
    "Description": "\nCompares the single precision floating-point values in the low doublewords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\n\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.\n\nThe UCOMISS instruction differs from the COMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) only if a source operand is an SNaN. The COMISS instruction signals an invalid operation exception when a source operand is either a QNaN or SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD. Software should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n",
    "Alias": []
  },
  {
    "Name": "UD0",
    "Brief": "Raise invalid opcode exception with r32 and r/m32 operands",
    "Description": "\nGenerates an invalid opcode exception. These instructions are provided for software testing to explicitly generate an invalid opcode exception. The opcodes for these instructions are reserved for this purpose.\n\nOther than raising the invalid opcode exception, these instructions have no effect on processor state or memory.\n\nEven though it is the execution of the UD instruction that causes the invalid opcode exception, the instruction pointer saved by delivery of the exception references the UD instruction (and not the following instruction).\n\nUD0 and UD1 require r32 and r/m32 operands, while UD2 does not require any operands. All three instructions behave the same way in both non-64-bit and 64-bit modes.\n\nNote: Some processors decode the UD0 instruction without a ModR/M byte, which may result in an invalid-opcode exception when the instruction crosses a page or segment boundary.\n",
    "Alias": []
  },
  {
    "Name": "UD1",
    "Brief": "Raise invalid opcode exception with r32 and r/m32 operands",
    "Description": "\nGenerates an invalid opcode exception. These instructions are provided for software testing to explicitly generate an invalid opcode exception. The opcodes for these instructions are reserved for this purpose.\n\nOther than raising the invalid opcode exception, these instructions have no effect on processor state or memory.\n\nEven though it is the execution of the UD instruction that causes the invalid opcode exception, the instruction pointer saved by delivery of the exception references the UD instruction (and not the following instruction).\n\nUD0 and UD1 require r32 and r/m32 operands, while UD2 does not require any operands. All three instructions behave the same way in both non-64-bit and 64-bit modes.\n\nNote: Some processors decode the UD0 instruction without a ModR/M byte, which may result in an invalid-opcode exception when the instruction crosses a page or segment boundary.\n",
    "Alias": []
  },
  {
    "Name": "UD2",
    "Brief": "Raise invalid opcode exception without operands",
    "Description": "\nGenerates an invalid opcode exception. These instructions are provided for software testing to explicitly generate an invalid opcode exception. The opcodes for these instructions are reserved for this purpose.\n\nOther than raising the invalid opcode exception, these instructions have no effect on processor state or memory.\n\nEven though it is the execution of the UD instruction that causes the invalid opcode exception, the instruction pointer saved by delivery of the exception references the UD instruction (and not the following instruction).\n\nUD0 and UD1 require r32 and r/m32 operands, while UD2 does not require any operands. All three instructions behave the same way in both non-64-bit and 64-bit modes.\n\nNote: Some processors decode the UD0 instruction without a ModR/M byte, which may result in an invalid-opcode exception when the instruction crosses a page or segment boundary.\n",
    "Alias": []
  },
  {
    "Name": "UIRET",
    "Brief": "Return from handling a user interrupt",
    "Description": "\nUIRET returns from the handling of a user interrupt. It can be executed regardless of CPL.\n\nExecution of UIRET inside a transactional region causes a transactional abort; the abort loads EAX as it would have been due to an execution of IRET.\n\nUIRET can be tracked by Architectural Last Branch Records (LBRs), Intel Processor Trace (Intel PT), and Performance Monitoring. For both Intel PT and LBRs, UIRET is recorded in precisely the same manner as IRET. Hence for LBRs, UIRETs fall into the OTHER_BRANCH category, which implies that IA32_LBR_CTL.OTHER_BRANCH[bit 22] must be set to record user-interrupt delivery, and that the IA32_LBR_x_INFO.BR_TYPE field will indicate OTHER_BRANCH for any recorded user interrupt. For Intel PT, control flow tracing must be enabled by setting IA32_RTIT_CTL.BranchEn[bit 13].\n\nUIRET will also increment performance counters for which counting BR_INST_RETIRED.FAR_BRANCH is enabled.\n\nThe instruction pops the return instruction pointer (RIP), return flags (RFLAGS), and return stack pointer (RSP) from the stack, updates the appropriate registers, and sets the User Interrupt Flag (UIF) to 1.\n",
    "Alias": []
  },
  {
    "Name": "UMONITOR",
    "Brief": "User Level Set Up Monitor Address",
    "Description": "\nThe UMONITOR instruction arms address monitoring hardware using an address specified in the source register. A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by UMWAIT.\n\nThe content of the source register is an effective address. By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used. The address range must use memory of the write-back type. Only write-back memory is guaranteed to correctly trigger the monitoring hardware.\n\nThe UMONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, UMONITOR sets the A-bit but not the D-bit in page tables.\n\nUMONITOR and UMWAIT are available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. UMONITOR and UMWAIT may be executed at any privilege level. Except for the width of the source register, the instruction's operation is the same in non-64-bit modes and in 64-bit mode.\n\nUMONITOR does not interoperate with the legacy MWAIT instruction. The instruction causes a transactional abort when used inside a transactional region.\n",
    "Alias": []
  },
  {
    "Name": "UMWAIT",
    "Brief": "User Level Monitor Wait - Hint to enter an implementation-dependent optimized state",
    "Description": "\nUMWAIT instructs the processor to enter an implementation-dependent optimized state while monitoring a range of addresses. The optimized state may be either a light-weight power/performance optimized state or an improved power/performance optimized state. The selection between the two states is governed by the explicit input register bit[0] source operand.\n\nUMWAIT is available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. UMWAIT may be executed at any privilege level. \n\nThe input register contains information about the preferred optimized state:\n- bit[0] = 0: C0.2 state (slower wakeup, larger power savings, improves performance of other SMT threads)\n- bit[0] = 1: C0.1 state (faster wakeup, smaller power savings)\n\nThe instruction wakes up when the time-stamp counter reaches or exceeds the implicit EDX:EAX 64-bit input value (if the monitoring hardware did not trigger beforehand).\n\nAn operating system can specify the maximum delay by writing a TSC-quanta value to the IA32_UMWAIT_CONTROL MSR. If the processor wakes due to the OS time limit, RFLAGS.CF is set; otherwise, it is cleared.\n\nUMWAIT works in conjunction with the UMONITOR instruction to define an address to wait on and an optimized waiting state. The instruction will not wait if certain preceding instructions have been executed.\n\nThe processor can exit the optimized state due to various events, including:\n- Store to the monitored address range\n- NMI or SMI\n- Debug exception\n- Machine check exception\n- External interrupts\n",
    "Alias": []
  },
  {
    "Name": "UNPCKHPD",
    "Brief": "Unpack and Interleave High Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms an interleaved unpack of the high double precision floating-point values from the first source operand and the second source operand.\n\n128-bit Legacy SSE version: The second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits of the corresponding ZMM register destination are unmodified.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The upper bits of the corresponding ZMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a register, memory location, or a vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register, conditionally updated using writemask k1.\n\nThe instruction essentially takes the high quadwords from both source operands and interleaves them into the destination operand.\n",
    "Alias": []
  },
  {
    "Name": "UNPCKHPS",
    "Brief": "Unpack and Interleave High Packed Single Precision Floating-Point Values",
    "Description": "\nPerforms an interleaved unpack of the high single precision floating-point values from the first source operand and the second source operand.\n\n128-bit Legacy SSE version: The second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\nVEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.\n\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\n\nEVEX.128 encoded version: The first source operand is a XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VUNPCKHPS",
    "Brief": "Vector Unpack and Interleave High Packed Single Precision Floating-Point Values",
    "Description": "\nPerforms an interleaved unpack of the high single precision floating-point values from the first source operand and the second source operand.\n\n128-bit Legacy SSE version: The second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\nVEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.\n\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\n\nEVEX.128 encoded version: The first source operand is a XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "UNPCKLPD",
    "Brief": "Unpack and Interleave Low Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms an interleaved unpack of the low double precision floating-point values from the first source operand and the second source operand.\n\n128-bit Legacy SSE version: The second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits of the corresponding ZMM register destination are unmodified.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The upper bits of the corresponding ZMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nEVEX encoded versions: Support for register and memory sources with optional broadcasting, and conditional updates using writemask k1 for XMM, YMM, and ZMM registers.\n\nThe instruction essentially takes the low 64-bit double-precision floating-point values from two source operands and interleaves them into the destination register.\n",
    "Alias": []
  },
  {
    "Name": "VUNPCKLPD",
    "Brief": "Vector Unpack and Interleave Low Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms an interleaved unpack of the low double precision floating-point values from the first source operand and the second source operand.\n\n128-bit Legacy SSE version: The second source can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits of the corresponding ZMM register destination are unmodified.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The upper bits of the corresponding ZMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nEVEX encoded versions: Support for register and memory sources with optional broadcasting, and conditional updates using writemask k1 for XMM, YMM, and ZMM registers.\n\nThe instruction essentially takes the low 64-bit double-precision floating-point values from two source operands and interleaves them into the destination register.\n",
    "Alias": []
  },
  {
    "Name": "UNPCKLPS",
    "Brief": "Unpack and Interleave Low Packed Single Precision Floating-Point Values",
    "Description": "\nPerforms an interleaved unpack of the low single precision floating-point values from the first source operand and the second source operand.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.\n\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\n\nEVEX.128 encoded version: The first source operand is an XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VADDPH",
    "Brief": "Add packed FP16 values",
    "Description": "\nThis instruction adds packed FP16 values from source operands and stores the packed FP16 result in the destination operand. The destination elements are updated according to the writemask.\n\nThe instruction supports different vector lengths (128, 256, and 512 bits) and provides various operation modes:\n- When source operand is a register, it adds corresponding FP16 values from two registers\n- When source operand is a memory source, it can perform broadcast addition (using the first memory element for all additions)\n- Supports write masking, allowing selective element updates\n- Provides rounding control for 512-bit vector operations\n\nThe instruction handles different floating-point scenarios including:\n- Invalid operations\n- Underflow\n- Overflow\n- Precision\n- Denormal number handling\n",
    "Alias": []
  },
  {
    "Name": "VADDSH",
    "Brief": "Add scalar FP16 values",
    "Description": "\nThis instruction adds the low FP16 value from the source operands and stores the FP16 result in the destination operand.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nThe instruction supports various rounding modes and can be used with write masks for conditional execution. It can perform the addition with different rounding controls, either using the MXCSR rounding control or an explicit rounding control provided in the instruction.\n",
    "Alias": []
  },
  {
    "Name": "VALIGND",
    "Brief": "Shift right and merge vectors with doubleword granularity",
    "Description": "\nConcatenates and shifts right doubleword/quadword elements of the first source operand (the second operand) and the second source operand (the third operand) into a 1024/512/256-bit intermediate vector. The low 512/256/128-bit of the intermediate vector is written to the destination operand (the first operand) using the writemask k1.\n\nThe destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location.\n\nThis instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1 are computed and stored into zmm1. Elements in zmm1 with the corresponding bit clear in k1 retain their previous values (merging-masking) or are set to 0 (zeroing-masking).\n\nVALIGND works with doubleword (32-bit) elements, while VALIGNQ works with quadword (64-bit) elements. The shift amount is specified by an immediate byte (imm8), with the number of bits to shift depending on the vector length.\n",
    "Alias": []
  },
  {
    "Name": "VALIGNQ",
    "Brief": "Shift right and merge vectors with quadword granularity",
    "Description": "\nConcatenates and shifts right doubleword/quadword elements of the first source operand (the second operand) and the second source operand (the third operand) into a 1024/512/256-bit intermediate vector. The low 512/256/128-bit of the intermediate vector is written to the destination operand (the first operand) using the writemask k1.\n\nThe destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location.\n\nThis instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1 are computed and stored into zmm1. Elements in zmm1 with the corresponding bit clear in k1 retain their previous values (merging-masking) or are set to 0 (zeroing-masking).\n\nVALIGND works with doubleword (32-bit) elements, while VALIGNQ works with quadword (64-bit) elements. The shift amount is specified by an immediate byte (imm8), with the number of bits to shift depending on the vector length.\n",
    "Alias": []
  },
  {
    "Name": "VBLENDMPD",
    "Brief": "Blend double precision vector elements using an OpMask control",
    "Description": "\nPerforms an element-by-element blending between float64/float32 elements in the first source operand (the second operand) with the elements in the second source operand (the third operand) using an opmask register as select control. The blended result is written to the destination register.\n\nThe destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location.\n\nThe opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for first source operand, 1 for second source operand).\n\nIf EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VBLENDMPS",
    "Brief": "Blend single precision vector elements using an OpMask control",
    "Description": "\nPerforms an element-by-element blending between float64/float32 elements in the first source operand (the second operand) with the elements in the second source operand (the third operand) using an opmask register as select control. The blended result is written to the destination register.\n\nThe destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location.\n\nThe opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for first source operand, 1 for second source operand).\n\nIf EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTSS",
    "Brief": "Load with Broadcast Single Precision Floating-Point Data",
    "Description": "\nVBROADCAST instructions load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).\n\nVEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.\n\nDifferent variants of VBROADCAST instructions support different granularities and vector lengths:\n- VBROADCASTSS supports 128-bit, 256-bit, and 512-bit versions\n- VBROADCASTSD supports 256-bit and 512-bit versions\n- VBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2 support both 256-bit and 512-bit versions\n- VBROADCASTF32X8 and VBROADCASTF64X4 are only supported in 512-bit versions\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTSD",
    "Brief": "Load with Broadcast Double Precision Floating-Point Data",
    "Description": "\nVBROADCAST instructions load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).\n\nVEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.\n\nDifferent variants of VBROADCAST instructions support different granularities and vector lengths:\n- VBROADCASTSS supports 128-bit, 256-bit, and 512-bit versions\n- VBROADCASTSD supports 256-bit and 512-bit versions\n- VBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2 support both 256-bit and 512-bit versions\n- VBROADCASTF32X8 and VBROADCASTF64X4 are only supported in 512-bit versions\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTF128",
    "Brief": "Load with Broadcast 128-bit Floating-Point Data",
    "Description": "\nVBROADCAST instructions load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).\n\nVEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.\n\nDifferent variants of VBROADCAST instructions support different granularities and vector lengths:\n- VBROADCASTSS supports 128-bit, 256-bit, and 512-bit versions\n- VBROADCASTSD supports 256-bit and 512-bit versions\n- VBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2 support both 256-bit and 512-bit versions\n- VBROADCASTF32X8 and VBROADCASTF64X4 are only supported in 512-bit versions\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTF32X2",
    "Brief": "Load with Broadcast Two Single Precision Floating-Point Elements",
    "Description": "\nVBROADCAST instructions load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).\n\nVEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.\n\nDifferent variants of VBROADCAST instructions support different granularities and vector lengths:\n- VBROADCASTSS supports 128-bit, 256-bit, and 512-bit versions\n- VBROADCASTSD supports 256-bit and 512-bit versions\n- VBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2 support both 256-bit and 512-bit versions\n- VBROADCASTF32X8 and VBROADCASTF64X4 are only supported in 512-bit versions\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTF32X4",
    "Brief": "Load with Broadcast Four Single Precision Floating-Point Elements",
    "Description": "\nVBROADCAST instructions load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).\n\nVEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.\n\nDifferent variants of VBROADCAST instructions support different granularities and vector lengths:\n- VBROADCASTSS supports 128-bit, 256-bit, and 512-bit versions\n- VBROADCASTSD supports 256-bit and 512-bit versions\n- VBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2 support both 256-bit and 512-bit versions\n- VBROADCASTF32X8 and VBROADCASTF64X4 are only supported in 512-bit versions\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTF64X2",
    "Brief": "Load with Broadcast Two Double Precision Floating-Point Elements",
    "Description": "\nVBROADCAST instructions load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).\n\nVEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.\n\nDifferent variants of VBROADCAST instructions support different granularities and vector lengths:\n- VBROADCASTSS supports 128-bit, 256-bit, and 512-bit versions\n- VBROADCASTSD supports 256-bit and 512-bit versions\n- VBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2 support both 256-bit and 512-bit versions\n- VBROADCASTF32X8 and VBROADCASTF64X4 are only supported in 512-bit versions\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTF32X8",
    "Brief": "Load with Broadcast Eight Single Precision Floating-Point Elements",
    "Description": "\nVBROADCAST instructions load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).\n\nVEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.\n\nDifferent variants of VBROADCAST instructions support different granularities and vector lengths:\n- VBROADCASTSS supports 128-bit, 256-bit, and 512-bit versions\n- VBROADCASTSD supports 256-bit and 512-bit versions\n- VBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2 support both 256-bit and 512-bit versions\n- VBROADCASTF32X8 and VBROADCASTF64X4 are only supported in 512-bit versions\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTF64X4",
    "Brief": "Load with Broadcast Four Double Precision Floating-Point Elements",
    "Description": "\nVBROADCAST instructions load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).\n\nVEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.\n\nEVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.\n\nDifferent variants of VBROADCAST instructions support different granularities and vector lengths:\n- VBROADCASTSS supports 128-bit, 256-bit, and 512-bit versions\n- VBROADCASTSD supports 256-bit and 512-bit versions\n- VBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2 support both 256-bit and 512-bit versions\n- VBROADCASTF32X8 and VBROADCASTF64X4 are only supported in 512-bit versions\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCMPPH",
    "Brief": "Compare packed FP16 values and store result in mask register",
    "Description": "\nThis instruction compares packed FP16 values from source operands and stores the result in the destination mask operand. The comparison predicate operand (immediate byte bits 4:0) specifies the type of comparison performed on each of the pairs of packed values. The destination elements are updated according to the writemask.\n\nThe instruction supports multiple comparison predicates, including:\n- Equal (EQ)\n- Less Than (LT)\n- Less or Equal (LE)\n- Not Equal (NEQ)\n- Greater Than (GT)\n- Greater or Equal (GE)\n- Unordered\n- Ordered\n\nThese comparisons can be performed with different semantics such as signaling (S), quiet (Q), and with specific handling of NaN and sign bits. The exact comparison is determined by the 5-bit immediate value passed to the instruction.\n\nThe instruction can operate on 128-bit (4 elements), 256-bit (8 elements), or 512-bit (16 elements) vector registers, with support for write masking and optional broadcast of a single value.\n",
    "Alias": []
  },
  {
    "Name": "VCMPSH",
    "Brief": "Compare Scalar FP16 Values",
    "Description": "\nThis instruction compares the FP16 values from the lowest element of the source operands and stores the result in the destination mask operand. The comparison predicate operand (immediate byte bits 4:0) specifies the type of comparison performed on the pair of packed FP16 values. The low destination bit is updated according to the writemask. Bits MAXKL-1:1 of the destination operand are zeroed.\n\nThe instruction supports multiple comparison predicates, including:\n- Equal (EQ)\n- Less Than (LT)\n- Less Than or Equal (LE)\n- Not Equal (NEQ)\n- Greater Than (GT)\n- Greater Than or Equal (GE)\n- Unordered/Ordered comparisons\n\nThese comparisons can be performed with different semantic variations like:\n- Quiet (Q) vs Signaling (S)\n- Ordered (O) vs Unordered (U)\n\nThe specific comparison type is selected using a 5-bit immediate value that determines the exact comparison semantics.\n",
    "Alias": []
  },
  {
    "Name": "VCOMISH",
    "Brief": "Compare Scalar Ordered FP16 Values and Set EFLAGS",
    "Description": "\nThis instruction compares the FP16 values in the low word of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\n\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 16-bit memory location.\n\nThe VCOMISH instruction differs from the VUCOMISH instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The VUCOMISH instruction signals an invalid numeric exception only if a source operand is an SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated. EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCOMPRESSPD",
    "Brief": "Store Sparse Packed Double Precision Floating-Point Values Into Dense Memory",
    "Description": "\nCompress (store) up to 8 double precision floating-point values from the source operand (the second operand) as a contiguous vector to the destination operand (the first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\n\nThe opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 8 active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the destination starting from the low element of the destination operand.\n\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.\n\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector.\n",
    "Alias": []
  },
  {
    "Name": "VCOMPRESSPS",
    "Brief": "Store Sparse Packed Single Precision Floating-Point Values Into Dense Memory",
    "Description": "\nCompress (stores) up to 16 single precision floating-point values from the source operand (the second operand) to the destination operand (the first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\n\nThe opmask register k1 selects the active elements (a partial vector or possibly non-contiguous if less than 16 active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the destination starting from the low element of the destination operand.\n\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.\n\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector.\n",
    "Alias": []
  },
  {
    "Name": "VPCOMPRESSB",
    "Brief": "Store sparse packed byte integer values into dense memory/register",
    "Description": "\nCompress (stores) up to 64 byte values or 32 word values from the source operand (second operand) to the destination operand (first operand), based on the active elements determined by the writemask operand.\n\nMoves up to 512 bits of packed byte or word values from the source operand to the destination operand. This instruction is used to store partial contents of a vector register into a byte or word vector or single memory location using the active elements in operand writemask.\n\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.\n\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.\n\nThis instruction supports memory fault suppression. The compressed displacement assumes a pre-scaling corresponding to the size of one single element instead of the size of the full vector.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VPCOMPRESSW",
    "Brief": "Store sparse packed word integer values into dense memory/register",
    "Description": "\nCompress (stores) up to 64 byte values or 32 word values from the source operand (second operand) to the destination operand (first operand), based on the active elements determined by the writemask operand.\n\nMoves up to 512 bits of packed byte or word values from the source operand to the destination operand. This instruction is used to store partial contents of a vector register into a byte or word vector or single memory location using the active elements in operand writemask.\n\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.\n\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.\n\nThis instruction supports memory fault suppression. The compressed displacement assumes a pre-scaling corresponding to the size of one single element instead of the size of the full vector.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTDQ2PH",
    "Brief": "Convert packed signed doubleword integers to packed FP16 values",
    "Description": "\nThis instruction converts four, eight, or sixteen packed signed doubleword integers in the source operand to four, eight, or sixteen packed FP16 values in the destination operand.\n\nEVEX encoded versions: The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcast from a 32-bit memory location. The destination operand is a YMM/XMM register conditionally updated with writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nIf the result of the convert operation is overflow and MXCSR.OM=0 then a SIMD exception will be raised with OE=1, PE=1.\n",
    "Alias": []
  },
  {
    "Name": "VCVTNE2PS2BF16",
    "Brief": "Convert two packed single data to one packed BF16 data",
    "Description": "\nConverts two SIMD registers of packed single data into a single register of packed BF16 data.\n\nThis instruction does not support memory fault suppression.\n\nThis instruction uses \"Round to nearest (even)\" rounding mode. Output denormals are always flushed to zero and input denormals are always treated as zero. MXCSR is not consulted nor updated. No floating-point exceptions are generated.\n\nThe instruction supports different vector lengths (128, 256, and 512 bits) and can operate with write masks and broadcast modes. The conversion is performed by taking elements from the second source (src2) for the first half of the destination, and elements from the first source (src1) for the second half of the destination.\n",
    "Alias": []
  },
  {
    "Name": "VCVTNEPS2BF16",
    "Brief": "Convert Packed Single Data to Packed BF16 Data",
    "Description": "\nConverts one SIMD register of packed single data into a single register of packed BF16 data.\n\nThis instruction uses \"Round to nearest (even)\" rounding mode. Output denormals are always flushed to zero and input denormals are always treated as zero. MXCSR is not consulted nor updated.\n\nAs the instruction operand encoding table shows, the EVEX.vvvv field is not used for encoding an operand. EVEX.vvvv is reserved and must be 0b1111 otherwise instructions will #UD.\n\nThe conversion process involves several special cases:\n- Zero or denormal inputs are converted to sign-preserving zero\n- Infinity inputs are converted by taking the upper 16 bits\n- NaN inputs are truncated and the most significant bit of the mantissa is set to force a Quiet NaN\n- Normal numbers are rounded using a specific rounding bias method\n\nThe instruction supports different register sizes (128, 256, and 512 bits) and includes optional write masking and zero-masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPD2PH",
    "Brief": "Convert packed double precision floating-point values to packed FP16 values",
    "Description": "\nThis instruction converts two, four, or eight packed double precision floating-point values in the source operand (second operand) to two, four, or eight packed FP16 values in the destination operand (first operand). When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasts from a 64-bit memory location. The destination operand is a XMM register conditionally updated with writemask k1. The upper bits (MAXVL-1:128/64/32) of the corresponding destination are zeroed.\n\nEVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\n\nThis instruction uses MXCSR.DAZ for handling FP64 inputs. FP16 outputs can be normal or denormal, and are not conditionally flushed to zero.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPD2QQ",
    "Brief": "Convert packed double precision floating-point values to packed quadword integers",
    "Description": "\nConverts packed double precision floating-point values in the source operand (second operand) to packed quadword integers in the destination operand (first operand).\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2^w - 1, where w represents the number of bits in the destination format) is returned.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPD2UDQ",
    "Brief": "Convert packed double precision floating-point values to packed unsigned doubleword integers",
    "Description": "\nConverts packed double precision floating-point values in the source operand (the second operand) to packed unsigned doubleword integers in the destination operand (the first operand).\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nThe source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPD2UQQ",
    "Brief": "Convert packed double precision floating-point values to packed unsigned quadword integers",
    "Description": "\nConverts packed double precision floating-point values in the source operand (second operand) to packed unsigned quadword integers in the destination operand (first operand).\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nThe source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nThe instruction supports three vector lengths: 128-bit (two values), 256-bit (four values), and 512-bit (eight values). The conversion can use either the MXCSR rounding mode or embedded rounding control, depending on the specific encoding.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2DQ",
    "Brief": "Convert packed FP16 values to signed doubleword integers",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to signed doubleword integers in destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports three different vector lengths:\n1. 128-bit: Converts 4 FP16 values to 4 signed doubleword integers\n2. 256-bit: Converts 8 FP16 values to 8 signed doubleword integers\n3. 512-bit: Converts 16 FP16 values to 16 signed doubleword integers\n\nRounding can be controlled either by the MXCSR register or by embedded rounding control bits depending on the specific instruction variant.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2PD",
    "Brief": "Convert packed FP16 values to FP64 values",
    "Description": "\nThis instruction converts packed FP16 values to FP64 values in the destination register. The destination elements are updated according to the writemask.\n\nThe instruction handles both normal and denormal FP16 inputs. The conversion is done using the following steps:\n- For 128-bit version: Converts 2 FP16 values to 2 FP64 values\n- For 256-bit version: Converts 4 FP16 values to 4 FP64 values\n- For 512-bit version: Converts 8 FP16 values to 8 FP64 values\n\nThe conversion supports:\n- Memory or register sources\n- Broadcast mode for memory sources\n- Writemask for selective destination updates\n- Optional zeroing of destination elements not selected by the writemask\n\nThe instruction is part of the AVX512-FP16 instruction set and provides precise conversion of half-precision floating-point values to double-precision floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2PS",
    "Brief": "Convert packed FP16 values to single precision floating-point values",
    "Description": "\nThis instruction converts packed half precision (16-bits) floating-point values in the low-order bits of the source operand (the second operand) to packed single precision floating-point values and writes the converted values into the destination operand (the first operand).\n\nIf case of a denormal operand, the correct normal result is returned. MXCSR.DAZ is ignored and is treated as if it 0. No denormal exception is reported on MXCSR.\n\nVEX.128 version: The source operand is a XMM register or 64-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 version: The source operand is a XMM register or 128-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nThe VCVTPH2PSX instruction is a new form of the PH to PS conversion instruction, encoded in map 6. The previous version of the instruction, VCVTPH2PS, that is present in AVX512F (encoded in map 2, 0F38) does not support embedded broadcasting. The VCVTPH2PSX instruction has the embedded broadcasting option available.\n\nThe instructions associated with AVX512_FP16 always handle FP16 denormal number inputs; denormal inputs are not treated as zero.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2PSX",
    "Brief": "Convert packed FP16 values to single precision floating-point values with broadcast and embedded conversion",
    "Description": "\nThis instruction converts packed half precision (16-bits) floating-point values in the low-order bits of the source operand (the second operand) to packed single precision floating-point values and writes the converted values into the destination operand (the first operand).\n\nIf case of a denormal operand, the correct normal result is returned. MXCSR.DAZ is ignored and is treated as if it 0. No denormal exception is reported on MXCSR.\n\nVEX.128 version: The source operand is a XMM register or 64-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 version: The source operand is a XMM register or 128-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nThe VCVTPH2PSX instruction is a new form of the PH to PS conversion instruction, encoded in map 6. The previous version of the instruction, VCVTPH2PS, that is present in AVX512F (encoded in map 2, 0F38) does not support embedded broadcasting. The VCVTPH2PSX instruction has the embedded broadcasting option available.\n\nThe instructions associated with AVX512_FP16 always handle FP16 denormal number inputs; denormal inputs are not treated as zero.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2QQ",
    "Brief": "Convert packed FP16 values to signed quadword integer values",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to signed quadword integers in destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value is returned.\n\nThe destination elements are updated according to the writemask.\n\nSupported variants:\n- EVEX.128: Convert two packed FP16 values to two signed quadword integers\n- EVEX.256: Convert four packed FP16 values to four signed quadword integers\n- EVEX.512: Convert eight packed FP16 values to eight signed quadword integers\n\nThe instruction supports various rounding modes and write mask options for flexible conversion of half-precision floating-point values to 64-bit signed integers.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2UDQ",
    "Brief": "Convert Packed FP16 Values to Unsigned Doubleword Integers",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to unsigned doubleword integers in the destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports three vector length variants:\n1. 128-bit: Converts 4 FP16 values to 4 unsigned doubleword integers\n2. 256-bit: Converts 8 FP16 values to 8 unsigned doubleword integers\n3. 512-bit: Converts 16 FP16 values to 16 unsigned doubleword integers\n\nRounding can be controlled either by the MXCSR register or by embedded rounding control bits depending on the specific instruction encoding.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2UQQ",
    "Brief": "Convert packed FP16 values to unsigned quadword integers",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to unsigned quadword integers in destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports three vector lengths:\n- 128-bit: Converts two packed FP16 values to two unsigned quadword integers\n- 256-bit: Converts four packed FP16 values to four unsigned quadword integers\n- 512-bit: Converts eight packed FP16 values to eight unsigned quadword integers\n\nThe conversion can be performed using memory source, broadcast, and supports write masking and zeroing masking.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2UW",
    "Brief": "Convert packed FP16 values to unsigned word integers",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to unsigned word integers in the destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports three vector length variants:\n1. 128-bit: Converts 8 FP16 values to 8 unsigned 16-bit integers\n2. 256-bit: Converts 16 FP16 values to 16 unsigned 16-bit integers\n3. 512-bit: Converts 32 FP16 values to 32 unsigned 16-bit integers\n\nRounding can be controlled by the MXCSR register or embedded rounding control bits, depending on the instruction encoding.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPH2W",
    "Brief": "Convert packed FP16 values to signed word integers",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to signed word integers in the destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports three vector length variants:\n1. 128-bit (XMM register): Converts 8 FP16 values to 8 signed 16-bit integers\n2. 256-bit (YMM register): Converts 16 FP16 values to 16 signed 16-bit integers\n3. 512-bit (ZMM register): Converts 32 FP16 values to 32 signed 16-bit integers\n\nThe instruction can use either the MXCSR rounding control or embedded rounding control depending on the specific variant and operand type.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPS2PH",
    "Brief": "Convert single-precision floating-point values to half-precision (16-bit) floating-point values",
    "Description": "\nConvert packed single-precision floating values in the source operand to half-precision (16-bit) floating-point values and store to the destination operand. The rounding mode is specified using the immediate field (imm8).\n\nUnderflow results (i.e., tiny results) are converted to denormals. MXCSR.FTZ is ignored. If a source element is denormal relative to the input format with DM masked and at least one of PM or UM unmasked; a SIMD exception will be raised with DE, UE and PE set.\n\nVEX.128 version: The source operand is a XMM register. The destination operand is a XMM register or 64-bit memory location. If the destination operand is a register then the upper bits (MAXVL-1:64) of corresponding register are zeroed.\n\nVEX.256 version: The source operand is a YMM register. The destination operand is a XMM register or 128-bit memory location. If the destination operand is a register, the upper bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit memory location, conditionally updated with writemask k1. Bits (MAXVL-1:256/128/64) of the corresponding destination register are zeroed.\n\nThe immediate byte defines several bit fields that control rounding operation:\n- Bits [1:0] control rounding mode (round to nearest even, round down, round up, or truncate)\n- Bit [2] determines whether to use the immediate rounding control or MXCSR.RC\n",
    "Alias": []
  },
  {
    "Name": "VCVTPS2PHX",
    "Brief": "Convert packed single precision floating-point values to packed FP16 values",
    "Description": "\nThis instruction converts packed single precision floating values in the source operand to FP16 values and stores to the destination operand.\n\nThe VCVTPS2PHX instruction supports broadcasting.\n\nThis instruction uses MXCSR.DAZ for handling FP32 inputs. FP16 outputs can be normal or denormal numbers, and are not conditionally flushed based on MXCSR settings.\n\nThe instruction provides different variants for converting:\n- 4 single precision values to FP16 in 128-bit registers\n- 8 single precision values to FP16 in 256-bit registers\n- 16 single precision values to FP16 in 512-bit registers\n\nThe conversion supports:\n- Writemask operations\n- Optional broadcasting from a single value\n- Rounding mode selection from MXCSR or explicit rounding\n",
    "Alias": []
  },
  {
    "Name": "VCVTPS2QQ",
    "Brief": "Convert packed single precision floating-point values to packed signed quadword integer values",
    "Description": "\nConverts eight packed single precision floating-point values in the source operand to eight signed quadword integers in the destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2^w-1, where w represents the number of bits in the destination format) is returned.\n\nThe source operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPS2UDQ",
    "Brief": "Convert packed single precision floating-point values to packed unsigned doubleword integer values",
    "Description": "\nConverts sixteen packed single precision floating-point values in the source operand to sixteen unsigned double-word integers in the destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nThe source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTPS2UQQ",
    "Brief": "Convert packed single precision floating-point values to packed unsigned quadword integer values",
    "Description": "\nConverts up to eight packed single precision floating-point values in the source operand to unsigned quadword integers in the destination operand.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nThe source operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTQQ2PD",
    "Brief": "Convert packed quadword integers to packed double precision floating-point values",
    "Description": "\nConverts packed quadword integers in the source operand (second operand) to packed double precision floating-point values in the destination operand (first operand).\n\nThe source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nKey points:\n- EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD\n- Supports three register/memory size variants:\n  1. 128-bit: Converts two quadword integers\n  2. 256-bit: Converts four quadword integers\n  3. 512-bit: Converts eight quadword integers\n- Supports both merging and zeroing write masks\n- Rounding mode can be set by EVEX.RC or MXCSR.RC depending on operand type\n",
    "Alias": []
  },
  {
    "Name": "VCVTQQ2PH",
    "Brief": "Convert packed signed quadword integers to packed FP16 values",
    "Description": "\nThis instruction converts packed signed quadword integers in the source operand to packed FP16 values in the destination operand. The destination elements are updated according to the writemask.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nIf the result of the convert operation is overflow and MXCSR.OM=0 then a SIMD exception will be raised with OE=1, PE=1.\n\nThe instruction supports different vector lengths:\n- 128-bit: Convert two packed signed quadword integers to packed FP16 values\n- 256-bit: Convert four packed signed quadword integers to packed FP16 values\n- 512-bit: Convert eight packed signed quadword integers to packed FP16 values\n\nThe conversion can use either the MXCSR rounding mode or a specified rounding mode, and supports write masking and zeroing masking.\n",
    "Alias": []
  },
  {
    "Name": "VCVTQQ2PS",
    "Brief": "Convert packed quadword integers to packed single precision floating-point values",
    "Description": "\nConverts packed quadword integers in the source operand (second operand) to packed single precision floating-point values in the destination operand (first operand).\n\nThe source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a YMM/XMM/XMM (lower 64 bits) register conditionally updated with writemask k1.\n\nThere are three variants of the instruction:\n1. EVEX.128: Converts two packed quadword integers to single precision floating-point values\n2. EVEX.256: Converts four packed quadword integers to single precision floating-point values\n3. EVEX.512: Converts eight packed quadword integers to single precision floating-point values\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nThe conversion process supports both merging-masking and zeroing-masking with the writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VCVTSD2SH",
    "Brief": "Convert low FP64 value to an FP16 value",
    "Description": "\nThis instruction converts the low FP64 value in the second source operand to an FP16 value, and stores the result in the low element of the destination operand.\n\nWhen the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nThe instruction supports rounding and can be used with write masks, allowing for flexible conversion of double-precision floating-point values to half-precision floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VCVTSD2USI",
    "Brief": "Convert scalar double precision floating-point value to unsigned integer",
    "Description": "\nConverts a double precision floating-point value in the source operand (the second operand) to an unsigned doubleword integer in the destination operand (the first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double precision floating-point value is contained in the low quadword of the register.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nThe instruction supports two variants:\n1. Converting to a 32-bit unsigned integer (r32)\n2. Converting to a 64-bit unsigned integer (r64), with zero-extension in 64-bit mode\n",
    "Alias": []
  },
  {
    "Name": "VCVTSH2SD",
    "Brief": "Convert low FP16 value to an FP64 value",
    "Description": "\nThis instruction converts the low FP16 element in the second source operand to a FP64 element in the low element of the destination operand.\n\nBits 127:64 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP64 element of the destination is updated according to the writemask.\n\nThe instruction is encoded with EVEX.LLIG.F3.MAP5.W0 and supports the AVX512-FP16 feature. It allows conversion of a 16-bit floating-point value to a 64-bit floating-point value with optional write masking and rounding modes.\n",
    "Alias": []
  },
  {
    "Name": "VCVTSH2SI",
    "Brief": "Convert low FP16 value to signed integer",
    "Description": "\nThis instruction converts the low FP16 element in the source operand to a signed integer in the destination general purpose register.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer indefinite value is returned.\n\nTwo variants of the instruction exist:\n1. Converting to a 32-bit signed integer (r32)\n2. Converting to a 64-bit signed integer (r64) in 64-bit mode\n\nThe conversion uses either the MXCSR rounding control or embedded rounding control depending on the source operand type.\n",
    "Alias": []
  },
  {
    "Name": "VCVTSH2SS",
    "Brief": "Convert low FP16 value to FP32 value",
    "Description": "\nThis instruction converts the low FP16 element in the second source operand to the low FP32 element of the destination operand.\n\nBits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nKey characteristics:\n- Converts a single 16-bit floating-point value to a 32-bit floating-point value\n- Preserves upper bits from the first source operand\n- Supports write masking for conditional conversion\n- Part of the AVX512-FP16 instruction set\n",
    "Alias": []
  },
  {
    "Name": "VCVTSH2USI",
    "Brief": "Convert low FP16 value to unsigned integer",
    "Description": "\nThis instruction converts the low FP16 element in the source operand to an unsigned integer in the destination general purpose register.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer indefinite value is returned.\n\nThe instruction supports conversion to both 32-bit and 64-bit unsigned integers, depending on the operand size and mode. In 64-bit mode with a 64-bit operand size, it converts the low FP16 element to a 64-bit unsigned integer. In other cases, it converts to a 32-bit unsigned integer.\n\nRounding is controlled either by the MXCSR register's rounding control bits or by embedded rounding control bits when the source is a register with broadcast enabled.\n",
    "Alias": []
  },
  {
    "Name": "VCVTSI2SH",
    "Brief": "Convert a signed doubleword/quadword integer to an FP16 value",
    "Description": "\nThis instruction converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the second source operand to an FP16 value in the destination operand. The result is stored in the low word of the destination operand. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or embedded rounding controls.\n\nThe second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers. Bits 127:16 of the XMM register destination are copied from corresponding bits in the first source operand. Bits MAXVL-1:128 of the destination register are zeroed.\n\nIf the result of the convert operation is overflow and MXCSR.OM=0 then a SIMD exception will be raised with OE=1, PE=1.\n",
    "Alias": []
  },
  {
    "Name": "VCVTSS2SH",
    "Brief": "Convert low FP32 value to an FP16 value",
    "Description": "\nThis instruction converts the low FP32 value in the second source operand to a FP16 value in the low element of the destination operand.\n\nWhen the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nThe instruction uses different rounding modes:\n- If the second source is a register and EVEX.b = 1, it uses the rounding mode specified in EVEX.RC\n- Otherwise, it uses the rounding mode from MXCSR.RC\n\nThe conversion can handle various floating-point scenarios, including potentially generating exceptions for invalid, underflow, overflow, precision, and denormal conditions.\n",
    "Alias": []
  },
  {
    "Name": "VCVTSS2USI",
    "Brief": "Convert scalar single precision floating-point value to unsigned integer",
    "Description": "\nConverts a single precision floating-point value in the source operand (the second operand) to an unsigned double-word integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand (the first operand). \n\nThe source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single precision floating-point value is contained in the low doubleword of the register.\n\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nVEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPD2QQ",
    "Brief": "Convert packed double precision floating-point values to packed quadword integers with truncation",
    "Description": "\nConverts with truncation packed double precision floating-point values in the source operand (second operand) to packed quadword integers in the destination operand (first operand).\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2^w-1, where w represents the number of bits in the destination format) is returned.\n\nNote: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPD2UDQ",
    "Brief": "Convert packed double precision floating-point values to packed unsigned doubleword integers with truncation",
    "Description": "\nConverts with truncation packed double precision floating-point values in the source operand (the second operand) to packed unsigned doubleword integers in the destination operand (the first operand).\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nThe source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\n\nNote: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPD2UQQ",
    "Brief": "Convert packed double precision floating-point values to packed unsigned quadword integers with truncation",
    "Description": "\nConverts with truncation packed double precision floating-point values in the source operand (second operand) to packed unsigned quadword integers in the destination operand (first operand).\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPH2DQ",
    "Brief": "Convert packed FP16 values to signed doubleword integers with truncation",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to signed doubleword integers in destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value is returned.\n\nThe destination elements are updated according to the writemask.\n\nSupported variants:\n- EVEX.128: Convert 4 FP16 values to 4 signed doubleword integers\n- EVEX.256: Convert 8 FP16 values to 8 signed doubleword integers\n- EVEX.512: Convert 16 FP16 values to 16 signed doubleword integers\n\nThe instruction can use broadcast mode and supports writemask and zero-masking.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPH2QQ",
    "Brief": "Convert with Truncation Packed FP16 Values to Signed Quadword Integers",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to signed quadword integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports different vector lengths:\n- 128-bit: Converts two packed FP16 values to two signed quadword integers\n- 256-bit: Converts four packed FP16 values to four signed quadword integers\n- 512-bit: Converts eight packed FP16 values to eight signed quadword integers\n\nThe conversion uses truncation, meaning it always rounds toward zero when converting floating-point values to integers.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPH2UDQ",
    "Brief": "Convert packed FP16 values to unsigned doubleword integers with truncation",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to unsigned doubleword integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer indefinite value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports three vector lengths:\n- 128-bit: Converts 4 FP16 values to 4 unsigned doubleword integers\n- 256-bit: Converts 8 FP16 values to 8 unsigned doubleword integers\n- 512-bit: Converts 16 FP16 values to 16 unsigned doubleword integers\n\nThe conversion uses truncation (round toward zero) and supports optional write masking and broadcasting.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPH2UQQ",
    "Brief": "Convert packed FP16 values to unsigned quadword integers with truncation",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to unsigned quadword integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer indefinite value is returned.\n\nThe destination elements are updated according to the writemask.\n\nVariants of the instruction exist for 128-bit, 256-bit, and 512-bit vector registers, converting 2, 4, or 8 packed FP16 values respectively to unsigned quadword integers. The instruction supports various masking and broadcasting options.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPH2UW",
    "Brief": "Convert Packed FP16 Values to Unsigned Word Integers using truncation",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to unsigned word integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer indefinite value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports three vector lengths:\n- 128-bit: Converts 8 FP16 values to 8 unsigned word integers\n- 256-bit: Converts 16 FP16 values to 16 unsigned word integers\n- 512-bit: Converts 32 FP16 values to 32 unsigned word integers\n\nThe conversion is performed using truncation, meaning the fractional part is discarded, effectively rounding toward zero.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPH2W",
    "Brief": "Convert Packed FP16 Values to Signed Word Integers using truncation",
    "Description": "\nThis instruction converts packed FP16 values in the source operand to signed word integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer indefinite value is returned.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports three vector lengths:\n- 128-bit: Converts 8 FP16 values to 8 signed word integers\n- 256-bit: Converts 16 FP16 values to 16 signed word integers\n- 512-bit: Converts 32 FP16 values to 32 signed word integers\n\nThe conversion uses truncation (round toward zero) and can be performed with optional write masking and optional source element broadcasting.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPS2QQ",
    "Brief": "Convert packed single precision floating-point values to packed signed quadword integer values with truncation",
    "Description": "\nConverts with truncation packed single precision floating-point values in the source operand to signed quadword integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2^w-1, where w represents the number of bits in the destination format) is returned.\n\nEVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64 bits) register or a 256/128/64-bit memory location. The destination operation is a vector register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nConversion specifics:\n- 128-bit version: Converts two single precision floating-point values\n- 256-bit version: Converts four single precision floating-point values\n- 512-bit version: Converts eight single precision floating-point values\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPS2UDQ",
    "Brief": "Convert packed single precision floating-point values to packed unsigned doubleword integer values with truncation",
    "Description": "\nConverts with truncation packed single precision floating-point values in the source operand to sixteen unsigned doubleword integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTPS2UQQ",
    "Brief": "Convert with truncation packed single precision floating-point values to packed unsigned quadword integer values",
    "Description": "\nConverts with truncation up to eight packed single precision floating-point values in the source operand to unsigned quadword integers in the destination operand.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nEVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64 bits) register or a 256/128/64-bit memory location. The destination operation is a vector register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTSD2USI",
    "Brief": "Convert with truncation scalar double precision floating-point value to unsigned integer",
    "Description": "\nConverts with truncation a double precision floating-point value in the source operand (the second operand) to an unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand (the first operand). \n\nThe source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double precision floating-point value is contained in the low quadword of the register.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nEVEX.W1 version: promotes the instruction to produce 64-bit data in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTSH2SI",
    "Brief": "Convert with Truncation Low FP16 Value to a Signed Integer",
    "Description": "\nThis instruction converts the low FP16 element in the source operand to a signed integer in the destination general purpose register.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer indefinite value is returned.\n\nThere are two variants of the instruction:\n1. Convert FP16 to 32-bit signed integer (in 32-bit and 64-bit modes)\n2. Convert FP16 to 64-bit signed integer (in 64-bit mode only)\n\nThe instruction supports:\n- Conversion of the low element of an XMM register or memory\n- Optional support for SAE (Suppress All Exceptions)\n- Truncation mode when converting floating-point values\n",
    "Alias": []
  },
  {
    "Name": "VCVTTSH2USI",
    "Brief": "Convert with Truncation Low FP16 Value to an Unsigned Integer",
    "Description": "\nThis instruction converts the low FP16 element in the source operand to an unsigned integer in the destination general purpose register.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer indefinite value is returned.\n\nThe instruction has two variants:\n1. For 32-bit destination register: Converts FP16 value to a 32-bit unsigned integer\n2. For 64-bit destination register: Converts FP16 value to a 64-bit unsigned integer\n\nThe conversion uses truncation, meaning the value is rounded toward zero. The instruction supports setting the SAE (Suppress All Exceptions) flag and is part of the AVX512-FP16 instruction set.\n",
    "Alias": []
  },
  {
    "Name": "VCVTTSS2USI",
    "Brief": "Convert with truncation scalar single precision floating-point value to unsigned integer",
    "Description": "\nConverts with truncation a single precision floating-point value in the source operand (the second operand) to an unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand (the first operand). \n\nThe source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single precision floating-point value is contained in the low doubleword of the register.\n\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2^w – 1 is returned, where w represents the number of bits in the destination format.\n\nEVEX.W1 version: promotes the instruction to produce 64-bit data in 64-bit mode.\n\nNote: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUDQ2PD",
    "Brief": "Convert Packed Unsigned Doubleword Integers to Packed Double Precision Floating-Point Values",
    "Description": "\nConverts packed unsigned doubleword integers in the source operand (second operand) to packed double precision floating-point values in the destination operand (first operand).\n\nThe source operand is a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nAttempt to encode this instruction with EVEX embedded rounding is ignored.\n\nNote: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nThe instruction supports different vector lengths:\n- 128-bit version converts 2 unsigned doublewords to 2 double-precision floating-point values\n- 256-bit version converts 4 unsigned doublewords to 4 double-precision floating-point values\n- 512-bit version converts 8 unsigned doublewords to 8 double-precision floating-point values\n",
    "Alias": []
  },
  {
    "Name": "VCVTUDQ2PH",
    "Brief": "Convert packed unsigned doubleword integers to packed FP16 values",
    "Description": "\nThis instruction converts packed unsigned doubleword integers in the source operand to packed FP16 values in the destination operand. The destination elements are updated according to the writemask.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nIf the result of the convert operation is overflow and MXCSR.OM=0 then a SIMD exception will be raised with OE=1, PE=1.\n\nThe instruction provides different conversion modes for 128-bit, 256-bit, and 512-bit vector lengths:\n- For 128-bit vectors: Converts 4 unsigned doubleword integers to 4 FP16 values\n- For 256-bit vectors: Converts 8 unsigned doubleword integers to 8 FP16 values\n- For 512-bit vectors: Converts 16 unsigned doubleword integers to 16 FP16 values\n\nThe conversion can use either the MXCSR rounding control or a specified rounding control for the instruction, and supports write masking and optional zero-masking.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUDQ2PS",
    "Brief": "Convert packed unsigned doubleword integers to packed single precision floating-point values",
    "Description": "\nConverts packed unsigned doubleword integers in the source operand (second operand) to single precision floating-point values in the destination operand (first operand).\n\nThe source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nThe instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and provides options for merging and zeroing masking. When the source is a memory location, it can also support broadcasting a single 32-bit value across the entire vector.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUQQ2PD",
    "Brief": "Convert packed unsigned quadword integers to packed double precision floating-point values",
    "Description": "\nConverts packed unsigned quadword integers in the source operand (second operand) to packed double precision floating-point values in the destination operand (first operand).\n\nThe source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nThere are three main variants of the instruction:\n1. EVEX.128: Converts two packed unsigned quadword integers to two double precision floating-point values\n2. EVEX.256: Converts four packed unsigned quadword integers to four double precision floating-point values\n3. EVEX.512: Converts eight packed unsigned quadword integers to eight double precision floating-point values\n\nThe instruction supports both merging and zeroing masking through the k1 writemask.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUQQ2PH",
    "Brief": "Convert packed unsigned quadword integers to packed FP16 values",
    "Description": "\nThis instruction converts packed unsigned quadword integers in the source operand to packed FP16 values in the destination operand. The destination elements are updated according to the writemask.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nIf the result of the convert operation is overflow and MXCSR.OM=0 then a SIMD exception will be raised with OE=1, PE=1.\n\nThe instruction supports three vector length variants:\n- 128-bit: Converts two packed unsigned quadword integers to FP16 values\n- 256-bit: Converts four packed unsigned quadword integers to FP16 values\n- 512-bit: Converts eight packed unsigned quadword integers to FP16 values\n\nThe conversion uses the rounding mode specified in MXCSR or explicitly set in the instruction, and supports write-masking and optional zeroing of destination elements.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUQQ2PS",
    "Brief": "Convert packed unsigned quadword integers to packed single precision floating-point values",
    "Description": "\nConverts packed unsigned quadword integers in the source operand (second operand) to single precision floating-point values in the destination operand (first operand).\n\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1.\n\nNote: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nThe instruction supports different vector lengths:\n- 128-bit: Converts 2 unsigned quadword integers to 2 single precision floating-point values\n- 256-bit: Converts 4 unsigned quadword integers to 4 single precision floating-point values\n- 512-bit: Converts 8 unsigned quadword integers to 8 single precision floating-point values\n\nSupports both merging and zeroing masking, and optional rounding mode specification for the conversion.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUSI2SD",
    "Brief": "Convert unsigned integer to scalar double precision floating-point value",
    "Description": "\nConverts an unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the second source operand to a double precision floating-point value in the destination operand. The result is stored in the low quadword of the destination operand. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n\nThe second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX.W1 version: promotes the instruction to use 64-bit input value in 64-bit mode.\n\nEVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUSI2SH",
    "Brief": "Convert unsigned doubleword or quadword integer to an FP16 value",
    "Description": "\nThis instruction converts an unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the second source operand to a FP16 value in the destination operand. The result is stored in the low word of the destination operand. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or embedded rounding controls.\n\nThe second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers. Bits 127:16 of the XMM register destination are copied from corresponding bits in the first source operand. Bits MAXVL-1:128 of the destination register are zeroed.\n\nIf the result of the convert operation is overflow and MXCSR.OM=0 then a SIMD exception will be raised with OE=1, PE=1.\n\nThe instruction supports two main variants:\n1. Converting an unsigned 32-bit integer to FP16\n2. Converting an unsigned 64-bit integer to FP16 (in 64-bit mode)\n\nRounding is controlled by either the MXCSR register or embedded rounding controls depending on the instruction encoding.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUSI2SS",
    "Brief": "Convert unsigned integer to scalar single precision floating-point value",
    "Description": "\nConverts a unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the source operand (second operand) to a single precision floating-point value in the destination operand (first operand). The source operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.\n\nThe second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX.W1 version: promotes the instruction to use 64-bit input value in 64-bit mode.\n",
    "Alias": []
  },
  {
    "Name": "VCVTUW2PH",
    "Brief": "Convert packed unsigned word integers to FP16 values",
    "Description": "\nThis instruction converts packed unsigned word integers in the source operand to FP16 values in the destination operand. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or embedded rounding controls.\n\nThe destination elements are updated according to the writemask.\n\nIf the result of the convert operation is overflow and MXCSR.OM=0 then a SIMD exception will be raised with OE=1, PE=1.\n\nThe instruction supports conversion of:\n- 8 unsigned word integers to FP16 values in 128-bit registers\n- 16 unsigned word integers to FP16 values in 256-bit registers\n- 32 unsigned word integers to FP16 values in 512-bit registers\n\nConversion is done with optional writemask and can use either MXCSR rounding control or embedded rounding controls.\n",
    "Alias": []
  },
  {
    "Name": "VCVTW2PH",
    "Brief": "Convert packed signed word integers to FP16 values",
    "Description": "\nThis instruction converts packed signed word integers in the source operand to FP16 values in the destination operand. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or embedded rounding controls.\n\nThe destination elements are updated according to the writemask.\n\nThe instruction supports conversion of:\n- Eight packed signed word integers from 128-bit source to FP16 values\n- Sixteen packed signed word integers from 256-bit source to FP16 values\n- Thirty-two packed signed word integers from 512-bit source to FP16 values\n\nRounding is controlled by either the MXCSR register's rounding control bits or embedded rounding controls, depending on the specific instruction variant.\n",
    "Alias": []
  },
  {
    "Name": "VDBPSADBW",
    "Brief": "Double Block Packed Sum-Absolute-Differences on Unsigned Bytes",
    "Description": "\nThe VDBPSADBW instruction computes packed Sum-of-Absolute-Differences (SAD) word results of unsigned bytes from two 32-bit dword elements. \n\nKey details:\n- Compute SAD word results in qword superblocks\n- Produces 4 SAD word results in each 64-bit superblock of the destination register\n- Uses an 8-bit immediate (imm8) to control dword selection within 128-bit lanes\n- Supports different vector lengths (128-bit, 256-bit, 512-bit)\n- Supports write masking and zeroing/merging masking\n\nSAD Calculation Process:\n1. Create an intermediate vector (Tmp1) by selecting dword elements from the second source operand using imm8 shuffle control\n2. Compute absolute differences between sliding dword elements in Tmp1 and stationary dword elements in the first source operand\n3. Sum these absolute differences to produce 4 SAD word results in each 64-bit superblock\n4. Store results in destination register under optional write mask\n\nThe instruction is useful for various similarity/distance computations, such as block matching in video compression or pattern recognition algorithms.\n",
    "Alias": []
  },
  {
    "Name": "VDIVPH",
    "Brief": "Divide packed FP16 values",
    "Description": "\nThis instruction divides packed FP16 values from the first source operand by the corresponding elements in the second source operand, storing the packed FP16 result in the destination operand. The destination elements are updated according to the writemask.\n\nThe instruction supports three vector lengths: 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) registers. For each register size, the instruction can divide:\n- 8 FP16 values in 128-bit mode\n- 16 FP16 values in 256-bit mode\n- 32 FP16 values in 512-bit mode\n\nThe instruction supports various operations:\n- Direct division of corresponding elements\n- Broadcast division (when source is a memory operand with broadcast)\n- Masked division with optional zeroing or merging\n\nSupported rounding modes include:\n- MXCSR rounding control for 128/256-bit operations\n- Explicit rounding control for 512-bit operations\n\nThe result is subject to standard floating-point exceptions, including:\n- Invalid operation\n- Underflow\n- Overflow\n- Precision\n- Denormal\n- Division by zero\n",
    "Alias": []
  },
  {
    "Name": "VDIVSH",
    "Brief": "Divide low FP16 value by another FP16 value",
    "Description": "\nThis instruction divides the low FP16 value from the first source operand by the corresponding value in the second source operand, storing the FP16 result in the destination operand. Bits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nWhen performing the division:\n- If EVEX.b = 1 and the second source is a register, the rounding mode is set by EVEX.RC\n- Otherwise, the rounding mode is set by MXCSR.RC\n\nIf the writemask allows (k1[0] or no writemask), the destination's low FP16 value is set to the result of the division. If zeroing masking is used and the writemask prevents the operation, the low FP16 value is set to 0.\n",
    "Alias": []
  },
  {
    "Name": "VDPBF16PS",
    "Brief": "Dot Product of BF16 Pairs Accumulated Into Packed Single Precision",
    "Description": "\nThis instruction performs a SIMD dot-product of two BF16 pairs and accumulates into a packed single precision register.\n\n\"Round to nearest even\" rounding mode is used when doing each accumulation of the FMA. Output denormals are always flushed to zero and input denormals are always treated as zero. MXCSR is not consulted nor updated.\n\nNaN propagation follows a specific priority:\n1. If src1 low is NaN\n2. If src2 low is NaN\n3. If src1 high is NaN\n4. If src2 high is NaN\n5. If srcdest is NaN\n\nThe lower part of NaN values has priority over the upper part, meaning lower NaN values will override upper part NaN values.\n\nThe instruction supports different vector lengths (128, 256, and 512 bits) and includes optional write masking and zero-masking capabilities.\n",
    "Alias": []
  },
  {
    "Name": "VERR",
    "Brief": "Verify a segment is readable from the current privilege level",
    "Description": "\nVerifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.\n\nTo set the ZF flag, the following conditions must be met:\n- The segment selector is not NULL\n- The selector must denote a descriptor within the bounds of the descriptor table (GDT or LDT)\n- The selector must denote the descriptor of a code or data segment (not a system segment or gate)\n- For VERR, the segment must be readable\n- For VERW, the segment must be a writable data segment\n- If the segment is not a conforming code segment, the segment's DPL must be greater than or equal to (have less or the same privilege as) both the CPL and the segment selector's RPL\n\nThe validation performed is the same as when a segment selector is loaded into the DS, ES, FS, or GS register, and the indicated access (read or write) is performed. This allows software to anticipate potential segment access problems.\n",
    "Alias": []
  },
  {
    "Name": "VERW",
    "Brief": "Verify a segment is writable from the current privilege level",
    "Description": "\nVerifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.\n\nTo set the ZF flag, the following conditions must be met:\n- The segment selector is not NULL\n- The selector must denote a descriptor within the bounds of the descriptor table (GDT or LDT)\n- The selector must denote the descriptor of a code or data segment (not a system segment or gate)\n- For VERR, the segment must be readable\n- For VERW, the segment must be a writable data segment\n- If the segment is not a conforming code segment, the segment's DPL must be greater than or equal to (have less or the same privilege as) both the CPL and the segment selector's RPL\n\nThe validation performed is the same as when a segment selector is loaded into the DS, ES, FS, or GS register, and the indicated access (read or write) is performed. This allows software to anticipate potential segment access problems.\n",
    "Alias": []
  },
  {
    "Name": "VEXPANDPD",
    "Brief": "Load Sparse Packed Double Precision Floating-Point Values From Dense Memory",
    "Description": "\nExpand (load) up to 8/4/2, contiguous, double precision floating-point values of the input vector in the source operand (the second operand) to sparse elements in the destination operand (the first operand) selected by the writemask k1.\n\nThe destination operand is a ZMM/YMM/XMM register, the source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\n\nThe input vector starts from the lowest element in the source operand. The writemask register k1 selects the destination elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed, depending on EVEX.z.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector.\n",
    "Alias": []
  },
  {
    "Name": "VEXPANDPS",
    "Brief": "Load Sparse Packed Single Precision Floating-Point Values From Dense Memory",
    "Description": "\nExpand (load) up to 16/8/4, contiguous, single precision floating-point values of the input vector in the source operand (the second operand) to sparse elements of the destination operand (the first operand) selected by the writemask k1.\n\nThe destination operand is a ZMM/YMM/XMM register, the source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\n\nThe input vector starts from the lowest element in the source operand. The writemask k1 selects the destination elements (a partial vector or sparse elements if less than 16 elements) to be replaced by the ascending elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed, depending on EVEX.z.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector.\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTF128",
    "Brief": "Extract 128 bits of packed floating-point values from a larger vector",
    "Description": "\nThese instructions extract a portion of packed floating-point values from a source vector and store them in a destination vector or memory location.\n\nVEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of floating-point values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or a 128-bit memory location.\n\nVEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of floating-point values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by imm8[0]. The destination may be either a vector register or a 256-bit memory location.\n\nFor EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask, which allows for conditional updates of the destination.\n\nImportant notes:\n- VEX.vvvv and EVEX.vvvv must be 1111b, otherwise an #UD exception will be raised.\n- The high 6 bits of the immediate are ignored.\n- For VEXTRACTF128 with VEX.L=0, an #UD exception will be raised.\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTF32x4",
    "Brief": "Extract 128 bits of single precision floating-point values from a larger vector",
    "Description": "\nThese instructions extract a portion of packed floating-point values from a source vector and store them in a destination vector or memory location.\n\nVEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of floating-point values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or a 128-bit memory location.\n\nVEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of floating-point values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by imm8[0]. The destination may be either a vector register or a 256-bit memory location.\n\nFor EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask, which allows for conditional updates of the destination.\n\nImportant notes:\n- VEX.vvvv and EVEX.vvvv must be 1111b, otherwise an #UD exception will be raised.\n- The high 6 bits of the immediate are ignored.\n- For VEXTRACTF128 with VEX.L=0, an #UD exception will be raised.\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTF64x2",
    "Brief": "Extract 128 bits of double precision floating-point values from a larger vector",
    "Description": "\nThese instructions extract a portion of packed floating-point values from a source vector and store them in a destination vector or memory location.\n\nVEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of floating-point values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or a 128-bit memory location.\n\nVEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of floating-point values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by imm8[0]. The destination may be either a vector register or a 256-bit memory location.\n\nFor EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask, which allows for conditional updates of the destination.\n\nImportant notes:\n- VEX.vvvv and EVEX.vvvv must be 1111b, otherwise an #UD exception will be raised.\n- The high 6 bits of the immediate are ignored.\n- For VEXTRACTF128 with VEX.L=0, an #UD exception will be raised.\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTF32x8",
    "Brief": "Extract 256 bits of single precision floating-point values from a larger vector",
    "Description": "\nThese instructions extract a portion of packed floating-point values from a source vector and store them in a destination vector or memory location.\n\nVEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of floating-point values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or a 128-bit memory location.\n\nVEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of floating-point values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by imm8[0]. The destination may be either a vector register or a 256-bit memory location.\n\nFor EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask, which allows for conditional updates of the destination.\n\nImportant notes:\n- VEX.vvvv and EVEX.vvvv must be 1111b, otherwise an #UD exception will be raised.\n- The high 6 bits of the immediate are ignored.\n- For VEXTRACTF128 with VEX.L=0, an #UD exception will be raised.\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTF64x4",
    "Brief": "Extract 256 bits of double precision floating-point values from a larger vector",
    "Description": "\nThese instructions extract a portion of packed floating-point values from a source vector and store them in a destination vector or memory location.\n\nVEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of floating-point values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or a 128-bit memory location.\n\nVEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of floating-point values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by imm8[0]. The destination may be either a vector register or a 256-bit memory location.\n\nFor EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask, which allows for conditional updates of the destination.\n\nImportant notes:\n- VEX.vvvv and EVEX.vvvv must be 1111b, otherwise an #UD exception will be raised.\n- The high 6 bits of the immediate are ignored.\n- For VEXTRACTF128 with VEX.L=0, an #UD exception will be raised.\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTI128",
    "Brief": "Extract 128 bits of integer data from a larger vector register",
    "Description": "\nThese instructions extract packed integer values from a larger vector register and store them in a smaller destination register or memory location.\n\nVEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of integer values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by the immediate byte.\n\nVEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of integer values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by the immediate byte.\n\nThe destination can be either a vector register or a memory location. For EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask.\n\nKey points:\n- The high bits of the destination register are zeroed for register destinations\n- The immediate byte determines which 128-bit or 256-bit segment is extracted\n- Supports both register and memory destinations\n- Writemask can conditionally update the destination\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTI32x4",
    "Brief": "Extract 128 bits of 32-bit integer values from a larger vector register",
    "Description": "\nThese instructions extract packed integer values from a larger vector register and store them in a smaller destination register or memory location.\n\nVEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of integer values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by the immediate byte.\n\nVEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of integer values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by the immediate byte.\n\nThe destination can be either a vector register or a memory location. For EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask.\n\nKey points:\n- The high bits of the destination register are zeroed for register destinations\n- The immediate byte determines which 128-bit or 256-bit segment is extracted\n- Supports both register and memory destinations\n- Writemask can conditionally update the destination\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTI64x2",
    "Brief": "Extract 128 bits of 64-bit integer values from a larger vector register",
    "Description": "\nThese instructions extract packed integer values from a larger vector register and store them in a smaller destination register or memory location.\n\nVEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of integer values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by the immediate byte.\n\nVEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of integer values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by the immediate byte.\n\nThe destination can be either a vector register or a memory location. For EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask.\n\nKey points:\n- The high bits of the destination register are zeroed for register destinations\n- The immediate byte determines which 128-bit or 256-bit segment is extracted\n- Supports both register and memory destinations\n- Writemask can conditionally update the destination\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTI32x8",
    "Brief": "Extract 256 bits of 32-bit integer values from a 512-bit vector register",
    "Description": "\nThese instructions extract packed integer values from a larger vector register and store them in a smaller destination register or memory location.\n\nVEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of integer values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by the immediate byte.\n\nVEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of integer values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by the immediate byte.\n\nThe destination can be either a vector register or a memory location. For EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask.\n\nKey points:\n- The high bits of the destination register are zeroed for register destinations\n- The immediate byte determines which 128-bit or 256-bit segment is extracted\n- Supports both register and memory destinations\n- Writemask can conditionally update the destination\n",
    "Alias": []
  },
  {
    "Name": "VEXTRACTI64x4",
    "Brief": "Extract 256 bits of 64-bit integer values from a 512-bit vector register",
    "Description": "\nThese instructions extract packed integer values from a larger vector register and store them in a smaller destination register or memory location.\n\nVEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of integer values from the source operand and store to the low 128-bit of the destination operand. The 128-bit data extraction occurs at a 128-bit granular offset specified by the immediate byte.\n\nVEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of integer values from the source operand and store to the low 256-bit of the destination operand. The 256-bit data extraction occurs at a 256-bit granular offset specified by the immediate byte.\n\nThe destination can be either a vector register or a memory location. For EVEX-encoded versions, the low 128-bit or 256-bit of the destination operand is updated according to a writemask.\n\nKey points:\n- The high bits of the destination register are zeroed for register destinations\n- The immediate byte determines which 128-bit or 256-bit segment is extracted\n- Supports both register and memory destinations\n- Writemask can conditionally update the destination\n",
    "Alias": []
  },
  {
    "Name": "VFCMADDCPH",
    "Brief": "Complex multiply a pair of FP16 values with complex conjugate and accumulate",
    "Description": "\nThis instruction performs a complex multiply and accumulate operation. There are normal and complex conjugate forms of the operation.\n\nThe broadcasting and masking for this operation is done on 32-bit quantities representing a pair of FP16 values.\n\nRounding is performed at every FMA (fused multiply and add) boundary. Execution occurs as if all MXCSR exceptions are masked. MXCSR status bits are updated to reflect exceptional conditions.\n\nVFCMADDCPH performs a complex multiply with the complex conjugate of the second operand, while VFMADDCPH performs a standard complex multiplication.\n\nKey characteristics:\n- Operates on packed FP16 values\n- Supports broadcasting and masking\n- Available in 128, 256, and 512-bit vector lengths\n- Requires AVX512-FP16 and AVX512VL feature flags\n- Supports various masking and rounding modes\n",
    "Alias": []
  },
  {
    "Name": "VFMADDCPH",
    "Brief": "Complex multiply a pair of FP16 values and accumulate",
    "Description": "\nThis instruction performs a complex multiply and accumulate operation. There are normal and complex conjugate forms of the operation.\n\nThe broadcasting and masking for this operation is done on 32-bit quantities representing a pair of FP16 values.\n\nRounding is performed at every FMA (fused multiply and add) boundary. Execution occurs as if all MXCSR exceptions are masked. MXCSR status bits are updated to reflect exceptional conditions.\n\nVFCMADDCPH performs a complex multiply with the complex conjugate of the second operand, while VFMADDCPH performs a standard complex multiplication.\n\nKey characteristics:\n- Operates on packed FP16 values\n- Supports broadcasting and masking\n- Available in 128, 256, and 512-bit vector lengths\n- Requires AVX512-FP16 and AVX512VL feature flags\n- Supports various masking and rounding modes\n",
    "Alias": []
  },
  {
    "Name": "VFCMADDCSH",
    "Brief": "Complex multiply a pair of FP16 values with complex conjugate and accumulate",
    "Description": "\nThis instruction performs a complex multiply and accumulate operation. There are normal and complex conjugate forms of the operation.\n\nThe masking for this operation is done on 32-bit quantities representing a pair of FP16 values.\n\nBits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nRounding is performed at every FMA (fused multiply and add) boundary. Execution occurs as if all MXCSR exceptions are masked. MXCSR status bits are updated to reflect exceptional conditions.\n\nThe VFCMADDCSH instruction uses a complex conjugate version of multiplication, while the VFMADDCSH instruction uses a standard complex multiplication.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDCSH",
    "Brief": "Complex multiply a pair of FP16 values and accumulate",
    "Description": "\nThis instruction performs a complex multiply and accumulate operation. There are normal and complex conjugate forms of the operation.\n\nThe masking for this operation is done on 32-bit quantities representing a pair of FP16 values.\n\nBits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nRounding is performed at every FMA (fused multiply and add) boundary. Execution occurs as if all MXCSR exceptions are masked. MXCSR status bits are updated to reflect exceptional conditions.\n\nThe VFCMADDCSH instruction uses a complex conjugate version of multiplication, while the VFMADDCSH instruction uses a standard complex multiplication.\n",
    "Alias": []
  },
  {
    "Name": "VFCMULCPH",
    "Brief": "Complex multiply a pair of FP16 values with complex conjugate",
    "Description": "\nThis instruction performs a complex multiply operation. There are normal and complex conjugate forms of the operation. The broadcasting and masking for this operation is done on 32-bit quantities representing a pair of FP16 values.\n\nThe VFCMULCPH instruction performs a complex multiply with the complex conjugate of the second operand, while the VFMULCPH instruction performs a standard complex multiplication.\n\nKey characteristics:\n- Operates on packed FP16 (half-precision) values\n- Supports 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) register operations\n- Supports broadcasting and masking\n- Rounding is performed at every FMA (fused multiply and add) boundary\n- Execution occurs as if all MXCSR exceptions are masked\n- MXCSR status bits are updated to reflect exceptional conditions\n\nThe instructions are part of the AVX512-FP16 instruction set and provide efficient complex number multiplication for half-precision floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFMULCPH",
    "Brief": "Complex multiply a pair of FP16 values",
    "Description": "\nThis instruction performs a complex multiply operation. There are normal and complex conjugate forms of the operation. The broadcasting and masking for this operation is done on 32-bit quantities representing a pair of FP16 values.\n\nThe VFCMULCPH instruction performs a complex multiply with the complex conjugate of the second operand, while the VFMULCPH instruction performs a standard complex multiplication.\n\nKey characteristics:\n- Operates on packed FP16 (half-precision) values\n- Supports 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) register operations\n- Supports broadcasting and masking\n- Rounding is performed at every FMA (fused multiply and add) boundary\n- Execution occurs as if all MXCSR exceptions are masked\n- MXCSR status bits are updated to reflect exceptional conditions\n\nThe instructions are part of the AVX512-FP16 instruction set and provide efficient complex number multiplication for half-precision floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFCMULCSH",
    "Brief": "Complex multiply a pair of FP16 values with complex conjugate",
    "Description": "\nThis instruction performs a complex multiply operation. There are normal and complex conjugate forms of the operation. The masking for this operation is done on 32-bit quantities representing a pair of FP16 values.\n\nBits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nRounding is performed at every FMA (fused multiply and add) boundary. Execution occurs as if all MXCSR exceptions are masked. MXCSR status bits are updated to reflect exceptional conditions.\n\nVFCMULCSH performs a complex multiply operation with complex conjugate, where the calculation involves multiplying the source values and adding/subtracting terms based on the complex number rules.\n\nVFMULCSH performs a standard complex multiply operation, where the calculation also involves multiplying the source values with different term arrangements.\n\nBoth instructions support masking, rounding, and operate on scalar half-precision (FP16) complex values.\n",
    "Alias": []
  },
  {
    "Name": "VFMULCSH",
    "Brief": "Complex multiply a pair of FP16 values",
    "Description": "\nThis instruction performs a complex multiply operation. There are normal and complex conjugate forms of the operation. The masking for this operation is done on 32-bit quantities representing a pair of FP16 values.\n\nBits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nRounding is performed at every FMA (fused multiply and add) boundary. Execution occurs as if all MXCSR exceptions are masked. MXCSR status bits are updated to reflect exceptional conditions.\n\nVFCMULCSH performs a complex multiply operation with complex conjugate, where the calculation involves multiplying the source values and adding/subtracting terms based on the complex number rules.\n\nVFMULCSH performs a standard complex multiply operation, where the calculation also involves multiplying the source values with different term arrangements.\n\nBoth instructions support masking, rounding, and operate on scalar half-precision (FP16) complex values.\n",
    "Alias": []
  },
  {
    "Name": "VFIXUPIMMPD",
    "Brief": "Fix up special packed Float64 values",
    "Description": "\nPerform fix-up of quad-word elements encoded in double precision floating-point format in the first source operand using a 32-bit, two-level look-up table specified in the corresponding quadword element of the second source operand with exception reporting specifier.\n\nThe two-level look-up table performs a fix-up of each double precision floating-point input data by decoding the input data encoding into 8 token types. A response table is defined for each token type that converts the input encoding with one of 16 response actions.\n\nThis instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source so that they match the specification. For example, it can correct results like rcp(0), where input 0 to rcp should yield INF according to the DX10 spec, but a Newton-Raphson evaluation might yield an incorrect result.\n\nIf MXCSR.DAZ is not set, denormal input elements are considered as normal inputs and do not trigger any fixup nor fault reporting.\n\nThe instruction supports fault reporting for specific conditions like zero values, one values, signaling NaN, infinities, and negative values through the immediate control byte (imm8).\n\nThe destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a memory location, or a vector broadcasted from a 64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VFIXUPIMMPS",
    "Brief": "Fix up special packed float32 values",
    "Description": "\nPerform fix-up of doubleword elements encoded in single precision floating-point format in the first source operand using a 32-bit, two-level look-up table specified in the corresponding doubleword element of the second source operand with exception reporting specifier.\n\nThe instruction is specifically designed for fixing up the results of arithmetic calculations to match specifications. For example, when computing the reciprocal of 0, the instruction can set the result to INF according to the DX10 specification, which might not be achieved through standard Newton-Raphson computation.\n\nKey characteristics:\n- Converts input data into 8 token types\n- Provides 16 possible response actions for each token type\n- Supports conditional processing using writemask\n- Can report specific exceptions like Zero Error (#ZE) and Invalid Error (#IE)\n- Handles denormal inputs based on MXCSR.DAZ setting\n- Works with 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) registers\n\nThe immediate control (imm8) allows fine-grained control over exception reporting for different input token types, such as zero values, one values, infinities, and special numbers like SNaN.\n",
    "Alias": []
  },
  {
    "Name": "VFIXUPIMMSD",
    "Brief": "Fix up special scalar Float64 value using a two-level look-up table",
    "Description": "\nPerform a fix-up of the low quadword element encoded in double precision floating-point format in the first source operand using a 32-bit, two-level look-up table specified in the low quadword element of the second source operand with exception reporting specifier.\n\nThe two-level look-up table performs a fix-up of each double precision floating-point input data by decoding the input data encoding into 8 token types. A response table is defined for each token type that converts the input encoding with one of 16 response actions.\n\nThis instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source so that they match the specification. For example, when calculating the reciprocal of 0, the instruction can set the result to INF according to the DX10 spec.\n\nIf MXCSR.DAZ is not set, denormal input elements are considered as normal inputs and do not trigger any fixup nor fault reporting.\n\nThe immediate control (imm8) is used to set the required flags reporting, supporting #ZE and #IE fault reporting for various input token types.\n\nMXCSR mask bits are ignored and treated as if all mask bits are set to masked response. If any of the imm8 bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated.\n",
    "Alias": []
  },
  {
    "Name": "VFIXUPIMMSS",
    "Brief": "Fix up a float32 number in the low doubleword element using a scalar int32 table",
    "Description": "\nPerform a fix-up of the low doubleword element encoded in single precision floating-point format in the first source operand using a 32-bit, two-level look-up table specified in the low doubleword element of the second source operand with exception reporting specifier.\n\nThe two-level look-up table performs a fix-up of the single precision floating-point input data by decoding the input data encoding into 8 token types. A response table is defined for each token type that converts the input encoding with one of 16 response actions.\n\nThis instruction is specifically intended for use in fixing up the results of arithmetic calculations to match specifications. For example, in the case of rcp(0), where input 0 to rcp should yield INF according to the DX10 spec, but a Newton-Raphson evaluation might yield an incorrect result, VFIXUPIMMSS can be used to set the result to the correct value.\n\nIf MXCSR.DAZ is not set, denormal input elements are considered as normal inputs and do not trigger any fixup nor fault reporting.\n\nThe immediate byte (imm8) is used to set the required flags reporting, supporting #ZE and #IE fault reporting.\n\nMXCSR mask bits are ignored and treated as if all mask bits are set to masked response. If any of the imm8 bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD132PD",
    "Brief": "Fused Multiply-Add of Packed Double Precision Floating-Point Values (first source operand multiplied)",
    "Description": "\nPerforms a set of SIMD multiply-add computation on packed double precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.\n\nVFMADD132PD: Multiplies the two, four or eight packed double precision floating-point values from the first source operand to the two, four or eight packed double precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nVFMADD213PD: Multiplies the two, four or eight packed double precision floating-point values from the second source operand to the two, four or eight packed double precision floating-point values in the first source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nVFMADD231PD: Multiplies the two, four or eight packed double precision floating-point values from the second source to the two, four or eight packed double precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have variations with VEX and EVEX encodings, including support for write masks and broadcast modes.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD213PD",
    "Brief": "Fused Multiply-Add of Packed Double Precision Floating-Point Values (second source operand multiplied)",
    "Description": "\nPerforms a set of SIMD multiply-add computation on packed double precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.\n\nVFMADD132PD: Multiplies the two, four or eight packed double precision floating-point values from the first source operand to the two, four or eight packed double precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nVFMADD213PD: Multiplies the two, four or eight packed double precision floating-point values from the second source operand to the two, four or eight packed double precision floating-point values in the first source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nVFMADD231PD: Multiplies the two, four or eight packed double precision floating-point values from the second source to the two, four or eight packed double precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have variations with VEX and EVEX encodings, including support for write masks and broadcast modes.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD231PD",
    "Brief": "Fused Multiply-Add of Packed Double Precision Floating-Point Values (third source operand multiplied)",
    "Description": "\nPerforms a set of SIMD multiply-add computation on packed double precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.\n\nVFMADD132PD: Multiplies the two, four or eight packed double precision floating-point values from the first source operand to the two, four or eight packed double precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nVFMADD213PD: Multiplies the two, four or eight packed double precision floating-point values from the second source operand to the two, four or eight packed double precision floating-point values in the first source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nVFMADD231PD: Multiplies the two, four or eight packed double precision floating-point values from the second source to the two, four or eight packed double precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double precision floating-point values to the destination operand (first source operand).\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have variations with VEX and EVEX encodings, including support for write masks and broadcast modes.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD132PH",
    "Brief": "Fused multiply-add of packed FP16 values (dest = dest * src3 + src2)",
    "Description": "\nThis instruction performs a packed multiply-add or negated multiply-add computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. \n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\" and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nThe destination elements are updated according to the writemask. The different variations of the instruction differ in how the operands are combined:\n\n- VFMADD132PH: dest = dest * src3 + src2\n- VFNMADD132PH: dest = -(dest * src3) + src2\n- VFMADD213PH: dest = src2 * dest + src3\n- VFNMADD213PH: dest = -(src2 * dest) + src3\n- VFMADD231PH: dest = src2 * src3 + dest\n- VFNMADD231PH: dest = -(src2 * src3) + dest\n\nThe instruction supports various vector lengths (128, 256, and 512 bits) and includes options for masking and zeroing.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD132PH",
    "Brief": "Fused negated multiply-add of packed FP16 values (dest = -(dest * src3) + src2)",
    "Description": "\nThis instruction performs a packed multiply-add or negated multiply-add computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. \n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\" and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nThe destination elements are updated according to the writemask. The different variations of the instruction differ in how the operands are combined:\n\n- VFMADD132PH: dest = dest * src3 + src2\n- VFNMADD132PH: dest = -(dest * src3) + src2\n- VFMADD213PH: dest = src2 * dest + src3\n- VFNMADD213PH: dest = -(src2 * dest) + src3\n- VFMADD231PH: dest = src2 * src3 + dest\n- VFNMADD231PH: dest = -(src2 * src3) + dest\n\nThe instruction supports various vector lengths (128, 256, and 512 bits) and includes options for masking and zeroing.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD213PH",
    "Brief": "Fused multiply-add of packed FP16 values (dest = src2 * dest + src3)",
    "Description": "\nThis instruction performs a packed multiply-add or negated multiply-add computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. \n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\" and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nThe destination elements are updated according to the writemask. The different variations of the instruction differ in how the operands are combined:\n\n- VFMADD132PH: dest = dest * src3 + src2\n- VFNMADD132PH: dest = -(dest * src3) + src2\n- VFMADD213PH: dest = src2 * dest + src3\n- VFNMADD213PH: dest = -(src2 * dest) + src3\n- VFMADD231PH: dest = src2 * src3 + dest\n- VFNMADD231PH: dest = -(src2 * src3) + dest\n\nThe instruction supports various vector lengths (128, 256, and 512 bits) and includes options for masking and zeroing.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD213PH",
    "Brief": "Fused negated multiply-add of packed FP16 values (dest = -(src2 * dest) + src3)",
    "Description": "\nThis instruction performs a packed multiply-add or negated multiply-add computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. \n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\" and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nThe destination elements are updated according to the writemask. The different variations of the instruction differ in how the operands are combined:\n\n- VFMADD132PH: dest = dest * src3 + src2\n- VFNMADD132PH: dest = -(dest * src3) + src2\n- VFMADD213PH: dest = src2 * dest + src3\n- VFNMADD213PH: dest = -(src2 * dest) + src3\n- VFMADD231PH: dest = src2 * src3 + dest\n- VFNMADD231PH: dest = -(src2 * src3) + dest\n\nThe instruction supports various vector lengths (128, 256, and 512 bits) and includes options for masking and zeroing.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD231PH",
    "Brief": "Fused multiply-add of packed FP16 values (dest = src2 * src3 + dest)",
    "Description": "\nThis instruction performs a packed multiply-add or negated multiply-add computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. \n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\" and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nThe destination elements are updated according to the writemask. The different variations of the instruction differ in how the operands are combined:\n\n- VFMADD132PH: dest = dest * src3 + src2\n- VFNMADD132PH: dest = -(dest * src3) + src2\n- VFMADD213PH: dest = src2 * dest + src3\n- VFNMADD213PH: dest = -(src2 * dest) + src3\n- VFMADD231PH: dest = src2 * src3 + dest\n- VFNMADD231PH: dest = -(src2 * src3) + dest\n\nThe instruction supports various vector lengths (128, 256, and 512 bits) and includes options for masking and zeroing.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD231PH",
    "Brief": "Fused negated multiply-add of packed FP16 values (dest = -(src2 * src3) + dest)",
    "Description": "\nThis instruction performs a packed multiply-add or negated multiply-add computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. \n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\" and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nThe destination elements are updated according to the writemask. The different variations of the instruction differ in how the operands are combined:\n\n- VFMADD132PH: dest = dest * src3 + src2\n- VFNMADD132PH: dest = -(dest * src3) + src2\n- VFMADD213PH: dest = src2 * dest + src3\n- VFNMADD213PH: dest = -(src2 * dest) + src3\n- VFMADD231PH: dest = src2 * src3 + dest\n- VFNMADD231PH: dest = -(src2 * src3) + dest\n\nThe instruction supports various vector lengths (128, 256, and 512 bits) and includes options for masking and zeroing.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD132PS",
    "Brief": "Fused Multiply-Add of Packed Single Precision Floating-Point Values (first source operand)",
    "Description": "\nPerforms a set of SIMD multiply-add computation on packed single precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.\n\nVFMADD132PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the first source operand to the four, eight or sixteen packed single precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nVFMADD213PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the four, eight or sixteen packed single precision floating-point values in the first source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nVFMADD231PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the four, eight or sixteen packed single precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nThe instructions support various register sizes (XMM, YMM, ZMM) and have different encoding variants (VEX and EVEX) with support for masking and broadcasting.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD213PS",
    "Brief": "Fused Multiply-Add of Packed Single Precision Floating-Point Values (second source operand)",
    "Description": "\nPerforms a set of SIMD multiply-add computation on packed single precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.\n\nVFMADD132PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the first source operand to the four, eight or sixteen packed single precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nVFMADD213PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the four, eight or sixteen packed single precision floating-point values in the first source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nVFMADD231PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the four, eight or sixteen packed single precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nThe instructions support various register sizes (XMM, YMM, ZMM) and have different encoding variants (VEX and EVEX) with support for masking and broadcasting.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD231PS",
    "Brief": "Fused Multiply-Add of Packed Single Precision Floating-Point Values (third source operand)",
    "Description": "\nPerforms a set of SIMD multiply-add computation on packed single precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.\n\nVFMADD132PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the first source operand to the four, eight or sixteen packed single precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nVFMADD213PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the four, eight or sixteen packed single precision floating-point values in the first source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nVFMADD231PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the four, eight or sixteen packed single precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single precision floating-point values to the destination operand (first source operand).\n\nThe instructions support various register sizes (XMM, YMM, ZMM) and have different encoding variants (VEX and EVEX) with support for masking and broadcasting.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD132SD",
    "Brief": "Multiply scalar double precision floating-point value from first source to third source, add to second source",
    "Description": "\nPerforms a SIMD multiply-add computation on the low double precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The first and second operand are XMM registers. The third source operand can be an XMM register or a 64-bit memory location.\n\nVFMADD132SD: Multiplies the low double precision floating-point value from the first source operand to the low double precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double precision floating-point values in the second source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVFMADD213SD: Multiplies the low double precision floating-point value from the second source operand to the low double precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low double precision floating-point value in the third source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVFMADD231SD: Multiplies the low double precision floating-point value from the second source to the low double precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double precision floating-point value in the first source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low quadword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD213SD",
    "Brief": "Multiply scalar double precision floating-point value from second source to first source, add to third source",
    "Description": "\nPerforms a SIMD multiply-add computation on the low double precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The first and second operand are XMM registers. The third source operand can be an XMM register or a 64-bit memory location.\n\nVFMADD132SD: Multiplies the low double precision floating-point value from the first source operand to the low double precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double precision floating-point values in the second source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVFMADD213SD: Multiplies the low double precision floating-point value from the second source operand to the low double precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low double precision floating-point value in the third source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVFMADD231SD: Multiplies the low double precision floating-point value from the second source to the low double precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double precision floating-point value in the first source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low quadword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD231SD",
    "Brief": "Multiply scalar double precision floating-point value from second source to third source, add to first source",
    "Description": "\nPerforms a SIMD multiply-add computation on the low double precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The first and second operand are XMM registers. The third source operand can be an XMM register or a 64-bit memory location.\n\nVFMADD132SD: Multiplies the low double precision floating-point value from the first source operand to the low double precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double precision floating-point values in the second source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVFMADD213SD: Multiplies the low double precision floating-point value from the second source operand to the low double precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low double precision floating-point value in the third source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVFMADD231SD: Multiplies the low double precision floating-point value from the second source to the low double precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double precision floating-point value in the first source operand, performs rounding and stores the resulting double precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low quadword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD132SH",
    "Brief": "Fused Multiply-Add of Scalar FP16 Values (dest = dest*src3+src2)",
    "Description": "\nPerforms a scalar multiply-add or negated multiply-add computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n- Supports rounding mode control through EVEX.RC or MXCSR.RC\n- Applies to AVX512-FP16 instruction set\n\nThe different variants allow flexible multiplication and addition operations with optional negation, providing versatile floating-point computation capabilities for scalar half-precision (FP16) values.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD132SH",
    "Brief": "Fused Negated Multiply-Add of Scalar FP16 Values (dest = -dest*src3+src2)",
    "Description": "\nPerforms a scalar multiply-add or negated multiply-add computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n- Supports rounding mode control through EVEX.RC or MXCSR.RC\n- Applies to AVX512-FP16 instruction set\n\nThe different variants allow flexible multiplication and addition operations with optional negation, providing versatile floating-point computation capabilities for scalar half-precision (FP16) values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD213SH",
    "Brief": "Fused Multiply-Add of Scalar FP16 Values (dest = src2*dest+src3)",
    "Description": "\nPerforms a scalar multiply-add or negated multiply-add computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n- Supports rounding mode control through EVEX.RC or MXCSR.RC\n- Applies to AVX512-FP16 instruction set\n\nThe different variants allow flexible multiplication and addition operations with optional negation, providing versatile floating-point computation capabilities for scalar half-precision (FP16) values.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD213SH",
    "Brief": "Fused Negated Multiply-Add of Scalar FP16 Values (dest = -src2*dest+src3)",
    "Description": "\nPerforms a scalar multiply-add or negated multiply-add computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n- Supports rounding mode control through EVEX.RC or MXCSR.RC\n- Applies to AVX512-FP16 instruction set\n\nThe different variants allow flexible multiplication and addition operations with optional negation, providing versatile floating-point computation capabilities for scalar half-precision (FP16) values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD231SH",
    "Brief": "Fused Multiply-Add of Scalar FP16 Values (dest = src2*src3+dest)",
    "Description": "\nPerforms a scalar multiply-add or negated multiply-add computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n- Supports rounding mode control through EVEX.RC or MXCSR.RC\n- Applies to AVX512-FP16 instruction set\n\nThe different variants allow flexible multiplication and addition operations with optional negation, providing versatile floating-point computation capabilities for scalar half-precision (FP16) values.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD231SH",
    "Brief": "Fused Negated Multiply-Add of Scalar FP16 Values (dest = -src2*src3+dest)",
    "Description": "\nPerforms a scalar multiply-add or negated multiply-add computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n- Supports rounding mode control through EVEX.RC or MXCSR.RC\n- Applies to AVX512-FP16 instruction set\n\nThe different variants allow flexible multiplication and addition operations with optional negation, providing versatile floating-point computation capabilities for scalar half-precision (FP16) values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD132SS",
    "Brief": "Fused Multiply-Add of Scalar Single Precision Floating-Point Values (first operand multiplied with third operand, then added to second operand)",
    "Description": "\nPerforms a SIMD multiply-add computation on single precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a 32-bit memory location.\n\nVFMADD132SS: Multiplies the low single precision floating-point value from the first source operand to the low single precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the second source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVFMADD213SS: Multiplies the low single precision floating-point value from the second source operand to the low single precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the third source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVFMADD231SS: Multiplies the low single precision floating-point value from the second source operand to the low single precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the first source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD213SS",
    "Brief": "Fused Multiply-Add of Scalar Single Precision Floating-Point Values (second operand multiplied with first operand, then added to third operand)",
    "Description": "\nPerforms a SIMD multiply-add computation on single precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a 32-bit memory location.\n\nVFMADD132SS: Multiplies the low single precision floating-point value from the first source operand to the low single precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the second source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVFMADD213SS: Multiplies the low single precision floating-point value from the second source operand to the low single precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the third source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVFMADD231SS: Multiplies the low single precision floating-point value from the second source operand to the low single precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the first source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMADD231SS",
    "Brief": "Fused Multiply-Add of Scalar Single Precision Floating-Point Values (second operand multiplied with third operand, then added to first operand)",
    "Description": "\nPerforms a SIMD multiply-add computation on single precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a 32-bit memory location.\n\nVFMADD132SS: Multiplies the low single precision floating-point value from the first source operand to the low single precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the second source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVFMADD213SS: Multiplies the low single precision floating-point value from the second source operand to the low single precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the third source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVFMADD231SS: Multiplies the low single precision floating-point value from the second source operand to the low single precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single precision floating-point value in the first source operand, performs rounding and stores the resulting single precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDRND231PD",
    "Brief": "Fused Multiply-Add of Packed Double-Precision Floating-Point Values with rounding control",
    "Description": "\nMultiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two or four packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).\n\nThe immediate byte defines several bit fields that control rounding, DAZ, FTZ, and exception suppression. The rounding mode specified in MXCSR.RC may be bypassed if the immediate bit called MS1 (MXCSR.RC Override) is set. Likewise, the MXCSR.FTZ and MXCSR.DAZ may also be bypassed if the immediate bit called MS2 (MXCSR.FTZ/DAZ Override) is set.\n\nIn case SAE (Suppress All Exceptions) bit is set (i.e. imm8[3] = 1), the status flags in MXCSR are not updated and no SIMD floating-point exceptions are raised. When SAE bit is not set (i.e. imm8[3] = 0) then SIMD floating-point exceptions are signaled according to the MXCSR. If any result operand is an SNaN then it will be converted to a QNaN.\n\nVEX.128 encoded version zeroes the upper 128 bits of the YMM destination register. VEX.256 encoded version uses full YMM registers.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB132PD",
    "Brief": "Fused Multiply-Alternating Add/Subtract of Packed Double Precision Floating-Point Values (132 variant)",
    "Description": "\nThese instructions perform a fused multiply-alternating add/subtract operation on packed double precision floating-point values with different operand arrangements:\n\nVFMADDSUB132PD: Multiplies the packed double precision floating-point values from the first source operand with the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the second source operand.\n\nVFMADDSUB213PD: Multiplies the packed double precision floating-point values from the second source operand with the first source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the third source operand.\n\nVFMADDSUB231PD: Multiplies the packed double precision floating-point values from the second source operand with the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the first source operand.\n\nThe EVEX encoded versions support:\n- Destination operand and second source operand as ZMM/YMM/XMM registers\n- Third source operand as a register, memory location, or broadcasted from a 64-bit memory location\n- Conditional update with write mask k1\n\nThe VEX encoded versions support 128-bit (XMM) and 256-bit (YMM) operations, with the upper bits of the destination register zeroed for 128-bit operations.\n\nThe instructions perform rounding according to the floating-point control settings and can handle various special floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB213PD",
    "Brief": "Fused Multiply-Alternating Add/Subtract of Packed Double Precision Floating-Point Values (213 variant)",
    "Description": "\nThese instructions perform a fused multiply-alternating add/subtract operation on packed double precision floating-point values with different operand arrangements:\n\nVFMADDSUB132PD: Multiplies the packed double precision floating-point values from the first source operand with the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the second source operand.\n\nVFMADDSUB213PD: Multiplies the packed double precision floating-point values from the second source operand with the first source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the third source operand.\n\nVFMADDSUB231PD: Multiplies the packed double precision floating-point values from the second source operand with the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the first source operand.\n\nThe EVEX encoded versions support:\n- Destination operand and second source operand as ZMM/YMM/XMM registers\n- Third source operand as a register, memory location, or broadcasted from a 64-bit memory location\n- Conditional update with write mask k1\n\nThe VEX encoded versions support 128-bit (XMM) and 256-bit (YMM) operations, with the upper bits of the destination register zeroed for 128-bit operations.\n\nThe instructions perform rounding according to the floating-point control settings and can handle various special floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB231PD",
    "Brief": "Fused Multiply-Alternating Add/Subtract of Packed Double Precision Floating-Point Values (231 variant)",
    "Description": "\nThese instructions perform a fused multiply-alternating add/subtract operation on packed double precision floating-point values with different operand arrangements:\n\nVFMADDSUB132PD: Multiplies the packed double precision floating-point values from the first source operand with the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the second source operand.\n\nVFMADDSUB213PD: Multiplies the packed double precision floating-point values from the second source operand with the first source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the third source operand.\n\nVFMADDSUB231PD: Multiplies the packed double precision floating-point values from the second source operand with the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the first source operand.\n\nThe EVEX encoded versions support:\n- Destination operand and second source operand as ZMM/YMM/XMM registers\n- Third source operand as a register, memory location, or broadcasted from a 64-bit memory location\n- Conditional update with write mask k1\n\nThe VEX encoded versions support 128-bit (XMM) and 256-bit (YMM) operations, with the upper bits of the destination register zeroed for 128-bit operations.\n\nThe instructions perform rounding according to the floating-point control settings and can handle various special floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB132PH",
    "Brief": "Fused Multiply-Alternating Add/Subtract of Packed FP16 Values (132 variant)",
    "Description": "\nThis instruction performs a packed multiply-add (odd elements) or multiply-subtract (even elements) computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in A * B ± C, where each digit corresponds to the operand number, with the destination being operand 1. The specific behavior for odd and even elements is as follows:\n\n- 132 variant:\n  - Odd elements: dest = dest * src3 + src2\n  - Even elements: dest = dest * src3 - src2\n\n- 213 variant:\n  - Odd elements: dest = src2 * dest + src3\n  - Even elements: dest = src2 * dest - src3\n\n- 231 variant:\n  - Odd elements: dest = src2 * src3 + dest\n  - Even elements: dest = src2 * src3 - dest\n\nThe destination elements are updated according to the writemask. The instruction supports different register sizes (128-bit, 256-bit, and 512-bit) and can work with registers or memory sources.\n\nThe instruction is part of the AVX512-FP16 instruction set and provides a fused multiply-add/subtract operation with half-precision (16-bit) floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB213PH",
    "Brief": "Fused Multiply-Alternating Add/Subtract of Packed FP16 Values (213 variant)",
    "Description": "\nThis instruction performs a packed multiply-add (odd elements) or multiply-subtract (even elements) computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in A * B ± C, where each digit corresponds to the operand number, with the destination being operand 1. The specific behavior for odd and even elements is as follows:\n\n- 132 variant:\n  - Odd elements: dest = dest * src3 + src2\n  - Even elements: dest = dest * src3 - src2\n\n- 213 variant:\n  - Odd elements: dest = src2 * dest + src3\n  - Even elements: dest = src2 * dest - src3\n\n- 231 variant:\n  - Odd elements: dest = src2 * src3 + dest\n  - Even elements: dest = src2 * src3 - dest\n\nThe destination elements are updated according to the writemask. The instruction supports different register sizes (128-bit, 256-bit, and 512-bit) and can work with registers or memory sources.\n\nThe instruction is part of the AVX512-FP16 instruction set and provides a fused multiply-add/subtract operation with half-precision (16-bit) floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB231PH",
    "Brief": "Fused Multiply-Alternating Add/Subtract of Packed FP16 Values (231 variant)",
    "Description": "\nThis instruction performs a packed multiply-add (odd elements) or multiply-subtract (even elements) computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in A * B ± C, where each digit corresponds to the operand number, with the destination being operand 1. The specific behavior for odd and even elements is as follows:\n\n- 132 variant:\n  - Odd elements: dest = dest * src3 + src2\n  - Even elements: dest = dest * src3 - src2\n\n- 213 variant:\n  - Odd elements: dest = src2 * dest + src3\n  - Even elements: dest = src2 * dest - src3\n\n- 231 variant:\n  - Odd elements: dest = src2 * src3 + dest\n  - Even elements: dest = src2 * src3 - dest\n\nThe destination elements are updated according to the writemask. The instruction supports different register sizes (128-bit, 256-bit, and 512-bit) and can work with registers or memory sources.\n\nThe instruction is part of the AVX512-FP16 instruction set and provides a fused multiply-add/subtract operation with half-precision (16-bit) floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB132PS",
    "Brief": "Fused Multiply-Alternating Add/Subtract with specific operand order",
    "Description": "\nThese instructions perform a fused multiply-alternating add/subtract operation on packed single precision floating-point values with different operand arrangements:\n\nVFMADDSUB132PS: Multiplies the packed single precision floating-point values from the first source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the second source operand, performs rounding, and stores the result in the destination operand.\n\nVFMADDSUB213PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the first source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the third source operand, performs rounding, and stores the result in the destination operand.\n\nVFMADDSUB231PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the first source operand, performs rounding, and stores the result in the destination operand.\n\nEVEX encoded versions support:\n- Destination and second source operands as ZMM/YMM/XMM registers\n- Third source operand as a register, memory location, or broadcasted from a 32-bit memory location\n- Conditional update with write mask k1\n\nThe instructions are available in 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector lengths, with variations in VEX and EVEX encoding.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB213PS",
    "Brief": "Fused Multiply-Alternating Add/Subtract with different operand order",
    "Description": "\nThese instructions perform a fused multiply-alternating add/subtract operation on packed single precision floating-point values with different operand arrangements:\n\nVFMADDSUB132PS: Multiplies the packed single precision floating-point values from the first source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the second source operand, performs rounding, and stores the result in the destination operand.\n\nVFMADDSUB213PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the first source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the third source operand, performs rounding, and stores the result in the destination operand.\n\nVFMADDSUB231PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the first source operand, performs rounding, and stores the result in the destination operand.\n\nEVEX encoded versions support:\n- Destination and second source operands as ZMM/YMM/XMM registers\n- Third source operand as a register, memory location, or broadcasted from a 32-bit memory location\n- Conditional update with write mask k1\n\nThe instructions are available in 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector lengths, with variations in VEX and EVEX encoding.\n",
    "Alias": []
  },
  {
    "Name": "VFMADDSUB231PS",
    "Brief": "Fused Multiply-Alternating Add/Subtract with another operand order",
    "Description": "\nThese instructions perform a fused multiply-alternating add/subtract operation on packed single precision floating-point values with different operand arrangements:\n\nVFMADDSUB132PS: Multiplies the packed single precision floating-point values from the first source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the second source operand, performs rounding, and stores the result in the destination operand.\n\nVFMADDSUB213PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the first source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the third source operand, performs rounding, and stores the result in the destination operand.\n\nVFMADDSUB231PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, adds the odd elements and subtracts the even elements from the first source operand, performs rounding, and stores the result in the destination operand.\n\nEVEX encoded versions support:\n- Destination and second source operands as ZMM/YMM/XMM registers\n- Third source operand as a register, memory location, or broadcasted from a 32-bit memory location\n- Conditional update with write mask k1\n\nThe instructions are available in 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector lengths, with variations in VEX and EVEX encoding.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB132PD",
    "Brief": "Multiply packed double precision floating-point values and subtract",
    "Description": "\nPerforms a set of SIMD multiply-subtract computation on packed double precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand.\n\nVFMSUB132PD: Multiplies the packed double precision floating-point values from the first source operand to the third source operand. From the infinite precision intermediate result, subtracts the values in the second source operand, performs rounding and stores the result in the destination operand.\n\nVFMSUB213PD: Multiplies the packed double precision floating-point values from the second source operand to the first source operand. From the infinite precision intermediate result, subtracts the values in the third source operand, performs rounding and stores the result in the destination operand.\n\nVFMSUB231PD: Multiplies the packed double precision floating-point values from the second source to the third source operand. From the infinite precision intermediate result, subtracts the values in the first source operand, performs rounding and stores the result in the destination operand.\n\nEVEX encoded versions support write masking and can operate on ZMM/YMM/XMM registers with optional broadcasting from a 64-bit memory location. The destination operand is conditionally updated with a write mask.\n\nVEX.128 and VEX.256 encoded versions have similar semantics but with different register sizes, and the upper bits of the destination register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB213PD",
    "Brief": "Multiply packed double precision floating-point values and subtract",
    "Description": "\nPerforms a set of SIMD multiply-subtract computation on packed double precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand.\n\nVFMSUB132PD: Multiplies the packed double precision floating-point values from the first source operand to the third source operand. From the infinite precision intermediate result, subtracts the values in the second source operand, performs rounding and stores the result in the destination operand.\n\nVFMSUB213PD: Multiplies the packed double precision floating-point values from the second source operand to the first source operand. From the infinite precision intermediate result, subtracts the values in the third source operand, performs rounding and stores the result in the destination operand.\n\nVFMSUB231PD: Multiplies the packed double precision floating-point values from the second source to the third source operand. From the infinite precision intermediate result, subtracts the values in the first source operand, performs rounding and stores the result in the destination operand.\n\nEVEX encoded versions support write masking and can operate on ZMM/YMM/XMM registers with optional broadcasting from a 64-bit memory location. The destination operand is conditionally updated with a write mask.\n\nVEX.128 and VEX.256 encoded versions have similar semantics but with different register sizes, and the upper bits of the destination register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB231PD",
    "Brief": "Multiply packed double precision floating-point values and subtract",
    "Description": "\nPerforms a set of SIMD multiply-subtract computation on packed double precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand.\n\nVFMSUB132PD: Multiplies the packed double precision floating-point values from the first source operand to the third source operand. From the infinite precision intermediate result, subtracts the values in the second source operand, performs rounding and stores the result in the destination operand.\n\nVFMSUB213PD: Multiplies the packed double precision floating-point values from the second source operand to the first source operand. From the infinite precision intermediate result, subtracts the values in the third source operand, performs rounding and stores the result in the destination operand.\n\nVFMSUB231PD: Multiplies the packed double precision floating-point values from the second source to the third source operand. From the infinite precision intermediate result, subtracts the values in the first source operand, performs rounding and stores the result in the destination operand.\n\nEVEX encoded versions support write masking and can operate on ZMM/YMM/XMM registers with optional broadcasting from a 64-bit memory location. The destination operand is conditionally updated with a write mask.\n\nVEX.128 and VEX.256 encoded versions have similar semantics but with different register sizes, and the upper bits of the destination register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB132PH",
    "Brief": "Fused Multiply-Subtract of Packed FP16 Values (dest = ±dest*src3-src2)",
    "Description": "\nThis instruction performs a packed multiply-subtract or a negated multiply-subtract computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on packed half-precision (16-bit) floating-point values\n- Supports multiple register sizes (128-bit, 256-bit, 512-bit)\n- Uses EVEX encoding with optional writemask and embedded rounding\n- Variants include standard and negated forms of multiply-subtract\n- Supports broadcast for memory operands\n- Destination elements are updated according to the writemask\n\nThe instructions can perform operations like:\n- dest = dest * src3 - src2\n- dest = -(dest * src3) - src2\n- dest = src2 * dest - src3\n- dest = -(src2 * dest) - src3\n- dest = src2 * src3 - dest\n- dest = -(src2 * src3) - dest\n\nThe instructions are part of the AVX512-FP16 instruction set and support various rounding modes and masking options.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB132PH",
    "Brief": "Negated Fused Multiply-Subtract of Packed FP16 Values (dest = ±-(dest*src3)-src2)",
    "Description": "\nThis instruction performs a packed multiply-subtract or a negated multiply-subtract computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on packed half-precision (16-bit) floating-point values\n- Supports multiple register sizes (128-bit, 256-bit, 512-bit)\n- Uses EVEX encoding with optional writemask and embedded rounding\n- Variants include standard and negated forms of multiply-subtract\n- Supports broadcast for memory operands\n- Destination elements are updated according to the writemask\n\nThe instructions can perform operations like:\n- dest = dest * src3 - src2\n- dest = -(dest * src3) - src2\n- dest = src2 * dest - src3\n- dest = -(src2 * dest) - src3\n- dest = src2 * src3 - dest\n- dest = -(src2 * src3) - dest\n\nThe instructions are part of the AVX512-FP16 instruction set and support various rounding modes and masking options.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB213PH",
    "Brief": "Fused Multiply-Subtract of Packed FP16 Values (dest = ±src2*dest-src3)",
    "Description": "\nThis instruction performs a packed multiply-subtract or a negated multiply-subtract computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on packed half-precision (16-bit) floating-point values\n- Supports multiple register sizes (128-bit, 256-bit, 512-bit)\n- Uses EVEX encoding with optional writemask and embedded rounding\n- Variants include standard and negated forms of multiply-subtract\n- Supports broadcast for memory operands\n- Destination elements are updated according to the writemask\n\nThe instructions can perform operations like:\n- dest = dest * src3 - src2\n- dest = -(dest * src3) - src2\n- dest = src2 * dest - src3\n- dest = -(src2 * dest) - src3\n- dest = src2 * src3 - dest\n- dest = -(src2 * src3) - dest\n\nThe instructions are part of the AVX512-FP16 instruction set and support various rounding modes and masking options.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB213PH",
    "Brief": "Negated Fused Multiply-Subtract of Packed FP16 Values (dest = ±-(src2*dest)-src3)",
    "Description": "\nThis instruction performs a packed multiply-subtract or a negated multiply-subtract computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on packed half-precision (16-bit) floating-point values\n- Supports multiple register sizes (128-bit, 256-bit, 512-bit)\n- Uses EVEX encoding with optional writemask and embedded rounding\n- Variants include standard and negated forms of multiply-subtract\n- Supports broadcast for memory operands\n- Destination elements are updated according to the writemask\n\nThe instructions can perform operations like:\n- dest = dest * src3 - src2\n- dest = -(dest * src3) - src2\n- dest = src2 * dest - src3\n- dest = -(src2 * dest) - src3\n- dest = src2 * src3 - dest\n- dest = -(src2 * src3) - dest\n\nThe instructions are part of the AVX512-FP16 instruction set and support various rounding modes and masking options.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB231PH",
    "Brief": "Fused Multiply-Subtract of Packed FP16 Values (dest = ±src2*src3-dest)",
    "Description": "\nThis instruction performs a packed multiply-subtract or a negated multiply-subtract computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on packed half-precision (16-bit) floating-point values\n- Supports multiple register sizes (128-bit, 256-bit, 512-bit)\n- Uses EVEX encoding with optional writemask and embedded rounding\n- Variants include standard and negated forms of multiply-subtract\n- Supports broadcast for memory operands\n- Destination elements are updated according to the writemask\n\nThe instructions can perform operations like:\n- dest = dest * src3 - src2\n- dest = -(dest * src3) - src2\n- dest = src2 * dest - src3\n- dest = -(src2 * dest) - src3\n- dest = src2 * src3 - dest\n- dest = -(src2 * src3) - dest\n\nThe instructions are part of the AVX512-FP16 instruction set and support various rounding modes and masking options.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB231PH",
    "Brief": "Negated Fused Multiply-Subtract of Packed FP16 Values (dest = ±-(src2*src3)-dest)",
    "Description": "\nThis instruction performs a packed multiply-subtract or a negated multiply-subtract computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on packed half-precision (16-bit) floating-point values\n- Supports multiple register sizes (128-bit, 256-bit, 512-bit)\n- Uses EVEX encoding with optional writemask and embedded rounding\n- Variants include standard and negated forms of multiply-subtract\n- Supports broadcast for memory operands\n- Destination elements are updated according to the writemask\n\nThe instructions can perform operations like:\n- dest = dest * src3 - src2\n- dest = -(dest * src3) - src2\n- dest = src2 * dest - src3\n- dest = -(src2 * dest) - src3\n- dest = src2 * src3 - dest\n- dest = -(src2 * src3) - dest\n\nThe instructions are part of the AVX512-FP16 instruction set and support various rounding modes and masking options.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB132PS",
    "Brief": "Fused Multiply-Subtract of Packed Single Precision Floating-Point Values (version 1)",
    "Description": "\nPerforms a set of SIMD multiply-subtract computation on packed single precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand.\n\nVFMSUB132PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the first source operand to the values in the third source operand. From the infinite precision intermediate result, subtracts the values in the second source operand, performs rounding and stores the result to the destination operand.\n\nVFMSUB213PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the values in the first source operand. From the infinite precision intermediate result, subtracts the values in the third source operand, performs rounding and stores the result to the destination operand.\n\nVFMSUB231PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source to the values in the third source operand. From the infinite precision intermediate result, subtracts the values in the first source operand, performs rounding and stores the result to the destination operand.\n\nEVEX encoded versions support conditional updates with write mask k1, and can work with register or memory sources, including broadcast from a 32-bit memory location.\n\nThe destination operand is always the first source operand, the second source operand must be a SIMD register, and the third source operand can be a SIMD register or a memory location.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB213PS",
    "Brief": "Fused Multiply-Subtract of Packed Single Precision Floating-Point Values (version 2)",
    "Description": "\nPerforms a set of SIMD multiply-subtract computation on packed single precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand.\n\nVFMSUB132PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the first source operand to the values in the third source operand. From the infinite precision intermediate result, subtracts the values in the second source operand, performs rounding and stores the result to the destination operand.\n\nVFMSUB213PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the values in the first source operand. From the infinite precision intermediate result, subtracts the values in the third source operand, performs rounding and stores the result to the destination operand.\n\nVFMSUB231PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source to the values in the third source operand. From the infinite precision intermediate result, subtracts the values in the first source operand, performs rounding and stores the result to the destination operand.\n\nEVEX encoded versions support conditional updates with write mask k1, and can work with register or memory sources, including broadcast from a 32-bit memory location.\n\nThe destination operand is always the first source operand, the second source operand must be a SIMD register, and the third source operand can be a SIMD register or a memory location.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB231PS",
    "Brief": "Fused Multiply-Subtract of Packed Single Precision Floating-Point Values (version 3)",
    "Description": "\nPerforms a set of SIMD multiply-subtract computation on packed single precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand.\n\nVFMSUB132PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the first source operand to the values in the third source operand. From the infinite precision intermediate result, subtracts the values in the second source operand, performs rounding and stores the result to the destination operand.\n\nVFMSUB213PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source operand to the values in the first source operand. From the infinite precision intermediate result, subtracts the values in the third source operand, performs rounding and stores the result to the destination operand.\n\nVFMSUB231PS: Multiplies the four, eight or sixteen packed single precision floating-point values from the second source to the values in the third source operand. From the infinite precision intermediate result, subtracts the values in the first source operand, performs rounding and stores the result to the destination operand.\n\nEVEX encoded versions support conditional updates with write mask k1, and can work with register or memory sources, including broadcast from a 32-bit memory location.\n\nThe destination operand is always the first source operand, the second source operand must be a SIMD register, and the third source operand can be a SIMD register or a memory location.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB132SD",
    "Brief": "Fused Multiply-Subtract of Scalar Double Precision Floating-Point Values (first operand, first term)",
    "Description": "\nPerforms a SIMD multiply-subtract computation on the low packed double precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand.\n\nVFMSUB132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point values in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFMSUB213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFMSUB231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nThe destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB213SD",
    "Brief": "Fused Multiply-Subtract of Scalar Double Precision Floating-Point Values (first operand, second term)",
    "Description": "\nPerforms a SIMD multiply-subtract computation on the low packed double precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand.\n\nVFMSUB132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point values in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFMSUB213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFMSUB231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nThe destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB231SD",
    "Brief": "Fused Multiply-Subtract of Scalar Double Precision Floating-Point Values (third operand)",
    "Description": "\nPerforms a SIMD multiply-subtract computation on the low packed double precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand.\n\nVFMSUB132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point values in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFMSUB213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFMSUB231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nThe destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB132SH",
    "Brief": "Fused Multiply-Subtract of Scalar FP16 Values (dest = ± dest*src3-src2)",
    "Description": "\nThis instruction performs a scalar multiply-subtract or negated multiply-subtract computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on the low FP16 element of the operand\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n\nThe different variants allow flexible multiplication and subtraction operations with optional negation, providing fine-grained control over floating-point computations for FP16 values.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB132SH",
    "Brief": "Fused Negated Multiply-Subtract of Scalar FP16 Values (dest = ± -(dest*src3-src2))",
    "Description": "\nThis instruction performs a scalar multiply-subtract or negated multiply-subtract computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on the low FP16 element of the operand\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n\nThe different variants allow flexible multiplication and subtraction operations with optional negation, providing fine-grained control over floating-point computations for FP16 values.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB213SH",
    "Brief": "Fused Multiply-Subtract of Scalar FP16 Values (dest = ± src2*dest-src3)",
    "Description": "\nThis instruction performs a scalar multiply-subtract or negated multiply-subtract computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on the low FP16 element of the operand\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n\nThe different variants allow flexible multiplication and subtraction operations with optional negation, providing fine-grained control over floating-point computations for FP16 values.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB213SH",
    "Brief": "Fused Negated Multiply-Subtract of Scalar FP16 Values (dest = ± -(src2*dest-src3))",
    "Description": "\nThis instruction performs a scalar multiply-subtract or negated multiply-subtract computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on the low FP16 element of the operand\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n\nThe different variants allow flexible multiplication and subtraction operations with optional negation, providing fine-grained control over floating-point computations for FP16 values.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB231SH",
    "Brief": "Fused Multiply-Subtract of Scalar FP16 Values (dest = ± src2*src3-dest)",
    "Description": "\nThis instruction performs a scalar multiply-subtract or negated multiply-subtract computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on the low FP16 element of the operand\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n\nThe different variants allow flexible multiplication and subtraction operations with optional negation, providing fine-grained control over floating-point computations for FP16 values.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB231SH",
    "Brief": "Fused Negated Multiply-Subtract of Scalar FP16 Values (dest = ± -(src2*src3-dest))",
    "Description": "\nThis instruction performs a scalar multiply-subtract or negated multiply-subtract computation on the low FP16 values using three source operands and writes the result in the destination operand. The destination operand is also the first source operand.\n\nThe \"N\" (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product. The notation \"132\", \"213\", and \"231\" indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1.\n\nKey characteristics:\n- Operates on the low FP16 element of the operand\n- Bits 127:16 of the destination operand are preserved\n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n\nThe different variants allow flexible multiplication and subtraction operations with optional negation, providing fine-grained control over floating-point computations for FP16 values.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB132SS",
    "Brief": "Fused Multiply-Subtract of Scalar Single Precision Floating-Point Values",
    "Description": "\nPerforms a SIMD multiply-subtract computation on the low packed single precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 32-bit memory location.\n\nVFMSUB132SS: Multiplies the low packed single precision floating-point value from the first source operand to the low packed single precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point values in the second source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVFMSUB213SS: Multiplies the low packed single precision floating-point value from the second source operand to the low packed single precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point value in the third source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVFMSUB231SS: Multiplies the low packed single precision floating-point value from the second source to the low packed single precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point value in the first source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB213SS",
    "Brief": "Fused Multiply-Subtract of Scalar Single Precision Floating-Point Values",
    "Description": "\nPerforms a SIMD multiply-subtract computation on the low packed single precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 32-bit memory location.\n\nVFMSUB132SS: Multiplies the low packed single precision floating-point value from the first source operand to the low packed single precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point values in the second source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVFMSUB213SS: Multiplies the low packed single precision floating-point value from the second source operand to the low packed single precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point value in the third source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVFMSUB231SS: Multiplies the low packed single precision floating-point value from the second source to the low packed single precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point value in the first source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUB231SS",
    "Brief": "Fused Multiply-Subtract of Scalar Single Precision Floating-Point Values",
    "Description": "\nPerforms a SIMD multiply-subtract computation on the low packed single precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 32-bit memory location.\n\nVFMSUB132SS: Multiplies the low packed single precision floating-point value from the first source operand to the low packed single precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point values in the second source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVFMSUB213SS: Multiplies the low packed single precision floating-point value from the second source operand to the low packed single precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point value in the third source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVFMSUB231SS: Multiplies the low packed single precision floating-point value from the second source to the low packed single precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single precision floating-point value in the first source operand, performs rounding and stores the resulting packed single precision floating-point value to the destination operand (first source operand).\n\nVEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.\n\nEVEX encoded version: The low doubleword element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD132PD",
    "Brief": "Fused Multiply-AlternatingSubtract/Add of packed double precision floating-point values (first operand is multiplied with third, then even/odd elements added/subtracted)",
    "Description": "\nThese instructions perform a fused multiply-alternating subtract/add operation on packed double precision floating-point values:\n\nVFMSUBADD132PD: Multiplies the two, four, or eight packed double precision floating-point values from the first source operand to the two or four packed double precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nVFMSUBADD213PD: Multiplies the two, four, or eight packed double precision floating-point values from the second source operand to the two or four packed double precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nVFMSUBADD231PD: Multiplies the two, four, or eight packed double precision floating-point values from the second source operand to the two or four packed double precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nThe instructions support VEX and EVEX encodings for 128-bit, 256-bit, and 512-bit vector operations, with support for writemasks and rounding modes in EVEX versions.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD213PD",
    "Brief": "Fused Multiply-AlternatingSubtract/Add of packed double precision floating-point values (second operand is multiplied with first, then even/odd elements added/subtracted)",
    "Description": "\nThese instructions perform a fused multiply-alternating subtract/add operation on packed double precision floating-point values:\n\nVFMSUBADD132PD: Multiplies the two, four, or eight packed double precision floating-point values from the first source operand to the two or four packed double precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nVFMSUBADD213PD: Multiplies the two, four, or eight packed double precision floating-point values from the second source operand to the two or four packed double precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nVFMSUBADD231PD: Multiplies the two, four, or eight packed double precision floating-point values from the second source operand to the two or four packed double precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nThe instructions support VEX and EVEX encodings for 128-bit, 256-bit, and 512-bit vector operations, with support for writemasks and rounding modes in EVEX versions.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD231PD",
    "Brief": "Fused Multiply-AlternatingSubtract/Add of packed double precision floating-point values (second operand is multiplied with third, then even/odd elements added/subtracted)",
    "Description": "\nThese instructions perform a fused multiply-alternating subtract/add operation on packed double precision floating-point values:\n\nVFMSUBADD132PD: Multiplies the two, four, or eight packed double precision floating-point values from the first source operand to the two or four packed double precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nVFMSUBADD213PD: Multiplies the two, four, or eight packed double precision floating-point values from the second source operand to the two or four packed double precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nVFMSUBADD231PD: Multiplies the two, four, or eight packed double precision floating-point values from the second source operand to the two or four packed double precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double precision floating-point elements and adds the even double precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double precision floating-point values to the destination operand (first source operand).\n\nThe instructions support VEX and EVEX encodings for 128-bit, 256-bit, and 512-bit vector operations, with support for writemasks and rounding modes in EVEX versions.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD132PH",
    "Brief": "Packed FP16 multiply-add/subtract with first operand as destination",
    "Description": "\nThis instruction performs a packed multiply-add (even elements) or multiply-subtract (odd elements) computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in A * B ± C, where each digit corresponds to the operand number, with the destination being operand 1. The specific operations for odd and even elements are:\n\n- 132: \n  - Even elements: dest = dest * src3 + src2\n  - Odd elements: dest = dest * src3 - src2\n\n- 231:\n  - Even elements: dest = src2 * src3 + dest\n  - Odd elements: dest = src2 * src3 - dest\n\n- 213:\n  - Even elements: dest = src2 * dest + src3\n  - Odd elements: dest = src2 * dest - src3\n\nThe destination elements are updated according to the writemask. The instruction supports 128-bit, 256-bit, and 512-bit vector lengths, with different rounding and masking options available through EVEX encoding.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD213PH",
    "Brief": "Packed FP16 multiply-add/subtract with second operand as destination",
    "Description": "\nThis instruction performs a packed multiply-add (even elements) or multiply-subtract (odd elements) computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in A * B ± C, where each digit corresponds to the operand number, with the destination being operand 1. The specific operations for odd and even elements are:\n\n- 132: \n  - Even elements: dest = dest * src3 + src2\n  - Odd elements: dest = dest * src3 - src2\n\n- 231:\n  - Even elements: dest = src2 * src3 + dest\n  - Odd elements: dest = src2 * src3 - dest\n\n- 213:\n  - Even elements: dest = src2 * dest + src3\n  - Odd elements: dest = src2 * dest - src3\n\nThe destination elements are updated according to the writemask. The instruction supports 128-bit, 256-bit, and 512-bit vector lengths, with different rounding and masking options available through EVEX encoding.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD231PH",
    "Brief": "Packed FP16 multiply-add/subtract with third operand as destination",
    "Description": "\nThis instruction performs a packed multiply-add (even elements) or multiply-subtract (odd elements) computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand.\n\nThe notation \"132\", \"213\", and \"231\" indicate the use of the operands in A * B ± C, where each digit corresponds to the operand number, with the destination being operand 1. The specific operations for odd and even elements are:\n\n- 132: \n  - Even elements: dest = dest * src3 + src2\n  - Odd elements: dest = dest * src3 - src2\n\n- 231:\n  - Even elements: dest = src2 * src3 + dest\n  - Odd elements: dest = src2 * src3 - dest\n\n- 213:\n  - Even elements: dest = src2 * dest + src3\n  - Odd elements: dest = src2 * dest - src3\n\nThe destination elements are updated according to the writemask. The instruction supports 128-bit, 256-bit, and 512-bit vector lengths, with different rounding and masking options available through EVEX encoding.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD132PS",
    "Brief": "Fused Multiply-Alternating Subtract/Add of Packed Single Precision Floating-Point Values (with first source as destination)",
    "Description": "\nThese instructions perform a fused multiply-alternating subtract/add operation on packed single precision floating-point values:\n\nVFMSUBADD132PS: Multiplies the packed single precision floating-point values from the first source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the second source operand, performs rounding and stores the result in the first source operand.\n\nVFMSUBADD213PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the first source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the third source operand, performs rounding and stores the result in the first source operand.\n\nVFMSUBADD231PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the first source operand, performs rounding and stores the result in the first source operand.\n\nThe EVEX encoded versions support:\n- Destination and second source operands as ZMM/YMM/XMM registers\n- Third source operand as a ZMM/YMM/XMM register, memory location, or broadcasted from a 32-bit memory location\n- Conditional update with write mask k1\n\nThe VEX encoded versions work similarly but with 128-bit (XMM) or 256-bit (YMM) register operations, with upper bits zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD213PS",
    "Brief": "Fused Multiply-Alternating Subtract/Add of Packed Single Precision Floating-Point Values (with second source as destination)",
    "Description": "\nThese instructions perform a fused multiply-alternating subtract/add operation on packed single precision floating-point values:\n\nVFMSUBADD132PS: Multiplies the packed single precision floating-point values from the first source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the second source operand, performs rounding and stores the result in the first source operand.\n\nVFMSUBADD213PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the first source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the third source operand, performs rounding and stores the result in the first source operand.\n\nVFMSUBADD231PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the first source operand, performs rounding and stores the result in the first source operand.\n\nThe EVEX encoded versions support:\n- Destination and second source operands as ZMM/YMM/XMM registers\n- Third source operand as a ZMM/YMM/XMM register, memory location, or broadcasted from a 32-bit memory location\n- Conditional update with write mask k1\n\nThe VEX encoded versions work similarly but with 128-bit (XMM) or 256-bit (YMM) register operations, with upper bits zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFMSUBADD231PS",
    "Brief": "Fused Multiply-Alternating Subtract/Add of Packed Single Precision Floating-Point Values (with third source as destination)",
    "Description": "\nThese instructions perform a fused multiply-alternating subtract/add operation on packed single precision floating-point values:\n\nVFMSUBADD132PS: Multiplies the packed single precision floating-point values from the first source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the second source operand, performs rounding and stores the result in the first source operand.\n\nVFMSUBADD213PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the first source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the third source operand, performs rounding and stores the result in the first source operand.\n\nVFMSUBADD231PS: Multiplies the packed single precision floating-point values from the second source operand to the corresponding values in the third source operand. From the infinite precision intermediate result, subtracts the odd elements and adds the even elements from the first source operand, performs rounding and stores the result in the first source operand.\n\nThe EVEX encoded versions support:\n- Destination and second source operands as ZMM/YMM/XMM registers\n- Third source operand as a ZMM/YMM/XMM register, memory location, or broadcasted from a 32-bit memory location\n- Conditional update with write mask k1\n\nThe VEX encoded versions work similarly but with 128-bit (XMM) or 256-bit (YMM) register operations, with upper bits zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD132PD",
    "Brief": "Fused Negative Multiply-Add of Packed Double Precision Floating-Point Values",
    "Description": "\nThese instructions perform fused negative multiply-add operations on packed double precision floating-point values. There are three variants with slightly different operand arrangements:\n\nVFNMADD132PD: Multiplies the first source operand with the third source operand, negates the result, and adds the second source operand. The result is stored in the first source operand.\n\nVFNMADD213PD: Multiplies the second source operand with the first source operand, negates the result, and adds the third source operand. The result is stored in the first source operand.\n\nVFNMADD231PD: Multiplies the second source operand with the third source operand, negates the result, and adds the first source operand. The result is stored in the first source operand.\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have both VEX and EVEX encoded versions. The EVEX versions include additional features like writemask, broadcasting, and rounding control.\n\nKey characteristics:\n- Performs multiplication, negation, and addition in a single fused operation\n- Supports single, double, and quad-precision floating-point values\n- Provides precise intermediate result without intermediate rounding\n- Can use different rounding modes specified by MXCSR or EVEX.RC\n- Supports masking and zeroing for EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD213PD",
    "Brief": "Fused Negative Multiply-Add of Packed Double Precision Floating-Point Values",
    "Description": "\nThese instructions perform fused negative multiply-add operations on packed double precision floating-point values. There are three variants with slightly different operand arrangements:\n\nVFNMADD132PD: Multiplies the first source operand with the third source operand, negates the result, and adds the second source operand. The result is stored in the first source operand.\n\nVFNMADD213PD: Multiplies the second source operand with the first source operand, negates the result, and adds the third source operand. The result is stored in the first source operand.\n\nVFNMADD231PD: Multiplies the second source operand with the third source operand, negates the result, and adds the first source operand. The result is stored in the first source operand.\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have both VEX and EVEX encoded versions. The EVEX versions include additional features like writemask, broadcasting, and rounding control.\n\nKey characteristics:\n- Performs multiplication, negation, and addition in a single fused operation\n- Supports single, double, and quad-precision floating-point values\n- Provides precise intermediate result without intermediate rounding\n- Can use different rounding modes specified by MXCSR or EVEX.RC\n- Supports masking and zeroing for EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD231PD",
    "Brief": "Fused Negative Multiply-Add of Packed Double Precision Floating-Point Values",
    "Description": "\nThese instructions perform fused negative multiply-add operations on packed double precision floating-point values. There are three variants with slightly different operand arrangements:\n\nVFNMADD132PD: Multiplies the first source operand with the third source operand, negates the result, and adds the second source operand. The result is stored in the first source operand.\n\nVFNMADD213PD: Multiplies the second source operand with the first source operand, negates the result, and adds the third source operand. The result is stored in the first source operand.\n\nVFNMADD231PD: Multiplies the second source operand with the third source operand, negates the result, and adds the first source operand. The result is stored in the first source operand.\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have both VEX and EVEX encoded versions. The EVEX versions include additional features like writemask, broadcasting, and rounding control.\n\nKey characteristics:\n- Performs multiplication, negation, and addition in a single fused operation\n- Supports single, double, and quad-precision floating-point values\n- Provides precise intermediate result without intermediate rounding\n- Can use different rounding modes specified by MXCSR or EVEX.RC\n- Supports masking and zeroing for EVEX encoded versions\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD132PS",
    "Brief": "Fused Negative Multiply-Add of Packed Single Precision Floating-Point Values (first operand)",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on packed single precision floating-point values with different operand arrangements:\n\nVFNMADD132PS: Multiplies the packed single precision floating-point values from the first source operand to the third source operand, adds the negated infinite precision intermediate result to the second source operand, and stores the result in the first source operand.\n\nVFNMADD213PS: Multiplies the packed single precision floating-point values from the second source operand to the first source operand, adds the negated infinite precision intermediate result to the third source operand, and stores the result in the first source operand.\n\nVFNMADD231PS: Multiplies the packed single precision floating-point values from the second source operand to the third source operand, adds the negated infinite precision intermediate result to the first source operand, and stores the result in the first source operand.\n\nThe instructions support different vector register sizes (XMM, YMM, ZMM) and can operate with or without write masks in EVEX-encoded versions. The operations are performed with infinite precision multiplication and addition before rounding according to the specified rounding mode.\n\nThese instructions are part of the Fused Multiply-Add (FMA) instruction set and are useful for high-performance mathematical computations, particularly in scientific and graphics processing applications.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD213PS",
    "Brief": "Fused Negative Multiply-Add of Packed Single Precision Floating-Point Values (second operand)",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on packed single precision floating-point values with different operand arrangements:\n\nVFNMADD132PS: Multiplies the packed single precision floating-point values from the first source operand to the third source operand, adds the negated infinite precision intermediate result to the second source operand, and stores the result in the first source operand.\n\nVFNMADD213PS: Multiplies the packed single precision floating-point values from the second source operand to the first source operand, adds the negated infinite precision intermediate result to the third source operand, and stores the result in the first source operand.\n\nVFNMADD231PS: Multiplies the packed single precision floating-point values from the second source operand to the third source operand, adds the negated infinite precision intermediate result to the first source operand, and stores the result in the first source operand.\n\nThe instructions support different vector register sizes (XMM, YMM, ZMM) and can operate with or without write masks in EVEX-encoded versions. The operations are performed with infinite precision multiplication and addition before rounding according to the specified rounding mode.\n\nThese instructions are part of the Fused Multiply-Add (FMA) instruction set and are useful for high-performance mathematical computations, particularly in scientific and graphics processing applications.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD231PS",
    "Brief": "Fused Negative Multiply-Add of Packed Single Precision Floating-Point Values (third operand)",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on packed single precision floating-point values with different operand arrangements:\n\nVFNMADD132PS: Multiplies the packed single precision floating-point values from the first source operand to the third source operand, adds the negated infinite precision intermediate result to the second source operand, and stores the result in the first source operand.\n\nVFNMADD213PS: Multiplies the packed single precision floating-point values from the second source operand to the first source operand, adds the negated infinite precision intermediate result to the third source operand, and stores the result in the first source operand.\n\nVFNMADD231PS: Multiplies the packed single precision floating-point values from the second source operand to the third source operand, adds the negated infinite precision intermediate result to the first source operand, and stores the result in the first source operand.\n\nThe instructions support different vector register sizes (XMM, YMM, ZMM) and can operate with or without write masks in EVEX-encoded versions. The operations are performed with infinite precision multiplication and addition before rounding according to the specified rounding mode.\n\nThese instructions are part of the Fused Multiply-Add (FMA) instruction set and are useful for high-performance mathematical computations, particularly in scientific and graphics processing applications.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD132SD",
    "Brief": "Fused Negative Multiply-Add of Scalar Double Precision Floating-Point Values (first source)",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on scalar double precision floating-point values with different operand arrangements:\n\nVFNMADD132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point values in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nVFNMADD213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nVFNMADD231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nThe VEX.128 and EVEX encoded versions have specific encoding rules:\n- The destination operand (also first source operand) is encoded in reg_field\n- The second source operand is encoded in VEX.vvvv/EVEX.vvvv\n- The third source operand is encoded in rm_field\n- Bits 127:64 of the destination are unchanged\n- Bits MAXVL-1:128 of the destination register are zeroed\n\nEVEX encoded versions support write masking and can optionally use different rounding modes.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD213SD",
    "Brief": "Fused Negative Multiply-Add of Scalar Double Precision Floating-Point Values (second source)",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on scalar double precision floating-point values with different operand arrangements:\n\nVFNMADD132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point values in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nVFNMADD213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nVFNMADD231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nThe VEX.128 and EVEX encoded versions have specific encoding rules:\n- The destination operand (also first source operand) is encoded in reg_field\n- The second source operand is encoded in VEX.vvvv/EVEX.vvvv\n- The third source operand is encoded in rm_field\n- Bits 127:64 of the destination are unchanged\n- Bits MAXVL-1:128 of the destination register are zeroed\n\nEVEX encoded versions support write masking and can optionally use different rounding modes.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD231SD",
    "Brief": "Fused Negative Multiply-Add of Scalar Double Precision Floating-Point Values (third source)",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on scalar double precision floating-point values with different operand arrangements:\n\nVFNMADD132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point values in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nVFNMADD213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nVFNMADD231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand (first source operand).\n\nThe VEX.128 and EVEX encoded versions have specific encoding rules:\n- The destination operand (also first source operand) is encoded in reg_field\n- The second source operand is encoded in VEX.vvvv/EVEX.vvvv\n- The third source operand is encoded in rm_field\n- Bits 127:64 of the destination are unchanged\n- Bits MAXVL-1:128 of the destination register are zeroed\n\nEVEX encoded versions support write masking and can optionally use different rounding modes.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD132SS",
    "Brief": "Fused Negative Multiply-Add of Scalar Single Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on scalar single-precision floating-point values with different operand arrangements:\n\nVFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nVFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nVFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nThe destination operand is always the first source operand. The instructions support different rounding modes and can use write masks in EVEX-encoded versions. Bits 127:32 of the destination remain unchanged, and bits MAXVL-1:128 are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD213SS",
    "Brief": "Fused Negative Multiply-Add of Scalar Single Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on scalar single-precision floating-point values with different operand arrangements:\n\nVFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nVFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nVFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nThe destination operand is always the first source operand. The instructions support different rounding modes and can use write masks in EVEX-encoded versions. Bits 127:32 of the destination remain unchanged, and bits MAXVL-1:128 are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFNMADD231SS",
    "Brief": "Fused Negative Multiply-Add of Scalar Single Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-add operation on scalar single-precision floating-point values with different operand arrangements:\n\nVFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nVFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nVFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).\n\nThe destination operand is always the first source operand. The instructions support different rounding modes and can use write masks in EVEX-encoded versions. Bits 127:32 of the destination remain unchanged, and bits MAXVL-1:128 are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB132PD",
    "Brief": "Fused Negative Multiply-Subtract of Packed Double Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on packed double precision floating-point values. There are three variants with slightly different operand arrangements:\n\nVFNMSUB132PD: Multiplies the first source operand with the third source operand, negates the result, then subtracts the second source operand.\n\nVFNMSUB213PD: Multiplies the second source operand with the first source operand, negates the result, then subtracts the third source operand.\n\nVFNMSUB231PD: Multiplies the second source operand with the third source operand, negates the result, then subtracts the first source operand.\n\nThe instructions support different vector register sizes (128-bit, 256-bit, and 512-bit) through VEX and EVEX encodings. The EVEX encoded versions support additional features like:\n- Writemask operations\n- Broadcast from memory\n- Rounding control\n- Embedded rounding for 512-bit operations\n\nThe destination operand is always the first source operand, which is modified in-place. For VEX encoded versions, the upper bits of the destination register are zeroed.\n\nThese instructions are part of the Fused Multiply-Add (FMA) instruction set and provide a way to perform multiply-subtract operations with a single rounding step, which can improve precision and performance compared to separate multiply and subtract operations.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB213PD",
    "Brief": "Fused Negative Multiply-Subtract of Packed Double Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on packed double precision floating-point values. There are three variants with slightly different operand arrangements:\n\nVFNMSUB132PD: Multiplies the first source operand with the third source operand, negates the result, then subtracts the second source operand.\n\nVFNMSUB213PD: Multiplies the second source operand with the first source operand, negates the result, then subtracts the third source operand.\n\nVFNMSUB231PD: Multiplies the second source operand with the third source operand, negates the result, then subtracts the first source operand.\n\nThe instructions support different vector register sizes (128-bit, 256-bit, and 512-bit) through VEX and EVEX encodings. The EVEX encoded versions support additional features like:\n- Writemask operations\n- Broadcast from memory\n- Rounding control\n- Embedded rounding for 512-bit operations\n\nThe destination operand is always the first source operand, which is modified in-place. For VEX encoded versions, the upper bits of the destination register are zeroed.\n\nThese instructions are part of the Fused Multiply-Add (FMA) instruction set and provide a way to perform multiply-subtract operations with a single rounding step, which can improve precision and performance compared to separate multiply and subtract operations.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB231PD",
    "Brief": "Fused Negative Multiply-Subtract of Packed Double Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on packed double precision floating-point values. There are three variants with slightly different operand arrangements:\n\nVFNMSUB132PD: Multiplies the first source operand with the third source operand, negates the result, then subtracts the second source operand.\n\nVFNMSUB213PD: Multiplies the second source operand with the first source operand, negates the result, then subtracts the third source operand.\n\nVFNMSUB231PD: Multiplies the second source operand with the third source operand, negates the result, then subtracts the first source operand.\n\nThe instructions support different vector register sizes (128-bit, 256-bit, and 512-bit) through VEX and EVEX encodings. The EVEX encoded versions support additional features like:\n- Writemask operations\n- Broadcast from memory\n- Rounding control\n- Embedded rounding for 512-bit operations\n\nThe destination operand is always the first source operand, which is modified in-place. For VEX encoded versions, the upper bits of the destination register are zeroed.\n\nThese instructions are part of the Fused Multiply-Add (FMA) instruction set and provide a way to perform multiply-subtract operations with a single rounding step, which can improve precision and performance compared to separate multiply and subtract operations.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB132PS",
    "Brief": "Fused Negative Multiply-Subtract of Packed Single Precision Floating-Point Values (Variant 1)",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on packed single-precision floating-point values with three different variants of operand ordering:\n\nVFNMSUB132PS: Multiplies the packed single-precision values from the first source operand with the third source operand, negates the result, then subtracts the second source operand. The result is stored in the destination operand.\n\nVFNMSUB213PS: Multiplies the packed single-precision values from the second source operand with the first source operand, negates the result, then subtracts the third source operand. The result is stored in the destination operand.\n\nVFNMSUB231PS: Multiplies the packed single-precision values from the second source operand with the third source operand, negates the result, then subtracts the first source operand. The result is stored in the destination operand.\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have versions with VEX and EVEX encodings. The EVEX-encoded versions support additional features like write masking and broadcasting.\n\nKey characteristics:\n- Performs multiplication, negation, and subtraction in a single fused operation\n- Supports infinite precision intermediate results\n- Applies rounding according to MXCSR control or specific rounding modes\n- Handles different vector register sizes (128, 256, 512 bits)\n- Supports write masking for selective updates\n- Available with broadcast for memory operands in EVEX versions\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB213PS",
    "Brief": "Fused Negative Multiply-Subtract of Packed Single Precision Floating-Point Values (Variant 2)",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on packed single-precision floating-point values with three different variants of operand ordering:\n\nVFNMSUB132PS: Multiplies the packed single-precision values from the first source operand with the third source operand, negates the result, then subtracts the second source operand. The result is stored in the destination operand.\n\nVFNMSUB213PS: Multiplies the packed single-precision values from the second source operand with the first source operand, negates the result, then subtracts the third source operand. The result is stored in the destination operand.\n\nVFNMSUB231PS: Multiplies the packed single-precision values from the second source operand with the third source operand, negates the result, then subtracts the first source operand. The result is stored in the destination operand.\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have versions with VEX and EVEX encodings. The EVEX-encoded versions support additional features like write masking and broadcasting.\n\nKey characteristics:\n- Performs multiplication, negation, and subtraction in a single fused operation\n- Supports infinite precision intermediate results\n- Applies rounding according to MXCSR control or specific rounding modes\n- Handles different vector register sizes (128, 256, 512 bits)\n- Supports write masking for selective updates\n- Available with broadcast for memory operands in EVEX versions\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB231PS",
    "Brief": "Fused Negative Multiply-Subtract of Packed Single Precision Floating-Point Values (Variant 3)",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on packed single-precision floating-point values with three different variants of operand ordering:\n\nVFNMSUB132PS: Multiplies the packed single-precision values from the first source operand with the third source operand, negates the result, then subtracts the second source operand. The result is stored in the destination operand.\n\nVFNMSUB213PS: Multiplies the packed single-precision values from the second source operand with the first source operand, negates the result, then subtracts the third source operand. The result is stored in the destination operand.\n\nVFNMSUB231PS: Multiplies the packed single-precision values from the second source operand with the third source operand, negates the result, then subtracts the first source operand. The result is stored in the destination operand.\n\nThe instructions support different register sizes (XMM, YMM, ZMM) and have versions with VEX and EVEX encodings. The EVEX-encoded versions support additional features like write masking and broadcasting.\n\nKey characteristics:\n- Performs multiplication, negation, and subtraction in a single fused operation\n- Supports infinite precision intermediate results\n- Applies rounding according to MXCSR control or specific rounding modes\n- Handles different vector register sizes (128, 256, 512 bits)\n- Supports write masking for selective updates\n- Available with broadcast for memory operands in EVEX versions\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB132SD",
    "Brief": "Fused Negative Multiply-Subtract of Scalar Double Precision Floating-Point Values (132 variant)",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on scalar double precision floating-point values with three different operand order variants:\n\nVFNMSUB132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFNMSUB213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFNMSUB231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nThe instructions support VEX and EVEX encoding with different features like writemask, rounding modes, and broadcast capabilities. The destination operand is always the first operand, and the operation can be summarized as: dest = -(src1 * src2) - src3.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB213SD",
    "Brief": "Fused Negative Multiply-Subtract of Scalar Double Precision Floating-Point Values (213 variant)",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on scalar double precision floating-point values with three different operand order variants:\n\nVFNMSUB132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFNMSUB213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFNMSUB231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nThe instructions support VEX and EVEX encoding with different features like writemask, rounding modes, and broadcast capabilities. The destination operand is always the first operand, and the operation can be summarized as: dest = -(src1 * src2) - src3.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB231SD",
    "Brief": "Fused Negative Multiply-Subtract of Scalar Double Precision Floating-Point Values (231 variant)",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on scalar double precision floating-point values with three different operand order variants:\n\nVFNMSUB132SD: Multiplies the low packed double precision floating-point value from the first source operand to the low packed double precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the second source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFNMSUB213SD: Multiplies the low packed double precision floating-point value from the second source operand to the low packed double precision floating-point value in the first source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the third source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nVFNMSUB231SD: Multiplies the low packed double precision floating-point value from the second source to the low packed double precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double precision floating-point value in the first source operand, performs rounding and stores the resulting packed double precision floating-point value to the destination operand.\n\nThe instructions support VEX and EVEX encoding with different features like writemask, rounding modes, and broadcast capabilities. The destination operand is always the first operand, and the operation can be summarized as: dest = -(src1 * src2) - src3.\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB132SS",
    "Brief": "Fused Negative Multiply-Subtract of Scalar Single Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on scalar single-precision floating-point values with different operand arrangements:\n\nVFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nVFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nVFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nFor VEX.128 and EVEX encoded versions:\n- The destination operand is also the first source operand\n- Bits 127:32 of the destination remain unchanged\n- Bits MAXVL-1:128 of the destination register are zeroed\n\nFor EVEX encoded versions:\n- The low doubleword element of the destination is updated according to the writemask\n- Rounding mode can be explicitly set or follows MXCSR settings\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB213SS",
    "Brief": "Fused Negative Multiply-Subtract of Scalar Single Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on scalar single-precision floating-point values with different operand arrangements:\n\nVFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nVFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nVFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nFor VEX.128 and EVEX encoded versions:\n- The destination operand is also the first source operand\n- Bits 127:32 of the destination remain unchanged\n- Bits MAXVL-1:128 of the destination register are zeroed\n\nFor EVEX encoded versions:\n- The low doubleword element of the destination is updated according to the writemask\n- Rounding mode can be explicitly set or follows MXCSR settings\n",
    "Alias": []
  },
  {
    "Name": "VFNMSUB231SS",
    "Brief": "Fused Negative Multiply-Subtract of Scalar Single Precision Floating-Point Values",
    "Description": "\nThese instructions perform a fused negative multiply-subtract operation on scalar single-precision floating-point values with different operand arrangements:\n\nVFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nVFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nVFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From the negated infinite precision intermediate result, subtracts the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand.\n\nFor VEX.128 and EVEX encoded versions:\n- The destination operand is also the first source operand\n- Bits 127:32 of the destination remain unchanged\n- Bits MAXVL-1:128 of the destination register are zeroed\n\nFor EVEX encoded versions:\n- The low doubleword element of the destination is updated according to the writemask\n- Rounding mode can be explicitly set or follows MXCSR settings\n",
    "Alias": []
  },
  {
    "Name": "VFPCLASSPD",
    "Brief": "Tests the input for special categories of packed double precision floating-point values",
    "Description": "\nThe VFPCLASSPD instruction checks the packed double precision floating-point values for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against. \n\nThe classification categories specified by imm8 include:\n- QNaN\n- Positive Zero\n- Negative Zero\n- Positive Infinity\n- Negative Infinity\n- Denormal\n- Negative Finite\n- Signaling NaN\n\nThe classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result of each element is written to the corresponding bit in a mask register according to the writemask.\n\nThe source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location.\n\nThe instruction supports different vector lengths (128, 256, and 512 bits) and uses EVEX encoding with specific feature flags (AVX512VL and AVX512DQ).\n",
    "Alias": []
  },
  {
    "Name": "VFPCLASSPH",
    "Brief": "Test types of packed FP16 values",
    "Description": "\nThis instruction checks the packed FP16 values in the source operand for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against.\n\nThe categories of classification include:\n- QNAN (Quiet NaN)\n- Positive Zero\n- Negative Zero\n- Positive Infinity\n- Negative Infinity\n- Denormal\n- Negative Finite\n- SNAN (Signaling NaN)\n\nThe classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result is written to the corresponding bits in the destination mask register according to the writemask.\n\nThe instruction supports 128-bit (4 FP16 values), 256-bit (8 FP16 values), and 512-bit (16 FP16 values) vector lengths, with different encoding variants for each length.\n",
    "Alias": []
  },
  {
    "Name": "VFPCLASSPS",
    "Brief": "Tests types of packed Float32 values",
    "Description": "\nThe FPCLASSPS instruction checks the packed single-precision floating-point values for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against.\n\nThe classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result of each element is written to the corresponding bit in a mask register k2 according to the writemask k1. Bits [MAX_KL-1:16/8/4] of the destination are cleared.\n\nThe classification categories include:\n- qNaN (Quiet NaN)\n- +0\n- -0\n- +Infinity\n- -Infinity\n- Denormal numbers\n- Finite negative numbers\n- Signaling NaN (sNaN)\n\nThe source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an Undefined (UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VFPCLASSSD",
    "Brief": "Tests the input scalar float64 value for specific categories",
    "Description": "\nThe VFPCLASSSD instruction checks the low double precision floating-point value in the source operand for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against.\n\nThe classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result is written to the low bit in a mask register k2 according to the writemask k1. Bits MAX_KL-1: 1 of the destination are cleared.\n\nThe instruction can test for the following categories:\n- qNaN (Quiet NaN)\n- +0\n- -0\n- +Infinity\n- -Infinity\n- Denormal numbers\n- Finite negative numbers\n- sNaN (Signaling NaN)\n\nThe immediate byte (imm8) acts as a mask to specify which categories to check. The result is a logical OR of the specified category tests.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will cause an #UD (Undefined Instruction) exception.\n",
    "Alias": []
  },
  {
    "Name": "VFPCLASSSH",
    "Brief": "Test types of scalar FP16 values",
    "Description": "\nThis instruction checks the low FP16 value in the source operand for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against. The classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element.\n\nThe instruction tests for the following categories:\n- NaN\n- +0\n- -0\n- +Infinity\n- -Infinity\n- Denormal\n- Finite negative\n\nThe result is written to the low bit in the destination mask register according to the writemask. The other bits in the destination mask register are zeroed.\n\nThe instruction uses an 8-bit immediate value (imm8) to specify which categories to test, allowing flexible classification of floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VFPCLASSSS",
    "Brief": "Tests type of a scalar Float32 value",
    "Description": "\nThe FPCLASSSS instruction checks the low single-precision floating-point value in the source operand for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against.\n\nThe classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result is written to the low bit in a mask register k2 according to the writemask k1. Bits MAX_KL-1: 1 of the destination are cleared.\n\nThe instruction can classify the input value into the following categories:\n- qNaN (Quiet NaN)\n- +0\n- -0\n- +Infinity\n- -Infinity\n- Denormal\n- Finite negative number\n- sNaN (Signaling NaN)\n\nThe immediate byte (imm8) provides a mask bit for each of these category tests, allowing selective testing of the input value's characteristics.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will raise an #UD (Undefined Instruction) exception.\n",
    "Alias": []
  },
  {
    "Name": "VGATHERDPD",
    "Brief": "Gather double precision floating-point values using signed dword indices",
    "Description": "\nThe instruction conditionally loads up to 2 or 4 double precision floating-point values from memory addresses specified by the memory operand using qword or dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\n\nThe mask operand specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand. Conditionality is specified by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the corresponding element of the destination register is left unchanged.\n\nVEX.128 version: The instruction will gather two double precision floating-point values. For dword indices, only the lower two indices in the vector index register are used.\n\nVEX.256 version: The instruction will gather four double precision floating-point values. For dword indices, only the lower four indices in the vector index register are used.\n\nKey characteristics:\n- Values may be read from memory in any order\n- Faults are delivered in a right-to-left manner\n- Elements may be gathered in any order\n- Does not perform AC checks\n- Should not be used for memory mapped I/O\n",
    "Alias": []
  },
  {
    "Name": "VGATHERQPD",
    "Brief": "Gather double precision floating-point values using signed qword indices",
    "Description": "\nThe instruction conditionally loads up to 2 or 4 double precision floating-point values from memory addresses specified by the memory operand using qword or dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\n\nThe mask operand specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand. Conditionality is specified by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the corresponding element of the destination register is left unchanged.\n\nVEX.128 version: The instruction will gather two double precision floating-point values. For dword indices, only the lower two indices in the vector index register are used.\n\nVEX.256 version: The instruction will gather four double precision floating-point values. For dword indices, only the lower four indices in the vector index register are used.\n\nKey characteristics:\n- Values may be read from memory in any order\n- Faults are delivered in a right-to-left manner\n- Elements may be gathered in any order\n- Does not perform AC checks\n- Should not be used for memory mapped I/O\n",
    "Alias": []
  },
  {
    "Name": "VGATHERDPS",
    "Brief": "Gather single-precision floating-point values from memory using signed dword indices",
    "Description": "\nA set of single-precision/double precision floating-point memory locations pointed by base address BASE_ADDR and index vector V_INDEX with scale SCALE are gathered. The result is written into a vector register. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). \n\nElements will only be loaded if their corresponding mask bit is one. If an element's mask bit is not set, the corresponding element of the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.\n\nKey characteristics of the instruction include:\n- Values may be read from memory in any order\n- Faults are delivered in a right-to-left manner\n- Elements may be gathered in any order, but faults must be delivered from right to left\n- Does not perform AC checks\n- Not valid with 16-bit effective addresses\n- Requires the presence of a VSIB byte\n\nThe scaled index may have more bits than the processor's address bits, in which case the most significant bits beyond the number of address bits are ignored.\n\nThe instruction will cause an #UD fault if:\n- The destination vector register is the same as the index vector\n- The k0 mask register is specified\n",
    "Alias": []
  },
  {
    "Name": "VGATHERQPS",
    "Brief": "Gather single-precision floating-point values using qword indices",
    "Description": "\nThe instruction conditionally loads up to 4 or 8 single-precision floating-point values from memory addresses specified by the memory operand using dword or qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\n\nThe mask operand specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand. Conditionality is specified by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the corresponding element of the destination register is left unchanged.\n\nUsing qword indices, the instruction conditionally loads up to 2 or 4 single-precision floating-point values from the VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destination register are zero'ed with qword indices.\n\nKey characteristics of the instruction include:\n- Memory values can be read in any order\n- Faults are delivered in a right-to-left manner\n- The instruction does not perform AC checks\n- It will cause a #UD if the address size attribute is 16-bit or the memory operand is encoded without the SIB byte\n- Should not be used for memory-mapped I/O due to implementation-specific load ordering\n\nVEX.128 version:\n- For dword indices: gathers four single-precision floating-point values\n- For qword indices: gathers two values and zeros the upper 64 bits of the destination\n\nVEX.256 version:\n- For dword indices: gathers eight single-precision floating-point values\n- For qword indices: gathers four values and zeros the upper 128 bits of the destination\n",
    "Alias": []
  },
  {
    "Name": "VGETEXPPD",
    "Brief": "Convert exponents of packed double precision floating-point values to double precision floating-point values",
    "Description": "\nExtracts the biased exponents from the normalized double precision floating-point representation of each qword data element of the source operand as unbiased signed integer value, or convert the denormal representation of input data to unbiased negative integer values. Each integer value of the unbiased exponent is converted to double precision floating-point value and written to the corresponding qword elements of the destination operand as double precision floating-point numbers.\n\nThe destination operand is a ZMM/YMM/XMM register and updated under the writemask. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nThe formula is:\nGETEXP(x) = floor(log₂(|x|))\n\nNotation floor(x) stands for the greatest integer not exceeding real number x.\n\nSpecial cases of input values include:\n- If input is NaN, return QNaN of the input\n- If input magnitude is between 0 and INF, return floor(log₂(|input|))\n- If input magnitude is +INF, return +INF\n- If input magnitude is 0, return -INF\n",
    "Alias": []
  },
  {
    "Name": "VGETEXPPH",
    "Brief": "Convert exponents of packed FP16 values to FP16 values",
    "Description": "\nThis instruction extracts the biased exponents from the normalized FP16 representation of each word element of the source operand as an unbiased signed integer value, or converts the denormal representation of input data to unbiased negative integer values. Each integer value of the unbiased exponent is converted to an FP16 value and written to the corresponding word elements of the destination operand as FP16 numbers.\n\nThe destination elements are updated according to the writemask.\n\nThe formula for the operation is:\nGETEXP(x) = floor(log₂(|x|))\n\nSpecial cases of input values include:\n- For NaN input: Returns QNaN of the input\n- For 0 < |src1| < INF: Returns floor(log₂(|src1|))\n- For |src1| = +INF: Returns +INF\n- For |src1| = 0: Returns -INF\n\nSoftware usage of this instruction typically involves a combination with VGETMANTPH, and the instruction does not require handling SIMD floating-point exceptions.\n\nThe instruction supports different vector lengths (128, 256, and 512 bits) and can handle various input scenarios including special floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VGETEXPPS",
    "Brief": "Convert exponents of packed single precision floating-point values to single precision floating-point values",
    "Description": "\nExtracts the biased exponents from the normalized single-precision floating-point representation of each dword element of the source operand as unbiased signed integer values, or convert the denormal representation of input data to unbiased negative integer values. Each integer value of the unbiased exponent is converted to single-precision floating-point value and written to the corresponding dword elements of the destination operand.\n\nThe destination operand is a ZMM/YMM/XMM register and updated under the writemask. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location.\n\nThe formula is: GETEXP(x) = floor(log₂(|x|))\n\nNotation floor(x) stands for maximal integer not exceeding real number x.\n\nSoftware usage of VGETEXPxx and VGETMANTxx instructions generally involve a combination of GETEXP operation and GETMANT operation. Thus VGETEXPxx instructions do not require software to handle SIMD floating-point exceptions.\n\nSpecial cases of input values include:\n- For NaN input: Returns QNaN of the source\n- For 0 < |src1| < INF: Returns floor(log₂(|src1|))\n- For |src1| = +INF: Returns +INF\n- For |src1| = 0: Returns -INF\n",
    "Alias": []
  },
  {
    "Name": "VGETEXPSD",
    "Brief": "Convert exponents of scalar double precision floating-point value to double precision floating-point value",
    "Description": "\nExtracts the biased exponent from the normalized double precision floating-point representation of the low qword data element of the source operand as an unbiased signed integer value, or convert the denormal representation of input data to unbiased negative integer values. The integer value of the unbiased exponent is converted to double precision floating-point value and written to the destination operand as a double precision floating-point number.\n\nThe destination must be an XMM register, and the source operand can be an XMM register or a float64 memory location.\n\nIf writemasking is used, the low quadword element of the destination operand is conditionally updated depending on the value of writemask register k1. If writemasking is not used, the low quadword element of the destination operand is unconditionally updated.\n\nEach GETEXP operation converts the exponent value into a floating-point number (permitting input value in denormal representation).\n\nThe formula is:\nGETEXP(x) = floor(log₂(|x|))\n\nNotation floor(x) stands for the maximal integer not exceeding real number x.\n",
    "Alias": []
  },
  {
    "Name": "VGETEXPSH",
    "Brief": "Convert exponents of scalar FP16 values to FP16 values",
    "Description": "\nThis instruction extracts the biased exponents from the normalized FP16 representation of the low word element of the source operand (the second operand) as an unbiased signed integer value, or converts the denormal representation of input data to an unbiased negative integer value. The integer value of the unbiased exponent is converted to an FP16 value and written to the low word element of the destination operand (the first operand) as an FP16 number.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nEach GETEXP operation converts the exponent value into a floating-point number (permitting input value in denormal representation).\n\nThe formula is:\nGETEXP(x) = floor(log₂(|x|))\n\nNotation floor(x) stands for the maximal integer not exceeding real number x.\n\nSoftware usage of VGETEXPxx and VGETMANTxx instructions generally involve a combination of GETEXP operation and GETMANT operation. Thus, the VGETEXPSH instruction does not require software to handle SIMD floating-point exceptions.\n",
    "Alias": []
  },
  {
    "Name": "VGETEXPSS",
    "Brief": "Convert exponents of scalar single precision floating-point value to single precision floating-point value",
    "Description": "\nExtracts the biased exponent from the normalized single-precision floating-point representation of the low double-word data element of the source operand as an unbiased signed integer value, or convert the denormal representation of input data to unbiased negative integer values. The integer value of the unbiased exponent is converted to single-precision floating-point value and written to the destination operand as a single-precision floating-point number.\n\nThe destination must be an XMM register, and the source operand can be an XMM register or a float32 memory location.\n\nIf writemasking is used, the low doubleword element of the destination operand is conditionally updated depending on the value of the writemask register k1. If writemasking is not used, the low doubleword element of the destination operand is unconditionally updated.\n\nThe formula for the operation is:\nGETEXP(x) = floor(log₂(|x|))\n\nWhere \"floor(x)\" stands for the maximal integer not exceeding the real number x.\n\nSoftware usage of VGETEXP instructions generally involves a combination of GETEXP and GETMANT operations, and thus do not require software to handle SIMD floating-point exceptions.\n",
    "Alias": []
  },
  {
    "Name": "VGETMANTPD",
    "Brief": "Extract Float64 Vector of Normalized Mantissas From Float64 Vector",
    "Description": "\nConvert double precision floating values in the source operand to double precision floating-point values with mantissa normalization and sign control specified by the imm8 byte.\n\nFor each input double precision floating-point value x, the conversion operation is:\nGetMant(x) = ±2^k|x.significand|\n\nWhere:\n1 <= |x.significand| < 2\n\nThe unbiased exponent k can be either 0 or -1, depending on the interval range defined by interv, the range of the significand, and whether the source exponent is even or odd. The sign of the final result is determined by sign control and the source sign.\n\nThe instruction supports different normalization intervals and sign control modes:\n- Interval [1, 2)\n- Interval [1/2, 2)\n- Interval [1/2, 1)\n- Interval [3/4, 3/2)\n\nSign control modes include:\n- Preserving source sign\n- Setting sign to positive or negative\n- Generating QNaN for certain sign conditions\n\nSpecial cases for floating-point values like NaN, infinity, and zero are handled according to specific rules defined in the instruction specification.\n\nThe instruction is writemasked, meaning only elements with corresponding bits set in the vector mask register k1 are computed and stored in the destination.\n",
    "Alias": []
  },
  {
    "Name": "VGETMANTPH",
    "Brief": "Extract FP16 Vector of Normalized Mantissas from FP16 Vector",
    "Description": "\nThis instruction converts the FP16 values in the source operand to FP16 values with the mantissa normalization and sign control specified by the imm8 byte.\n\nThe conversion operation is: GetMant(x) = ±2^k|x.significand|, where 1 ≤ |x.significand| &lt; 2. The unbiased exponent k depends on the interval range defined by interv and whether the exponent of the source is even or odd. The sign of the final result is determined by the sign control and the source sign and the leading fraction bit.\n\nThe imm8 byte controls two main aspects:\n1. Sign Control (SC):\n   - 0b00: Preserves source sign\n   - 0b01: Sets sign to 0\n   - 0b1x: Generates QNaN_Indefinite if source sign is non-zero\n\n2. Normalization Interval (interv):\n   - 0b00: Interval is [1, 2)\n   - 0b01: Interval is [1/2, 2)\n   - 0b10: Interval is [1/2, 1)\n   - 0b11: Interval is [3/4, 3/2)\n\nSpecial handling exists for various input types like NaN, infinity, zero, and negative numbers, with specific rules for sign and mantissa generation.\n\nThe destination elements are updated according to the writemask, with options for masking and zeroing.\n",
    "Alias": []
  },
  {
    "Name": "VGETMANTPS",
    "Brief": "Extract Float32 Vector of Normalized Mantissas From Float32 Vector",
    "Description": "\nConvert single-precision floating values in the source operand to single-precision floating-point values with mantissa normalization and sign control specified by the imm8 byte.\n\nThe conversion operation is: GetMant(x) = ±2^k|x.significand|, where:\n1 <= |x.significand| < 2\n\nUnbiased exponent k can be either 0 or -1, depending on:\n- Interval range defined by interv\n- Range of the significand\n- Whether the source exponent is even or odd\n\nThe sign of the final result is determined by:\n- Sign control (sc)\n- Source sign\n\nEach converted single-precision floating-point result is encoded according to:\n- Sign control\n- Unbiased exponent k (adding bias)\n- Mantissa normalized to the specified interval\n\nThe instruction supports:\n- Writemask operation\n- Handling of special floating-point numbers\n- Various sign and normalization interval controls via the imm8 parameter\n\nNote: EVEX.vvvv must be 1111b, and VEX.L must be 0, otherwise an undefined instruction (#UD) will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VGETMANTSD",
    "Brief": "Extract the normalized mantissa of the low float64 element",
    "Description": "\nConvert the double precision floating values in the low quadword element of the second source operand to a double precision floating-point value with the mantissa normalization and sign control specified by the imm8 byte.\n\nThe conversion operation is: GetMant(x) = ±2^k|x.significand|\n\nWhere:\n1 <= |x.significand| < 2\n\nUnbiased exponent k can be either 0 or -1, depending on:\n- Interval range defined by interv\n- Range of the significand\n- Whether the source exponent is even or odd\n\nThe sign of the final result is determined by:\n- Sign control (sc)\n- Source sign\n\nThe converted double precision floating-point result is encoded with:\n- Sign control\n- Unbiased exponent k (adding bias)\n- Mantissa normalized to the specified interval range\n\nThe GetMant() function follows specific rules when dealing with floating-point special numbers. The low quadword element of the destination operand is updated either unconditionally or conditionally based on the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VGETMANTSH",
    "Brief": "Extract FP16 normalized mantissa from FP16 scalar",
    "Description": "\nThis instruction converts the FP16 value in the low element of the second source operand to FP16 values with the mantissa normalization and sign control specified by the imm8 byte.\n\nThe conversion operation is defined as:\n\nGetMant(x) = ±2^k|x.significand|\n\nWhere:\n- 1 ≤ |x.significand| < 2\n- The unbiased exponent k depends on the interval range and whether the source exponent is even or odd\n- The sign of the final result is determined by sign control, source sign, and leading fraction bit\n\nKey characteristics:\n- Converts the low element of the source operand\n- Allows control over mantissa normalization and sign via imm8 byte\n- Uses writemask k1 for destination\n- Bits 127:16 of the destination are copied from the first source operand\n- Follows specific rules for handling floating-point special numbers\n\nThe instruction provides fine-grained control over mantissa extraction and normalization for FP16 scalar values.\n",
    "Alias": []
  },
  {
    "Name": "VGETMANTSS",
    "Brief": "Extract normalized mantissa from low float32 element with sign control and mantissa interval normalization",
    "Description": "\nConvert the single-precision floating values in the low doubleword element of the second source operand to a single-precision floating-point value with mantissa normalization and sign control specified by the imm8 byte.\n\nThe conversion operation is: GetMant(x) = ±2^k|x.significand|\n\nWhere:\n1 <= |x.significand| < 2\n\nThe unbiased exponent k can be either 0 or -1, depending on:\n- Interval range defined by interv\n- Range of the significand\n- Whether the source exponent is even or odd\n\nThe sign of the final result is determined by:\n- Sign control (sc)\n- Source sign\n\nThe converted single-precision floating-point result is encoded according to:\n- Sign control\n- Unbiased exponent k (adding bias)\n- Mantissa normalized to the specified interval range\n\nThe GetMant() function follows specific rules when dealing with floating-point special numbers.\n\nIf writemasking is used, the low doubleword element of the destination operand is conditionally updated based on the writemask register k1. Without writemasking, the low doubleword element is unconditionally updated.\n",
    "Alias": []
  },
  {
    "Name": "VINSERTF128",
    "Brief": "Insert 128 bits of packed floating-point values into a vector register",
    "Description": "\nThese instructions insert floating-point values from a source operand into a destination vector register at a specified granularity and offset.\n\nVINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand into the destination operand at a 128-bit granularity offset. The remaining portions of the destination operand are copied from the first source operand.\n\nThe second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.\n\nVINSERTF32x8 and VINSERTF64x4 insert 256-bits of packed floating-point values from the second source operand into the destination operand at a 256-bit granular offset. The second source operand can be either a YMM register or a 256-bit memory location.\n\nThe insertion location is determined by an immediate byte (imm8) which specifies the offset. The destination operand is updated according to a writemask, which can perform merging or zeroing operations.\n\nThese instructions support various vector register sizes (YMM and ZMM) and different floating-point precisions (single and double).\n",
    "Alias": []
  },
  {
    "Name": "VINSERTF32x4",
    "Brief": "Insert 128 bits of packed single-precision floating-point values into a vector register",
    "Description": "\nThese instructions insert floating-point values from a source operand into a destination vector register at a specified granularity and offset.\n\nVINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand into the destination operand at a 128-bit granularity offset. The remaining portions of the destination operand are copied from the first source operand.\n\nThe second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.\n\nVINSERTF32x8 and VINSERTF64x4 insert 256-bits of packed floating-point values from the second source operand into the destination operand at a 256-bit granular offset. The second source operand can be either a YMM register or a 256-bit memory location.\n\nThe insertion location is determined by an immediate byte (imm8) which specifies the offset. The destination operand is updated according to a writemask, which can perform merging or zeroing operations.\n\nThese instructions support various vector register sizes (YMM and ZMM) and different floating-point precisions (single and double).\n",
    "Alias": []
  },
  {
    "Name": "VINSERTF64x2",
    "Brief": "Insert 128 bits of packed double-precision floating-point values into a vector register",
    "Description": "\nThese instructions insert floating-point values from a source operand into a destination vector register at a specified granularity and offset.\n\nVINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand into the destination operand at a 128-bit granularity offset. The remaining portions of the destination operand are copied from the first source operand.\n\nThe second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.\n\nVINSERTF32x8 and VINSERTF64x4 insert 256-bits of packed floating-point values from the second source operand into the destination operand at a 256-bit granular offset. The second source operand can be either a YMM register or a 256-bit memory location.\n\nThe insertion location is determined by an immediate byte (imm8) which specifies the offset. The destination operand is updated according to a writemask, which can perform merging or zeroing operations.\n\nThese instructions support various vector register sizes (YMM and ZMM) and different floating-point precisions (single and double).\n",
    "Alias": []
  },
  {
    "Name": "VINSERTF32x8",
    "Brief": "Insert 256 bits of packed single-precision floating-point values into a ZMM register",
    "Description": "\nThese instructions insert floating-point values from a source operand into a destination vector register at a specified granularity and offset.\n\nVINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand into the destination operand at a 128-bit granularity offset. The remaining portions of the destination operand are copied from the first source operand.\n\nThe second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.\n\nVINSERTF32x8 and VINSERTF64x4 insert 256-bits of packed floating-point values from the second source operand into the destination operand at a 256-bit granular offset. The second source operand can be either a YMM register or a 256-bit memory location.\n\nThe insertion location is determined by an immediate byte (imm8) which specifies the offset. The destination operand is updated according to a writemask, which can perform merging or zeroing operations.\n\nThese instructions support various vector register sizes (YMM and ZMM) and different floating-point precisions (single and double).\n",
    "Alias": []
  },
  {
    "Name": "VINSERTF64x4",
    "Brief": "Insert 256 bits of packed double-precision floating-point values into a ZMM register",
    "Description": "\nThese instructions insert floating-point values from a source operand into a destination vector register at a specified granularity and offset.\n\nVINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand into the destination operand at a 128-bit granularity offset. The remaining portions of the destination operand are copied from the first source operand.\n\nThe second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.\n\nVINSERTF32x8 and VINSERTF64x4 insert 256-bits of packed floating-point values from the second source operand into the destination operand at a 256-bit granular offset. The second source operand can be either a YMM register or a 256-bit memory location.\n\nThe insertion location is determined by an immediate byte (imm8) which specifies the offset. The destination operand is updated according to a writemask, which can perform merging or zeroing operations.\n\nThese instructions support various vector register sizes (YMM and ZMM) and different floating-point precisions (single and double).\n",
    "Alias": []
  },
  {
    "Name": "VINSERTI128",
    "Brief": "Insert 128-bits of packed integer data into destination operand",
    "Description": "\nThese instructions insert packed integer values from the second source operand into the destination operand at specific offsets:\n\nVINSERTI32x4 and VINSERTI64x2 insert 128-bits of packed integer values from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nVINSERTI32x8 and VINSERTI64x4 insert 256-bits of packed integer values from the second source operand into the destination operand at a 256-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be a YMM register or a 256-bit memory location.\n\nVINSERTI128 inserts 128-bits of packed integer data from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nThe instructions support writemask for selective updating of destination operand elements. The high bits of the immediate are typically ignored, and the insertion offset is determined by the lower bits of the immediate value.\n",
    "Alias": []
  },
  {
    "Name": "VINSERTI32x4",
    "Brief": "Insert 128 bits of packed doubleword integer values into destination operand",
    "Description": "\nThese instructions insert packed integer values from the second source operand into the destination operand at specific offsets:\n\nVINSERTI32x4 and VINSERTI64x2 insert 128-bits of packed integer values from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nVINSERTI32x8 and VINSERTI64x4 insert 256-bits of packed integer values from the second source operand into the destination operand at a 256-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be a YMM register or a 256-bit memory location.\n\nVINSERTI128 inserts 128-bits of packed integer data from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nThe instructions support writemask for selective updating of destination operand elements. The high bits of the immediate are typically ignored, and the insertion offset is determined by the lower bits of the immediate value.\n",
    "Alias": []
  },
  {
    "Name": "VINSERTI64x2",
    "Brief": "Insert 128 bits of packed quadword integer values into destination operand",
    "Description": "\nThese instructions insert packed integer values from the second source operand into the destination operand at specific offsets:\n\nVINSERTI32x4 and VINSERTI64x2 insert 128-bits of packed integer values from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nVINSERTI32x8 and VINSERTI64x4 insert 256-bits of packed integer values from the second source operand into the destination operand at a 256-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be a YMM register or a 256-bit memory location.\n\nVINSERTI128 inserts 128-bits of packed integer data from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nThe instructions support writemask for selective updating of destination operand elements. The high bits of the immediate are typically ignored, and the insertion offset is determined by the lower bits of the immediate value.\n",
    "Alias": []
  },
  {
    "Name": "VINSERTI32x8",
    "Brief": "Insert 256 bits of packed doubleword integer values into destination operand",
    "Description": "\nThese instructions insert packed integer values from the second source operand into the destination operand at specific offsets:\n\nVINSERTI32x4 and VINSERTI64x2 insert 128-bits of packed integer values from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nVINSERTI32x8 and VINSERTI64x4 insert 256-bits of packed integer values from the second source operand into the destination operand at a 256-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be a YMM register or a 256-bit memory location.\n\nVINSERTI128 inserts 128-bits of packed integer data from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nThe instructions support writemask for selective updating of destination operand elements. The high bits of the immediate are typically ignored, and the insertion offset is determined by the lower bits of the immediate value.\n",
    "Alias": []
  },
  {
    "Name": "VINSERTI64x4",
    "Brief": "Insert 256 bits of packed quadword integer values into destination operand",
    "Description": "\nThese instructions insert packed integer values from the second source operand into the destination operand at specific offsets:\n\nVINSERTI32x4 and VINSERTI64x2 insert 128-bits of packed integer values from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nVINSERTI32x8 and VINSERTI64x4 insert 256-bits of packed integer values from the second source operand into the destination operand at a 256-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be a YMM register or a 256-bit memory location.\n\nVINSERTI128 inserts 128-bits of packed integer data from the second source operand into the destination operand at a 128-bit granular offset. The remaining portions of the destination are copied from the first source operand. The second source operand can be an XMM register or a 128-bit memory location.\n\nThe instructions support writemask for selective updating of destination operand elements. The high bits of the immediate are typically ignored, and the insertion offset is determined by the lower bits of the immediate value.\n",
    "Alias": []
  },
  {
    "Name": "VMASKMOVPS",
    "Brief": "Conditionally load or store packed single-precision values using a mask",
    "Description": "\nConditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.\n\nThe mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is:\n- Copied from the second source operand to the destination operand in load form\n- Set to zero in load form\n- Unmodified in store form\n\nThe second source operand is a memory address for load form, and the destination operand is a memory address for store form. The other operands are XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).\n\nKey characteristics:\n- Faults occur only due to mask-bit required memory accesses\n- No faults will occur if mask bits are zero\n- No nontemporal hint is applied\n- Should not be used for memory-mapped I/O or uncached memory\n- Paging A and D bits are set in an implementation-dependent way\n\nSupports both single-precision (PS) and double-precision (PD) floating-point data types with 128-bit and 256-bit variants.\n",
    "Alias": []
  },
  {
    "Name": "VMASKMOVPD",
    "Brief": "Conditionally load or store packed double-precision values using a mask",
    "Description": "\nConditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.\n\nThe mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is:\n- Copied from the second source operand to the destination operand in load form\n- Set to zero in load form\n- Unmodified in store form\n\nThe second source operand is a memory address for load form, and the destination operand is a memory address for store form. The other operands are XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).\n\nKey characteristics:\n- Faults occur only due to mask-bit required memory accesses\n- No faults will occur if mask bits are zero\n- No nontemporal hint is applied\n- Should not be used for memory-mapped I/O or uncached memory\n- Paging A and D bits are set in an implementation-dependent way\n\nSupports both single-precision (PS) and double-precision (PD) floating-point data types with 128-bit and 256-bit variants.\n",
    "Alias": []
  },
  {
    "Name": "VMAXPH",
    "Brief": "Return maximum of packed FP16 values",
    "Description": "\nThis instruction performs a SIMD compare of the packed FP16 values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of VMAXPH can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcast from a 16-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VMAXSH",
    "Brief": "Return the maximum of scalar FP16 values",
    "Description": "\nThis instruction performs a compare of the low packed FP16 values in the first source operand and the second source operand and returns the maximum value for the pair of values to the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of VMAXSH can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VMINPH",
    "Brief": "Return minimum of packed FP16 values",
    "Description": "\nThis instruction performs a SIMD compare of the packed FP16 values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of VMINPH can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcast from a 16-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VMINSH",
    "Brief": "Return the minimum low FP16 value between two operands",
    "Description": "\nThis instruction performs a compare of the low packed FP16 values in the first source operand and the second source operand and returns the minimum value for the pair of values to the destination operand.\n\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\n\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of VMINSH can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcast from a 16-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VMOVSH",
    "Brief": "Move Scalar FP16 Value",
    "Description": "\nThis instruction moves a FP16 (16-bit floating point) value to a register or memory location.\n\nThe instruction supports multiple forms of operation:\n1. Loading a FP16 value from memory to a register\n2. Storing a FP16 value from a register to memory\n3. Moving a FP16 value between registers while preserving other bits\n\nThe instruction supports writemask (k1) which allows conditional move/store operations:\n- If k1[0] is set or no writemask is used, the operation is performed\n- If k1[0] is clear and zeroing mask is used, the destination is set to zero\n- If k1[0] is clear and no zeroing mask is used, the destination remains unchanged\n\nThe two register-only forms are aliases that differ only in their operand encoding, which is a side effect of the selected encodings.\n\nThe instruction is part of the AVX512-FP16 instruction set and operates on 16-bit floating point values.\n",
    "Alias": []
  },
  {
    "Name": "VMOVW",
    "Brief": "Copy a word between XMM register and general-purpose register or memory location",
    "Description": "\nThis instruction either (a) copies one word element from an XMM register to a general-purpose register or memory location or (b) copies one word element from a general-purpose register or memory location to an XMM register. \n\nWhen writing a general-purpose register, the lower 16-bits of the register will contain the word value. The upper bits of the general-purpose register are written with zeros.\n\nThere are two variants of the instruction:\n1. EVEX.128.66.MAP5.WIG 6E /r VMOVW xmm1, reg/m16: Copies a word from a register or memory location to an XMM register.\n2. EVEX.128.66.MAP5.WIG 7E /r VMOVW reg/m16, xmm1: Copies a word from an XMM register to a register or memory location.\n\nThe instruction is part of the AVX512-FP16 instruction set and operates on 16-bit word elements.\n",
    "Alias": []
  },
  {
    "Name": "VMULPH",
    "Brief": "Multiply packed FP16 values",
    "Description": "\nThis instruction multiplies packed FP16 values from source operands and stores the packed FP16 result in the destination operand. The destination elements are updated according to the writemask.\n\nThe instruction supports three vector lengths: 128-bit (4 FP16 values), 256-bit (8 FP16 values), and 512-bit (16 FP16 values). It can operate on registers or memory sources, with optional broadcast for memory sources.\n\nKey features include:\n- Supports masked and non-masked operations\n- Supports zeroing and merging masking modes\n- Provides rounding control for 512-bit vector operations\n- Can use broadcast for memory sources, allowing a single FP16 value to be multiplied across all destination elements\n\nThe instruction is part of the AVX512-FP16 instruction set and requires specific CPUID feature flags.\n",
    "Alias": []
  },
  {
    "Name": "VMULSH",
    "Brief": "Multiply Scalar FP16 Values",
    "Description": "\nThis instruction multiplies the low FP16 value from the source operands and stores the FP16 result in the destination operand. Bits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nSpecifically, the instruction performs the following operations:\n1. Multiplies the low 16-bit FP16 value from the source operands\n2. Stores the result in the low 16 bits of the destination operand\n3. Copies bits 127:16 from the first source operand to the destination\n4. Zeros out the upper bits of the destination operand\n\nThe instruction supports rounding modes and can use a writemask to conditionally update the result.\n",
    "Alias": []
  },
  {
    "Name": "VP2INTERSECTD",
    "Brief": "Compute intersection between dwords to a pair of mask registers",
    "Description": "\nThis instruction writes an even/odd pair of mask registers. The mask register destination indicated in the MODRM.REG field is used to form the basis of the register pair. The low bit of that field is masked off (set to zero) to create the first register of the pair.\n\nThe instruction compares each element in the source vectors for matches. For VP2INTERSECTD, it compares 32-bit (dword) elements, and for VP2INTERSECTQ, it compares 64-bit (quadword) elements. \n\nWhen a match is found between elements from the two source vectors, the corresponding bits are set in the destination mask register pair:\n- The first mask register (even-numbered) indicates which elements in the first source vector had matches\n- The second mask register (odd-numbered) indicates which elements in the second source vector had matches\n\nEVEX.aaa and EVEX.z must be zero.\n\nThere are variants for 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector lengths, with support for broadcast modes for memory operands.\n",
    "Alias": []
  },
  {
    "Name": "VP2INTERSECTQ",
    "Brief": "Compute intersection between quadwords to a pair of mask registers",
    "Description": "\nThis instruction writes an even/odd pair of mask registers. The mask register destination indicated in the MODRM.REG field is used to form the basis of the register pair. The low bit of that field is masked off (set to zero) to create the first register of the pair.\n\nThe instruction compares each element in the source vectors for matches. For VP2INTERSECTD, it compares 32-bit (dword) elements, and for VP2INTERSECTQ, it compares 64-bit (quadword) elements. \n\nWhen a match is found between elements from the two source vectors, the corresponding bits are set in the destination mask register pair:\n- The first mask register (even-numbered) indicates which elements in the first source vector had matches\n- The second mask register (odd-numbered) indicates which elements in the second source vector had matches\n\nEVEX.aaa and EVEX.z must be zero.\n\nThere are variants for 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector lengths, with support for broadcast modes for memory operands.\n",
    "Alias": []
  },
  {
    "Name": "VPBLENDD",
    "Brief": "Select dwords from source operands based on mask and store into destination",
    "Description": "\nDword elements from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding dword in the destination is copied from the source. If a bit in the mask, corresponding to a dword, is \"1\", then the dword is copied, else the dword is unchanged.\n\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\n\nThe instruction essentially allows selective blending of 32-bit (dword) elements from two source vectors based on a byte mask.\n",
    "Alias": []
  },
  {
    "Name": "VPBLENDMB",
    "Brief": "Blend byte integer vectors using an opmask control",
    "Description": "\nPerforms an element-by-element blending of byte/word elements between the first source operand byte vector register and the second source operand byte vector from memory or register, using the instruction mask as selector. The result is written into the destination byte vector register.\n\nThe destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit memory location.\n\nThe mask is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for first source, 1 for second source).\n",
    "Alias": []
  },
  {
    "Name": "VPBLENDMW",
    "Brief": "Blend word integer vectors using an opmask control",
    "Description": "\nPerforms an element-by-element blending of byte/word elements between the first source operand byte vector register and the second source operand byte vector from memory or register, using the instruction mask as selector. The result is written into the destination byte vector register.\n\nThe destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit memory location.\n\nThe mask is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for first source, 1 for second source).\n",
    "Alias": []
  },
  {
    "Name": "VPBLENDMD",
    "Brief": "Blend doubleword integer vector using an OpMask control",
    "Description": "\nPerforms an element-by-element blending of dword/qword elements between the first source operand (the second operand) and the elements of the second source operand (the third operand) using an opmask register as select control. The blended result is written into the destination.\n\nThe destination and first source operands are ZMM registers. The second source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location.\n\nThe opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for the first source operand, 1 for the second source operand).\n\nIf EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VPBLENDMQ",
    "Brief": "Blend quadword integer vector using an OpMask control",
    "Description": "\nPerforms an element-by-element blending of dword/qword elements between the first source operand (the second operand) and the elements of the second source operand (the third operand) using an opmask register as select control. The blended result is written into the destination.\n\nThe destination and first source operands are ZMM registers. The second source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location.\n\nThe opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for the first source operand, 1 for the second source operand).\n\nIf EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VPBROADCASTB",
    "Brief": "Broadcast a byte integer to multiple locations in a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VPBROADCASTW",
    "Brief": "Broadcast a word integer to multiple locations in a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VPBROADCASTD",
    "Brief": "Broadcast a double word integer to multiple locations in a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VPBROADCASTQ",
    "Brief": "Broadcast a quad word integer to multiple locations in a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTI32x2",
    "Brief": "Broadcast two 32-bit integers to multiple locations in a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTI128",
    "Brief": "Broadcast 128 bits of data to lower and higher 128-bit regions",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTI32x4",
    "Brief": "Broadcast 128 bits of 4 double word integers to a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTI64x2",
    "Brief": "Broadcast 128 bits of 2 quad word integers to a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTI32x8",
    "Brief": "Broadcast 256 bits of 8 double word integers to a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VBROADCASTI64x4",
    "Brief": "Broadcast 256 bits of 4 quad word integers to a vector register",
    "Description": "\nLoad integer data from the source operand and broadcast to all elements of the destination operand. The instruction supports different vector register sizes (128-bit, 256-bit, and 512-bit) and various data types (byte, word, double word, quad word).\n\nKey characteristics:\n- Source can be a register or memory location\n- Destination is a vector register (XMM, YMM, or ZMM)\n- Supports writemask and masking operations (EVEX encoded versions)\n- Upper bits of the destination register are zeroed for VEX encoded versions\n- Supports different broadcast patterns depending on the specific instruction variant\n\nThe broadcast instructions are useful for SIMD operations where the same value needs to be replicated across multiple vector elements, enabling efficient data manipulation and vectorized computations.\n\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise an #UD exception will be generated.\n",
    "Alias": []
  },
  {
    "Name": "VPBROADCASTMB2Q",
    "Brief": "Broadcast low byte value from mask register to vector register",
    "Description": "\nBroadcasts the zero-extended 64/32 bit value of the low byte/word of the source operand (the second operand) to each 64/32 bit element of the destination operand (the first operand). The source operand is an opmask register. The destination operand is a ZMM register (EVEX.512), YMM register (EVEX.256), or XMM register (EVEX.128).\n\nThere are two variants of this instruction:\n- VPBROADCASTMB2Q: Broadcasts the low byte of the mask register to 64-bit elements\n- VPBROADCASTMW2D: Broadcasts the low word of the mask register to 32-bit elements\n\nThe instruction supports different vector lengths:\n- 128-bit (XMM): 2 or 4 elements depending on the instruction\n- 256-bit (YMM): 4 or 8 elements\n- 512-bit (ZMM): 8 or 16 elements\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPBROADCASTMW2D",
    "Brief": "Broadcast low word value from mask register to vector register",
    "Description": "\nBroadcasts the zero-extended 64/32 bit value of the low byte/word of the source operand (the second operand) to each 64/32 bit element of the destination operand (the first operand). The source operand is an opmask register. The destination operand is a ZMM register (EVEX.512), YMM register (EVEX.256), or XMM register (EVEX.128).\n\nThere are two variants of this instruction:\n- VPBROADCASTMB2Q: Broadcasts the low byte of the mask register to 64-bit elements\n- VPBROADCASTMW2D: Broadcasts the low word of the mask register to 32-bit elements\n\nThe instruction supports different vector lengths:\n- 128-bit (XMM): 2 or 4 elements depending on the instruction\n- 256-bit (YMM): 4 or 8 elements\n- 512-bit (ZMM): 8 or 16 elements\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPCMPB",
    "Brief": "Compare packed signed byte values into mask",
    "Description": "\nPerforms a SIMD compare of the packed byte values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).\n\nVPCMPB performs a comparison between pairs of signed byte values.\n\nVPCMPUB performs a comparison between pairs of unsigned byte values.\n\nThe first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask register k1. Up to 64/32/16 comparisons are performed with results written to the destination operand under the writemask k2.\n\nThe comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonics like VPCMPEQ, VPCMPLT, VPCMPLE, VPCMPNEQ, etc.\n\nPossible comparison operations include:\n- Equal (EQ)\n- Less Than (LT)\n- Less or Equal (LE)\n- Not Equal (NEQ)\n- Not Less Than (NLT)\n- Not Less or Equal (NLE)\n",
    "Alias": []
  },
  {
    "Name": "VPCMPUB",
    "Brief": "Compare packed unsigned byte values into mask",
    "Description": "\nPerforms a SIMD compare of the packed byte values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).\n\nVPCMPB performs a comparison between pairs of signed byte values.\n\nVPCMPUB performs a comparison between pairs of unsigned byte values.\n\nThe first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask register k1. Up to 64/32/16 comparisons are performed with results written to the destination operand under the writemask k2.\n\nThe comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonics like VPCMPEQ, VPCMPLT, VPCMPLE, VPCMPNEQ, etc.\n\nPossible comparison operations include:\n- Equal (EQ)\n- Less Than (LT)\n- Less or Equal (LE)\n- Not Equal (NEQ)\n- Not Less Than (NLT)\n- Not Less or Equal (NLE)\n",
    "Alias": []
  },
  {
    "Name": "VPCMPD",
    "Brief": "Compare packed signed doubleword integer values and generate a mask",
    "Description": "\nPerforms a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).\n\nVPCMPD/VPCMPUD performs a comparison between pairs of signed/unsigned doubleword integer values.\n\nThe first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register k1. Up to 16/8/4 comparisons are performed with results written to the destination operand under the writemask k2.\n\nThe comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the following comparison predicates:\n- 0: Equal (EQ)\n- 1: Less Than (LT)\n- 2: Less Than or Equal (LE)\n- 3: Always False\n- 4: Not Equal (NEQ)\n- 5: Not Less Than (NLT)\n- 6: Not Less Than or Equal (NLE)\n- 7: Always True\n",
    "Alias": []
  },
  {
    "Name": "VPCMPUD",
    "Brief": "Compare packed unsigned doubleword integer values and generate a mask",
    "Description": "\nPerforms a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).\n\nVPCMPD/VPCMPUD performs a comparison between pairs of signed/unsigned doubleword integer values.\n\nThe first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register k1. Up to 16/8/4 comparisons are performed with results written to the destination operand under the writemask k2.\n\nThe comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the following comparison predicates:\n- 0: Equal (EQ)\n- 1: Less Than (LT)\n- 2: Less Than or Equal (LE)\n- 3: Always False\n- 4: Not Equal (NEQ)\n- 5: Not Less Than (NLT)\n- 6: Not Less Than or Equal (NLE)\n- 7: Always True\n",
    "Alias": []
  },
  {
    "Name": "VPCMPQ",
    "Brief": "Compare packed signed quadword integer values into mask",
    "Description": "\nPerforms a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).\n\nVPCMPQ/VPCMPUQ performs a comparison between pairs of signed/unsigned quadword integer values.\n\nThe first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register k1. Up to 8/4/2 comparisons are performed with results written to the destination operand under the writemask k2.\n\nThe comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-21.\n\nThe comparison types include:\n- Equal (EQ)\n- Less Than (LT)\n- Less Than or Equal (LE)\n- Not Equal (NEQ)\n- Not Less Than (NLT)\n- Not Less Than or Equal (NLE)\n",
    "Alias": []
  },
  {
    "Name": "VPCMPUQ",
    "Brief": "Compare packed unsigned quadword integer values into mask",
    "Description": "\nPerforms a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).\n\nVPCMPQ/VPCMPUQ performs a comparison between pairs of signed/unsigned quadword integer values.\n\nThe first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register k1. Up to 8/4/2 comparisons are performed with results written to the destination operand under the writemask k2.\n\nThe comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-21.\n\nThe comparison types include:\n- Equal (EQ)\n- Less Than (LT)\n- Less Than or Equal (LE)\n- Not Equal (NEQ)\n- Not Less Than (NLT)\n- Not Less Than or Equal (NLE)\n",
    "Alias": []
  },
  {
    "Name": "VPCMPW",
    "Brief": "Compare packed signed word integers into mask",
    "Description": "\nPerforms a SIMD compare of the packed integer word in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).\n\nVPCMPW performs a comparison between pairs of signed word values.\n\nVPCMPUW performs a comparison between pairs of unsigned word values.\n\nThe first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask register k1. Up to 32/16/8 comparisons are performed with results written to the destination operand under the writemask k2.\n\nThe comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Possible comparison predicates include:\n- 0: Equal (EQ)\n- 1: Less Than (LT)\n- 2: Less Than or Equal (LE)\n- 3: Always False\n- 4: Not Equal (NEQ)\n- 5: Not Less Than (NLT)\n- 6: Not Less Than or Equal (NLE)\n- 7: Always True\n",
    "Alias": []
  },
  {
    "Name": "VPCMPUW",
    "Brief": "Compare packed unsigned word integers into mask",
    "Description": "\nPerforms a SIMD compare of the packed integer word in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).\n\nVPCMPW performs a comparison between pairs of signed word values.\n\nVPCMPUW performs a comparison between pairs of unsigned word values.\n\nThe first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask register k1. Up to 32/16/8 comparisons are performed with results written to the destination operand under the writemask k2.\n\nThe comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Possible comparison predicates include:\n- 0: Equal (EQ)\n- 1: Less Than (LT)\n- 2: Less Than or Equal (LE)\n- 3: Always False\n- 4: Not Equal (NEQ)\n- 5: Not Less Than (NLT)\n- 6: Not Less Than or Equal (NLE)\n- 7: Always True\n",
    "Alias": []
  },
  {
    "Name": "VPCOMPRESSD",
    "Brief": "Store Sparse Packed Doubleword Integer Values Into Dense Memory/Register",
    "Description": "\nCompress (store) up to 16/8/4 doubleword integer values from the source operand (second operand) to the destination operand (first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\n\nThe opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 16 active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the destination starting from the low element of the destination operand.\n\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.\n\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector.\n",
    "Alias": []
  },
  {
    "Name": "VPCOMPRESSQ",
    "Brief": "Store sparse packed quadword integer values into dense memory/register",
    "Description": "\nCompress (stores) up to 8/4/2 quadword integer values from the source operand (second operand) to the destination operand (first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\n\nThe opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 8 active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the destination starting from the low element of the destination operand.\n\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.\n\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector.\n",
    "Alias": []
  },
  {
    "Name": "VPCONFLICTD",
    "Brief": "Detect duplicate double-word values in a vector",
    "Description": "\nTest each dword/qword element of the source operand (the second operand) for equality with all other elements in the source operand closer to the least significant element. Each element's comparison results form a bit vector, which is then zero extended and written to the destination according to the writemask.\n\nEVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\n\nEVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nFor VPCONFLICTD, the instruction checks 32-bit (double-word) elements, while for VPCONFLICTQ, the instruction checks 64-bit (quad-word) elements. The result is a bit vector indicating if each element is a duplicate of any previous element in the source vector.\n",
    "Alias": []
  },
  {
    "Name": "VPCONFLICTQ",
    "Brief": "Detect duplicate quad-word values in a vector",
    "Description": "\nTest each dword/qword element of the source operand (the second operand) for equality with all other elements in the source operand closer to the least significant element. Each element's comparison results form a bit vector, which is then zero extended and written to the destination according to the writemask.\n\nEVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\n\nEVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nFor VPCONFLICTD, the instruction checks 32-bit (double-word) elements, while for VPCONFLICTQ, the instruction checks 64-bit (quad-word) elements. The result is a bit vector indicating if each element is a duplicate of any previous element in the source vector.\n",
    "Alias": []
  },
  {
    "Name": "VPDPBUSD",
    "Brief": "Multiply and Add Unsigned and Signed Bytes",
    "Description": "\nMultiplies the individual unsigned bytes of the first source operand by the corresponding signed bytes of the second source operand, producing intermediate signed word results. The word results are then summed and accumulated in the destination dword element size operand.\n\nThe instruction performs the following steps:\n1. Zero-extend the unsigned bytes from the first source operand to 16-bit words\n2. Sign-extend the signed bytes from the second source operand to 16-bit words\n3. Multiply the corresponding pairs of bytes\n4. Sum the resulting word products\n5. Add the sum to the corresponding doubleword in the destination operand\n\nThis instruction supports memory fault suppression and comes in VEX and EVEX encoded versions for 128-bit, 256-bit, and 512-bit vector registers. The EVEX versions provide additional features like write masks and broadcasting.\n",
    "Alias": []
  },
  {
    "Name": "VPDPBUSDS",
    "Brief": "Multiply and Add Unsigned and Signed Bytes With Saturation",
    "Description": "\nMultiplies the individual unsigned bytes of the first source operand by the corresponding signed bytes of the second source operand, producing intermediate signed word results. The word results are then summed and accumulated in the destination dword element size operand. If the intermediate sum overflows a 32b signed number the result is saturated to either 0x7FFF_FFFF for positive numbers of 0x8000_0000 for negative numbers.\n\nThe instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) using VEX and EVEX encodings. For EVEX-encoded versions, the instruction supports writemask and broadcasting capabilities.\n\nKey characteristics:\n- Performs byte-wise multiplication of unsigned and signed bytes\n- Accumulates the products into 32-bit destination elements\n- Provides signed saturation to prevent overflow\n- Supports various vector register sizes and masking operations\n",
    "Alias": []
  },
  {
    "Name": "VPDPWSSD",
    "Brief": "Multiply and Add Signed Word Integers",
    "Description": "\nMultiplies the individual signed words of the first source operand by the corresponding signed words of the second source operand, producing intermediate signed, doubleword results. The adjacent doubleword results are then summed and accumulated in the destination operand.\n\nThis instruction supports memory fault suppression.\n\nThe instruction operates in different vector lengths:\n- VEX.128: Operates on 128-bit vectors, processing 4 doublewords\n- VEX.256: Operates on 256-bit vectors, processing 8 doublewords\n- EVEX.512: Operates on 512-bit vectors, processing 16 doublewords\n\nThe operation involves:\n1. Sign-extending signed words\n2. Multiplying corresponding words\n3. Summing the products\n4. Accumulating results in the destination operand\n\nEVEX encoded versions support masking and broadcast operations, allowing selective processing and efficient memory access.\n",
    "Alias": []
  },
  {
    "Name": "VPDPWSSDS",
    "Brief": "Multiply and Add Signed Word Integers With Saturation",
    "Description": "\nMultiplies the individual signed words of the first source operand by the corresponding signed words of the second source operand, producing intermediate signed, doubleword results. The adjacent doubleword results are then summed and accumulated in the destination operand. \n\nIf the intermediate sum overflows a 32-bit signed number, the result is saturated to either 0x7FFF_FFFF for positive numbers or 0x8000_0000 for negative numbers.\n\nThe instruction supports multiple vector lengths (128-bit, 256-bit, and 512-bit) and can operate with or without write masks in EVEX-encoded versions. It can work with registers or memory operands, and supports broadcast for memory sources in EVEX-encoded versions.\n\nThis instruction supports memory fault suppression and is part of the AVX-VNNI (Vector Neural Network Instructions) instruction set.\n",
    "Alias": []
  },
  {
    "Name": "VPERM2F128",
    "Brief": "Permute 128-bit floating-point fields between two source vectors",
    "Description": "\nThis instruction permutes 128-bit floating-point fields from two source operands (first and second source operands) and stores the result in the destination operand.\n\nThe 8-bit immediate value (imm8) controls the permutation:\n- Bits [1:0] select the source for the first destination 128-bit field\n- Bits [5:4] select the source for the second destination field\n- If bit [3] is set, the low 128-bit field is zeroed\n- If bit [7] is set, the high 128-bit field is zeroed\n\nPossible source selections:\n- 0: First 128 bits of first source\n- 1: Second 128 bits of first source\n- 2: First 128 bits of second source\n- 3: Second 128 bits of second source\n\nThe instruction is only valid when VEX.L is set to 1, otherwise it will generate an #UD (Undefined Instruction) exception.\n\nThe first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.\n",
    "Alias": []
  },
  {
    "Name": "VPERM2I128",
    "Brief": "Permute 128-bit integer values from source operands",
    "Description": "\nPermute 128 bit integer data from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand).\n\nThe first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.\n\nImm8[1:0] select the source for the first destination 128-bit field, imm8[5:4] select the source for the second destination field. If imm8[3] is set, the low 128-bit field is zeroed. If imm8[7] is set, the high 128-bit field is zeroed.\n\nVEX.L must be 1, otherwise the instruction will #UD.\n\nThe instruction allows flexible selection of 128-bit source fields from two source YMM registers, with optional zeroing of destination fields based on the immediate byte control bits.\n",
    "Alias": []
  },
  {
    "Name": "VPERMB",
    "Brief": "Permute packed bytes elements using byte indexes",
    "Description": "\nCopies bytes from the second source operand (the third operand) to the destination operand (the first operand) according to the byte indices in the first source operand (the second operand). \n\nKey characteristics:\n- Permits a byte in the source operand to be copied to more than one location in the destination operand\n- Only the low 6 (EVEX.512), 5 (EVEX.256), or 4 (EVEX.128) bits of each byte index are used to select the source byte location\n- First source operand is a ZMM/YMM/XMM register\n- Second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location\n- Destination operand is a ZMM/YMM/XMM register updated at byte granularity using a writemask\n\nThe instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and provides flexible byte-level permutation across the source operands.\n",
    "Alias": []
  },
  {
    "Name": "VPERMD",
    "Brief": "Permute packed doubleword elements",
    "Description": "\nCopies doublewords (or words) from the second source operand (the third operand) to the destination operand (the first operand) according to the indices in the first source operand (the second operand). Note that this instruction permits a doubleword (word) in the source operand to be copied to more than one location in the destination operand.\n\nVEX.256 encoded VPERMD: The first and second operands are YMM registers, the third operand can be a YMM register or memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded VPERMD: The first and second operands are ZMM/YMM registers, the third operand can be a ZMM/YMM register, a 512/256-bit memory location or a 512/256-bit vector broadcasted from a 32-bit memory location. The elements in the destination are updated using the writemask k1.\n\nVPERMW: first and second operands are ZMM/YMM/XMM registers, the third operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination is updated using the writemask k1.\n\nEVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VPERMW",
    "Brief": "Permute packed word integers",
    "Description": "\nCopies doublewords (or words) from the second source operand (the third operand) to the destination operand (the first operand) according to the indices in the first source operand (the second operand). Note that this instruction permits a doubleword (word) in the source operand to be copied to more than one location in the destination operand.\n\nVEX.256 encoded VPERMD: The first and second operands are YMM registers, the third operand can be a YMM register or memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded VPERMD: The first and second operands are ZMM/YMM registers, the third operand can be a ZMM/YMM register, a 512/256-bit memory location or a 512/256-bit vector broadcasted from a 32-bit memory location. The elements in the destination are updated using the writemask k1.\n\nVPERMW: first and second operands are ZMM/YMM/XMM registers, the third operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination is updated using the writemask k1.\n\nEVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\n",
    "Alias": []
  },
  {
    "Name": "VPERMI2B",
    "Brief": "Full Permute of Bytes From Two Tables Overwriting the Index",
    "Description": "\nPermutes byte values in the second operand (the first source operand) and the third operand (the second source operand) using the byte indices in the first operand (the destination operand) to select byte elements from the second or third source operands. The selected byte elements are written to the destination at byte granularity under the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result. The third operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. In each index byte, the id bit for table selection is bit 6/5/4, and bits [5:0]/[4:0]/[3:0] selects element within each input table.\n\nThese instructions permit a byte value in the source operands to be copied to more than one location in the destination operand. Also, the same tables can be reused in subsequent iterations, but the index elements are overwritten.\n\nBits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMI2W",
    "Brief": "Permute word integers from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same table can be reused, for example, for a second iteration, while the index elements are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMI2D",
    "Brief": "Permute double-words from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same table can be reused, for example, for a second iteration, while the index elements are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMI2Q",
    "Brief": "Permute quad-words from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same table can be reused, for example, for a second iteration, while the index elements are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMI2PS",
    "Brief": "Permute single-precision floating-point values from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same table can be reused, for example, for a second iteration, while the index elements are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMI2PD",
    "Brief": "Permute double-precision floating-point values from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same table can be reused, for example, for a second iteration, while the index elements are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMILPD",
    "Brief": "Permute pairs of double precision floating-point values within lanes",
    "Description": "\nThe VPERMILPD instruction permutes pairs of double precision floating-point values in the source operand using control bits.\n\nThere are two main versions of the instruction:\n1. Immediate Control Version: Uses an immediate byte (imm8) to specify permutation control bits for each pair.\n2. Variable Control Version: Uses a second source operand to provide permutation control bits.\n\nKey characteristics:\n- Operates on 128-bit (XMM), 256-bit (YMM), or 512-bit (ZMM) registers\n- Each 64-bit double precision floating-point value can be swapped within its 128-bit lane\n- Control bits are located at bit 0 of each quadword element\n- Supports both masked and unmasked operations in EVEX-encoded versions\n- Can broadcast from a 64-bit memory location in EVEX versions\n\nThe control bits determine which source element in an input pair is selected for the destination element. Each pair of source elements must lie in the same 128-bit region as the destination.\n\nEVEX versions support additional features like writemasks and broadcasting.\n",
    "Alias": []
  },
  {
    "Name": "VPERMILPS",
    "Brief": "Permute single-precision floating-point values within quadruples",
    "Description": "\nThe VPERMILPS instruction performs permutation of single-precision floating-point values within quadruples using two different methods:\n\n1. Variable Control Version:\n- Permutes quadruples of single-precision floating-point values in the first source operand\n- Each quadruplet uses a 2-bit control field in the corresponding dword element of the second source operand\n- Each 2-bit control field determines which source element in an input quadruple is selected for the destination element\n- Each quadruple of source elements must lie in the same 128-bit region as the destination\n\n2. Immediate Control Version:\n- Permutes quadruples of single-precision floating-point values in the first source operand\n- Uses a 2-bit control field in the imm8 byte for each quadruplet\n- Each 128-bit lane in the destination operand uses the four control fields of the same imm8 byte\n\nThe instruction supports different vector register sizes (XMM, YMM, ZMM) and provides variants with and without write masking. The permutation is performed using a Select4 function that chooses one of four 32-bit elements from a 128-bit source based on the 2-bit control field.\n\nNote: For immediate versions, VEX.vvvv and EVEX.vvvv must be 1111b, otherwise an undefined instruction (#UD) exception is raised.\n",
    "Alias": []
  },
  {
    "Name": "VPERMPD",
    "Brief": "Permute double precision floating-point elements",
    "Description": "\nThe VPERMPD instruction copies quadword elements of double precision floating-point values from the source operand to the destination operand according to the specified indices.\n\nThere are two main forms of the instruction:\n1. Immediate (imm8) control form: \n   - Uses a two-bit value in the immediate byte to select which quadword element to copy\n   - Each two-bit value selects a qword element from the source operand\n   - Supports VEX and EVEX encoded versions for 256-bit and 512-bit vectors\n\n2. Vector control form:\n   - Uses the first source operand (index operand) to determine which quadword to copy\n   - The first 3 bits of each 64-bit element in the index operand select the source quadword\n   - Supports EVEX encoded versions for 256-bit and 512-bit vectors\n\nKey characteristics:\n- Permits copying a qword from the source operand to multiple locations in the destination\n- Supports write masking in EVEX encoded versions\n- Can broadcast from a 64-bit memory location in EVEX versions\n- VEX versions zero out upper bits of the destination register\n\nThe instruction is available for 256-bit and 512-bit vector registers with support for AVX2, AVX512VL, and AVX512F feature flags.\n",
    "Alias": []
  },
  {
    "Name": "VPERMPS",
    "Brief": "Permute single-precision floating-point elements",
    "Description": "\nCopies doubleword elements of single-precision floating-point values from the second source operand (the third operand) to the destination operand (the first operand) according to the indices in the first source operand (the second operand). Note that this instruction permits a doubleword in the source operand to be copied to more than one location in the destination operand.\n\nVEX.256 versions: The first and second operands are YMM registers, the third operand can be a YMM register or memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX encoded version: The first and second operands are ZMM registers, the third operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The elements in the destination are updated using the writemask k1.\n\nIf VPERMPS is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception.\n",
    "Alias": []
  },
  {
    "Name": "VPERMQ",
    "Brief": "Permute qwords using indices from immediate or vector control",
    "Description": "\nThe VPERMQ instruction allows permutation of quadwords (64-bit elements) in a vector register using two different methods:\n\n1. Immediate (imm8) Control Version:\n- Copies quadwords from the source operand to the destination operand\n- Each two-bit value in the immediate byte selects a qword element in the source operand\n- Supports 256-bit (VEX) and 512-bit (EVEX) vector registers\n- Bits in the immediate control which source qword is copied to each destination position\n\n2. Vector Control Version:\n- Copies quadwords from the second source operand to the destination operand\n- The first source operand contains indices that determine which quadword to copy\n- The first 3 bits of each 64-bit element in the index operand select the source quadword\n- Supports 512-bit vector registers with writemask capability\n\nKey characteristics:\n- A quadword in the source can be copied to multiple locations in the destination\n- Supports various vector lengths (256-bit and 512-bit)\n- Uses writemask for conditional updates in EVEX-encoded versions\n- Zeroes upper bits of destination register not covered by the operation\n\nEncoding variations include VEX and EVEX formats with different vector lengths and control methods.\n",
    "Alias": []
  },
  {
    "Name": "VPERMT2B",
    "Brief": "Full Permute of Bytes From Two Tables Overwriting a Table",
    "Description": "\nPermutes byte values from two tables, comprising of the first operand (also the destination operand) and the third operand (the second source operand). The second operand (the first source operand) provides byte indices to select byte results from the two tables. The selected byte elements are written to the destination at byte granularity under the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result. The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. In each index byte, the id bit for table selection is bit 6/5/4, and bits [5:0]/[4:0]/[3:0] selects element within each input table.\n\nNote that these instructions permit a byte value in the source operands to be copied to more than one location in the destination operand. Also, the second table and the indices can be reused in subsequent iterations, but the first table is overwritten.\n\nBits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMT2W",
    "Brief": "Permute 16-bit word integers from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same index can be reused for a second iteration, while the table elements being permuted are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMT2D",
    "Brief": "Permute 32-bit double-words from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same index can be reused for a second iteration, while the table elements being permuted are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMT2Q",
    "Brief": "Permute 64-bit quad-words from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same index can be reused for a second iteration, while the table elements being permuted are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMT2PS",
    "Brief": "Permute single-precision floating-point values from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same index can be reused for a second iteration, while the table elements being permuted are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPERMT2PD",
    "Brief": "Permute double-precision floating-point values from two tables using indices",
    "Description": "\nPermutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.\n\nThe first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.\n\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\n\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\n\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.\n\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.\n\nThese instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. The same index can be reused for a second iteration, while the table elements being permuted are overwritten.\n\nBits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.\n",
    "Alias": []
  },
  {
    "Name": "VPEXPANDB",
    "Brief": "Expands packed byte values from source to destination with writemask",
    "Description": "\nExpands (loads) up to 64 byte integer values or 32 word integer values from the source operand (memory operand) to the destination operand (register operand), based on the active elements determined by the writemask operand.\n\nMoves 128, 256 or 512 bits of packed byte or word integer values from the source operand (memory operand) to the destination operand (register operand). This instruction is used to load from an int8 or int16 vector register or memory location while inserting the data into sparse elements of destination vector register using the active elements pointed out by the operand writemask.\n\nKey characteristics:\n- Supports memory fault suppression\n- Compressed displacement assumes pre-scaling corresponding to single element size\n- EVEX.vvvv must be 1111b, otherwise instruction will cause #UD\n- Supports both merging and zeroing masking\n\nThe instruction can operate on different vector lengths (128, 256, and 512 bits) and can load from either memory or register sources.\n",
    "Alias": []
  },
  {
    "Name": "VPEXPANDW",
    "Brief": "Expands packed word values from source to destination with writemask",
    "Description": "\nExpands (loads) up to 64 byte integer values or 32 word integer values from the source operand (memory operand) to the destination operand (register operand), based on the active elements determined by the writemask operand.\n\nMoves 128, 256 or 512 bits of packed byte or word integer values from the source operand (memory operand) to the destination operand (register operand). This instruction is used to load from an int8 or int16 vector register or memory location while inserting the data into sparse elements of destination vector register using the active elements pointed out by the operand writemask.\n\nKey characteristics:\n- Supports memory fault suppression\n- Compressed displacement assumes pre-scaling corresponding to single element size\n- EVEX.vvvv must be 1111b, otherwise instruction will cause #UD\n- Supports both merging and zeroing masking\n\nThe instruction can operate on different vector lengths (128, 256, and 512 bits) and can load from either memory or register sources.\n",
    "Alias": []
  },
  {
    "Name": "VPEXPANDD",
    "Brief": "Load Sparse Packed Doubleword Integer Values From Dense Memory/Register",
    "Description": "\nExpand (load) up to 16 contiguous doubleword integer values of the input vector in the source operand (the second operand) to sparse elements in the destination operand (the first operand), selected by the writemask k1. The destination operand is a ZMM register, the source operand can be a ZMM register or memory location.\n\nThe input vector starts from the lowest element in the source operand. The opmask register k1 selects the destination elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed, depending on EVEX.z.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector.\n",
    "Alias": []
  },
  {
    "Name": "VPEXPANDQ",
    "Brief": "Load Sparse Packed Quadword Integer Values From Dense Memory/Register",
    "Description": "\nExpand (load) up to 8 quadword integer values from the source operand (the second operand) to sparse elements in the destination operand (the first operand), selected by the writemask k1. The destination operand is a ZMM register, the source operand can be a ZMM register or memory location.\n\nThe input vector starts from the lowest element in the source operand. The opmask register k1 selects the destination elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed, depending on EVEX.z.\n\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector.\n",
    "Alias": []
  },
  {
    "Name": "VPGATHERDD",
    "Brief": "Gather packed dword values using signed dword indices",
    "Description": "\nThe instruction conditionally loads up to 4 or 8 dword values from memory addresses specified by the memory operand using dword or qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\n\nThe mask operand specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand. Conditionality is specified by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the corresponding element of the destination register is left unchanged.\n\nKey characteristics of the instructions:\n- VEX.128 version: \n  - With dword indices: Gather four dword values\n  - With qword indices: Gather two values and zero the upper 64 bits of the destination\n\n- VEX.256 version:\n  - With dword indices: Gather eight dword values\n  - With qword indices: Gather four values and zero the upper 128 bits of the destination\n\nImportant notes:\n- If any pair of the index, mask, or destination registers are the same, this instruction results in a UD fault\n- Memory values may be read in any order\n- Faults are delivered in a right-to-left manner\n- This instruction does not perform AC checks\n- Should not be used for memory-mapped I/O due to implementation-specific load ordering\n",
    "Alias": []
  },
  {
    "Name": "VPGATHERQD",
    "Brief": "Gather packed dword values using signed qword indices",
    "Description": "\nThe instruction conditionally loads up to 4 or 8 dword values from memory addresses specified by the memory operand using dword or qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\n\nThe mask operand specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand. Conditionality is specified by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the corresponding element of the destination register is left unchanged.\n\nKey characteristics of the instructions:\n- VEX.128 version: \n  - With dword indices: Gather four dword values\n  - With qword indices: Gather two values and zero the upper 64 bits of the destination\n\n- VEX.256 version:\n  - With dword indices: Gather eight dword values\n  - With qword indices: Gather four values and zero the upper 128 bits of the destination\n\nImportant notes:\n- If any pair of the index, mask, or destination registers are the same, this instruction results in a UD fault\n- Memory values may be read in any order\n- Faults are delivered in a right-to-left manner\n- This instruction does not perform AC checks\n- Should not be used for memory-mapped I/O due to implementation-specific load ordering\n",
    "Alias": []
  },
  {
    "Name": "VPGATHERDQ",
    "Brief": "Gather packed quadword values from memory using signed dword indices",
    "Description": "\nA set of 16 or 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector VINDEX with scale SCALE are gathered. The result is written into vector zmm1. The elements are specified via the VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element's mask bit is not set, the corresponding element of the destination register (zmm1) is left unchanged.\n\nKey characteristics of the instructions include:\n- Values may be read from memory in any order\n- Faults are delivered in a right-to-left manner\n- Elements may be gathered in any order\n- Does not perform AC checks\n- Not valid with 16-bit effective addresses\n- Does not accept zeroing-masking\n\nThe instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and uses a writemask for merging-masking. The scaled index may require more bits to represent than the address bits used by the processor, in which case the most significant bits beyond the number of address bits are ignored.\n\nThe entire mask register will be set to zero by this instruction unless it triggers an exception. If an exception is triggered, the destination register and mask register are partially updated, with gathered elements placed into the destination register and their mask bits set to zero.\n",
    "Alias": []
  },
  {
    "Name": "VPGATHERQQ",
    "Brief": "Gather Packed Qword Values Using Signed Qword Indices",
    "Description": "\nThe instruction conditionally loads up to 2 or 4 qword values from memory addresses specified by the memory operand and using qword or dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\n\nThe mask operand specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand. Conditionality is specified by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the corresponding element of the destination register is left unchanged.\n\nKey characteristics of this instruction include:\n- VEX.128 version gathers two qword values\n- VEX.256 version gathers four qword values\n- Elements may be gathered in any order\n- Faults are delivered in a right-to-left manner\n- The instruction does not perform AC checks\n- Memory ordering follows the Intel-64 memory-ordering model\n\nCautions:\n- Cannot be used for memory mapped I/O\n- Causes a #UD if the address size attribute is 16-bit or memory operand is encoded without SIB byte\n- If any pair of index, mask, or destination registers are the same, it results in a UD fault\n\nThe instruction is useful for efficient, conditional gathering of qword values from memory using vectorized indexing.\n",
    "Alias": []
  },
  {
    "Name": "VPLZCNTD",
    "Brief": "Count the number of leading zero bits for each dword element",
    "Description": "\nCounts the number of leading most significant zero bits in each dword or qword element of the source operand (the second operand) and stores the results in the destination register (the first operand) according to the writemask. If an element is zero, the result for that element is the operand size of the element.\n\nEVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\n\nEVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VPLZCNTQ",
    "Brief": "Count the number of leading zero bits for each qword element",
    "Description": "\nCounts the number of leading most significant zero bits in each dword or qword element of the source operand (the second operand) and stores the results in the destination register (the first operand) according to the writemask. If an element is zero, the result for that element is the operand size of the element.\n\nEVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\n\nEVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VPMADD52HUQ",
    "Brief": "Multiply unsigned 52-bit integers and add high 52-bit products to 64-bit accumulators",
    "Description": "\nMultiplies packed unsigned 52-bit integers in each qword element of the first source operand (the second operand) with the packed unsigned 52-bit integers in the corresponding elements of the second source operand (the third operand) to form packed 104-bit intermediate results. The high 52-bit, unsigned integer of each 104-bit product is added to the corresponding qword unsigned integer of the destination operand (the first operand) under the writemask k1.\n\nThe first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 64-bit granularity.\n",
    "Alias": []
  },
  {
    "Name": "VPMADD52LUQ",
    "Brief": "Multiply unsigned 52-bit integers and add the low 52 bits of the product to qword unsigned integers",
    "Description": "\nMultiplies packed unsigned 52-bit integers in each qword element of the first source operand (the second operand) with the packed unsigned 52-bit integers in the corresponding elements of the second source operand (the third operand) to form packed 104-bit intermediate results. The low 52-bit, unsigned integer of each 104-bit product is added to the corresponding qword unsigned integer of the destination operand (the first operand) under the writemask k1.\n\nThe first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 64-bit granularity.\n",
    "Alias": []
  },
  {
    "Name": "VPMASKMOVD",
    "Brief": "Conditionally load or store 32-bit integer values with mask",
    "Description": "\nConditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.\n\nThe mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.\n\nThe second source operand is a memory address for the load form of these instructions. The destination operand is a memory address for the store form of these instructions. The other operands are either XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).\n\nFaults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0.\n\nUnlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.\n\nVMASKMOV should not be used to access memory mapped I/O as the ordering of the individual loads or stores is implementation specific.\n",
    "Alias": []
  },
  {
    "Name": "VPMASKMOVQ",
    "Brief": "Conditionally load or store 64-bit integer values with mask",
    "Description": "\nConditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.\n\nThe mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.\n\nThe second source operand is a memory address for the load form of these instructions. The destination operand is a memory address for the store form of these instructions. The other operands are either XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).\n\nFaults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0.\n\nUnlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.\n\nVMASKMOV should not be used to access memory mapped I/O as the ordering of the individual loads or stores is implementation specific.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVB2M",
    "Brief": "Convert bytes from vector register to mask register based on most significant bit",
    "Description": "\nConverts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on the value of most significant bit of the corresponding element in the source register.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.\n\nFor each instruction variant:\n- VPMOVB2M converts 8-bit elements by checking the most significant bit of each byte\n- VPMOVW2M converts 16-bit elements by checking the most significant bit of each word\n- VPMOVD2M converts 32-bit elements by checking the most significant bit of each doubleword\n- VPMOVQ2M converts 64-bit elements by checking the most significant bit of each quadword\n\nThe instructions support different vector register lengths (128-bit, 256-bit, and 512-bit) and have variations for different SIMD feature flags like AVX512VL, AVX512BW, and AVX512DQ.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVW2M",
    "Brief": "Convert words from vector register to mask register based on most significant bit",
    "Description": "\nConverts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on the value of most significant bit of the corresponding element in the source register.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.\n\nFor each instruction variant:\n- VPMOVB2M converts 8-bit elements by checking the most significant bit of each byte\n- VPMOVW2M converts 16-bit elements by checking the most significant bit of each word\n- VPMOVD2M converts 32-bit elements by checking the most significant bit of each doubleword\n- VPMOVQ2M converts 64-bit elements by checking the most significant bit of each quadword\n\nThe instructions support different vector register lengths (128-bit, 256-bit, and 512-bit) and have variations for different SIMD feature flags like AVX512VL, AVX512BW, and AVX512DQ.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVD2M",
    "Brief": "Convert doublewords from vector register to mask register based on most significant bit",
    "Description": "\nConverts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on the value of most significant bit of the corresponding element in the source register.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.\n\nFor each instruction variant:\n- VPMOVB2M converts 8-bit elements by checking the most significant bit of each byte\n- VPMOVW2M converts 16-bit elements by checking the most significant bit of each word\n- VPMOVD2M converts 32-bit elements by checking the most significant bit of each doubleword\n- VPMOVQ2M converts 64-bit elements by checking the most significant bit of each quadword\n\nThe instructions support different vector register lengths (128-bit, 256-bit, and 512-bit) and have variations for different SIMD feature flags like AVX512VL, AVX512BW, and AVX512DQ.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVQ2M",
    "Brief": "Convert quadwords from vector register to mask register based on most significant bit",
    "Description": "\nConverts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on the value of most significant bit of the corresponding element in the source register.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.\n\nFor each instruction variant:\n- VPMOVB2M converts 8-bit elements by checking the most significant bit of each byte\n- VPMOVW2M converts 16-bit elements by checking the most significant bit of each word\n- VPMOVD2M converts 32-bit elements by checking the most significant bit of each doubleword\n- VPMOVQ2M converts 64-bit elements by checking the most significant bit of each quadword\n\nThe instructions support different vector register lengths (128-bit, 256-bit, and 512-bit) and have variations for different SIMD feature flags like AVX512VL, AVX512BW, and AVX512DQ.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVDB",
    "Brief": "Down convert 32-bit integer elements to packed bytes using truncation",
    "Description": "\nVPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation. VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nThe instructions support different conversion methods:\n- VPMOVDB uses simple truncation\n- VPMOVSDB uses signed saturation\n- VPMOVUSDB uses unsigned saturation\n\nThese instructions are part of the AVX512 instruction set and support various vector lengths (128-bit, 256-bit, and 512-bit) with configurable write masks.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSDB",
    "Brief": "Convert signed 32-bit integers to packed signed bytes using signed saturation",
    "Description": "\nVPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation. VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nThe instructions support different conversion methods:\n- VPMOVDB uses simple truncation\n- VPMOVSDB uses signed saturation\n- VPMOVUSDB uses unsigned saturation\n\nThese instructions are part of the AVX512 instruction set and support various vector lengths (128-bit, 256-bit, and 512-bit) with configurable write masks.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVUSDB",
    "Brief": "Convert unsigned 32-bit integers to unsigned byte values using unsigned saturation",
    "Description": "\nVPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation. VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nThe instructions support different conversion methods:\n- VPMOVDB uses simple truncation\n- VPMOVSDB uses signed saturation\n- VPMOVUSDB uses unsigned saturation\n\nThese instructions are part of the AVX512 instruction set and support various vector lengths (128-bit, 256-bit, and 512-bit) with configurable write masks.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVDW",
    "Brief": "Down convert 32-bit integer elements to packed words using truncation",
    "Description": "\nVPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation. VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nThe instructions support different vector lengths (128-bit, 256-bit, and 512-bit) and provide options for merging and zeroing masking when converting the integer values.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSDW",
    "Brief": "Convert signed 32-bit integers to packed signed words using signed saturation",
    "Description": "\nVPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation. VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nThe instructions support different vector lengths (128-bit, 256-bit, and 512-bit) and provide options for merging and zeroing masking when converting the integer values.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVUSDW",
    "Brief": "Convert unsigned 32-bit integers to unsigned word values using unsigned saturation",
    "Description": "\nVPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation. VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nThe instructions support different vector lengths (128-bit, 256-bit, and 512-bit) and provide options for merging and zeroing masking when converting the integer values.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVM2B",
    "Brief": "Convert a mask register to a vector register with byte elements",
    "Description": "\nConverts a mask register to a vector register. Each element in the destination register is set to all 1's or all 0's depending on the value of the corresponding bit in the source mask register.\n\nThe source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.\n\nKey characteristics:\n- Available in 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector register variants\n- Supports different element sizes: byte, word, doubleword, and quadword\n- Requires AVX512VL and specific feature flags depending on the element size\n- EVEX.vvvv must be 1111b, otherwise an undefined instruction (#UD) exception is raised\n\nThe conversion process works by:\n1. For each bit in the source mask register\n2. If the bit is set (1), set the corresponding vector element to all 1's\n3. If the bit is clear (0), set the corresponding vector element to all 0's\n4. Unused bits in the destination register are set to zero\n",
    "Alias": []
  },
  {
    "Name": "VPMOVM2W",
    "Brief": "Convert a mask register to a vector register with word elements",
    "Description": "\nConverts a mask register to a vector register. Each element in the destination register is set to all 1's or all 0's depending on the value of the corresponding bit in the source mask register.\n\nThe source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.\n\nKey characteristics:\n- Available in 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector register variants\n- Supports different element sizes: byte, word, doubleword, and quadword\n- Requires AVX512VL and specific feature flags depending on the element size\n- EVEX.vvvv must be 1111b, otherwise an undefined instruction (#UD) exception is raised\n\nThe conversion process works by:\n1. For each bit in the source mask register\n2. If the bit is set (1), set the corresponding vector element to all 1's\n3. If the bit is clear (0), set the corresponding vector element to all 0's\n4. Unused bits in the destination register are set to zero\n",
    "Alias": []
  },
  {
    "Name": "VPMOVM2D",
    "Brief": "Convert a mask register to a vector register with doubleword elements",
    "Description": "\nConverts a mask register to a vector register. Each element in the destination register is set to all 1's or all 0's depending on the value of the corresponding bit in the source mask register.\n\nThe source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.\n\nKey characteristics:\n- Available in 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector register variants\n- Supports different element sizes: byte, word, doubleword, and quadword\n- Requires AVX512VL and specific feature flags depending on the element size\n- EVEX.vvvv must be 1111b, otherwise an undefined instruction (#UD) exception is raised\n\nThe conversion process works by:\n1. For each bit in the source mask register\n2. If the bit is set (1), set the corresponding vector element to all 1's\n3. If the bit is clear (0), set the corresponding vector element to all 0's\n4. Unused bits in the destination register are set to zero\n",
    "Alias": []
  },
  {
    "Name": "VPMOVM2Q",
    "Brief": "Convert a mask register to a vector register with quadword elements",
    "Description": "\nConverts a mask register to a vector register. Each element in the destination register is set to all 1's or all 0's depending on the value of the corresponding bit in the source mask register.\n\nThe source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.\n\nKey characteristics:\n- Available in 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM) vector register variants\n- Supports different element sizes: byte, word, doubleword, and quadword\n- Requires AVX512VL and specific feature flags depending on the element size\n- EVEX.vvvv must be 1111b, otherwise an undefined instruction (#UD) exception is raised\n\nThe conversion process works by:\n1. For each bit in the source mask register\n2. If the bit is set (1), set the corresponding vector element to all 1's\n3. If the bit is clear (0), set the corresponding vector element to all 0's\n4. Unused bits in the destination register are set to zero\n",
    "Alias": []
  },
  {
    "Name": "VPMOVQB",
    "Brief": "Down convert quad-word to byte with truncation",
    "Description": "\nVPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed saturation. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The source operand is a vector register. The destination operand is an XMM register or a memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:64) of the destination are zeroed.\n\nThese instructions support different vector lengths (128-bit, 256-bit, and 512-bit) and can work with writemasks for conditional conversion. The conversion method depends on the specific instruction:\n- VPMOVQB uses simple truncation\n- VPMOVSQB uses signed saturation\n- VPMOVUSQB uses unsigned saturation\n\nThe instructions are part of the AVX512 instruction set and provide efficient down-conversion of quad-word integers to byte-sized integers.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSQB",
    "Brief": "Down convert signed quad-word to signed byte with saturation",
    "Description": "\nVPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed saturation. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The source operand is a vector register. The destination operand is an XMM register or a memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:64) of the destination are zeroed.\n\nThese instructions support different vector lengths (128-bit, 256-bit, and 512-bit) and can work with writemasks for conditional conversion. The conversion method depends on the specific instruction:\n- VPMOVQB uses simple truncation\n- VPMOVSQB uses signed saturation\n- VPMOVUSQB uses unsigned saturation\n\nThe instructions are part of the AVX512 instruction set and provide efficient down-conversion of quad-word integers to byte-sized integers.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVUSQB",
    "Brief": "Down convert unsigned quad-word to unsigned byte with saturation",
    "Description": "\nVPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed saturation. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The source operand is a vector register. The destination operand is an XMM register or a memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:64) of the destination are zeroed.\n\nThese instructions support different vector lengths (128-bit, 256-bit, and 512-bit) and can work with writemasks for conditional conversion. The conversion method depends on the specific instruction:\n- VPMOVQB uses simple truncation\n- VPMOVSQB uses signed saturation\n- VPMOVUSQB uses unsigned saturation\n\nThe instructions are part of the AVX512 instruction set and provide efficient down-conversion of quad-word integers to byte-sized integers.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVQD",
    "Brief": "Down convert quad-word to double-word using truncation",
    "Description": "\nVPMOVQD down converts 64-bit integer elements in the source operand (the second operand) into packed double-words using truncation. VPMOVSQD converts signed 64-bit integers into packed signed doublewords using signed saturation. VPMOVUSQD convert unsigned quad-word values into unsigned double-word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted doubleword elements are written to the destination operand (the first operand) from the least-significant doubleword. Doubleword elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSQD",
    "Brief": "Down convert signed quad-word to signed double-word using saturation",
    "Description": "\nVPMOVQD down converts 64-bit integer elements in the source operand (the second operand) into packed double-words using truncation. VPMOVSQD converts signed 64-bit integers into packed signed doublewords using signed saturation. VPMOVUSQD convert unsigned quad-word values into unsigned double-word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted doubleword elements are written to the destination operand (the first operand) from the least-significant doubleword. Doubleword elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVUSQD",
    "Brief": "Down convert unsigned quad-word to unsigned double-word using saturation",
    "Description": "\nVPMOVQD down converts 64-bit integer elements in the source operand (the second operand) into packed double-words using truncation. VPMOVSQD converts signed 64-bit integers into packed signed doublewords using signed saturation. VPMOVUSQD convert unsigned quad-word values into unsigned double-word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted doubleword elements are written to the destination operand (the first operand) from the least-significant doubleword. Doubleword elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVQW",
    "Brief": "Down convert quad-word integers to word integers with truncation",
    "Description": "\nVPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.\n\nDown-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.\n\nKey points:\n- VPMOVQW uses truncation to convert quad-words to words\n- VPMOVSQW uses signed saturation for signed quad-word to word conversion\n- VPMOVUSQW uses unsigned saturation for unsigned quad-word to word conversion\n- Supports different vector lengths (128, 256, 512 bits)\n- Uses writemask for conditional conversion\n- Destination register upper bits are zeroed\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will generate an #UD (Undefined Instruction) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSQW",
    "Brief": "Down convert signed quad-word integers to signed word integers with signed saturation",
    "Description": "\nVPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.\n\nDown-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.\n\nKey points:\n- VPMOVQW uses truncation to convert quad-words to words\n- VPMOVSQW uses signed saturation for signed quad-word to word conversion\n- VPMOVUSQW uses unsigned saturation for unsigned quad-word to word conversion\n- Supports different vector lengths (128, 256, 512 bits)\n- Uses writemask for conditional conversion\n- Destination register upper bits are zeroed\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will generate an #UD (Undefined Instruction) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVUSQW",
    "Brief": "Down convert unsigned quad-word integers to unsigned word integers with unsigned saturation",
    "Description": "\nVPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.\n\nDown-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.\n\nKey points:\n- VPMOVQW uses truncation to convert quad-words to words\n- VPMOVSQW uses signed saturation for signed quad-word to word conversion\n- VPMOVUSQW uses unsigned saturation for unsigned quad-word to word conversion\n- Supports different vector lengths (128, 256, 512 bits)\n- Uses writemask for conditional conversion\n- Destination register upper bits are zeroed\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will generate an #UD (Undefined Instruction) exception.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVWB",
    "Brief": "Down convert packed 16-bit word integers to packed bytes using truncation",
    "Description": "\nVPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into unsigned byte values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nVariations of the instructions include:\n- VPMOVWB: Truncates 16-bit words to bytes\n- VPMOVSWB: Converts signed 16-bit words to signed bytes with saturation\n- VPMOVUSWB: Converts unsigned 16-bit words to unsigned bytes with saturation\n\nThe instructions support different vector register sizes (128, 256, and 512-bit) and can use write masks for selective conversion.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVSWB",
    "Brief": "Down convert packed signed 16-bit word integers to packed signed bytes using signed saturation",
    "Description": "\nVPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into unsigned byte values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nVariations of the instructions include:\n- VPMOVWB: Truncates 16-bit words to bytes\n- VPMOVSWB: Converts signed 16-bit words to signed bytes with saturation\n- VPMOVUSWB: Converts unsigned 16-bit words to unsigned bytes with saturation\n\nThe instructions support different vector register sizes (128, 256, and 512-bit) and can use write masks for selective conversion.\n",
    "Alias": []
  },
  {
    "Name": "VPMOVUSWB",
    "Brief": "Down convert packed unsigned 16-bit word integers to packed unsigned bytes using unsigned saturation",
    "Description": "\nVPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into unsigned byte values using unsigned saturation.\n\nThe source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.\n\nDown-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.\n\nVariations of the instructions include:\n- VPMOVWB: Truncates 16-bit words to bytes\n- VPMOVSWB: Converts signed 16-bit words to signed bytes with saturation\n- VPMOVUSWB: Converts unsigned 16-bit words to unsigned bytes with saturation\n\nThe instructions support different vector register sizes (128, 256, and 512-bit) and can use write masks for selective conversion.\n",
    "Alias": []
  },
  {
    "Name": "VPMULTISHIFTQB",
    "Brief": "Select packed unaligned bytes from quadword sources",
    "Description": "\nThis instruction selects eight unaligned bytes from each input qword element of the second source operand (the third operand) and writes eight assembled bytes for each qword element in the destination operand (the first operand). \n\nEach byte result is selected using a byte-granular shift control within the corresponding qword element of the first source operand (the second operand). Each byte result in the destination operand is updated under the writemask k1.\n\nOnly the low 6 bits of each control byte are used to select an 8-bit slot to extract the output byte from the qword data in the second source operand. The starting bit of the 8-bit slot can be unaligned relative to any byte boundary and is extracted from the input qword source at the location specified in the low 6-bit of the control byte. If the 8-bit slot would exceed the qword boundary, the out-of-bound portion of the 8-bit slot is wrapped back to start from bit 0 of the input qword element.\n\nThe first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register.\n",
    "Alias": []
  },
  {
    "Name": "VPOPCNTB",
    "Brief": "Count the number of bits set to one in each byte element",
    "Description": "\nThis instruction counts the number of bits set to one in each byte, word, dword or qword element of its source (e.g., zmm2 or memory) and places the results in the destination register (zmm1). This instruction supports memory fault suppression.\n\nFor each variant (VPOPCNTB, VPOPCNTW, VPOPCNTD, VPOPCNTQ), the instruction operates on different element sizes:\n- VPOPCNTB: Operates on byte elements (8-bit)\n- VPOPCNTW: Operates on word elements (16-bit)\n- VPOPCNTD: Operates on doubleword elements (32-bit)\n- VPOPCNTQ: Operates on quadword elements (64-bit)\n\nThe instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and can use writemasks for conditional processing. When a writemask is used, the instruction can either merge the results with the existing destination or zero out the elements not selected by the mask.\n",
    "Alias": []
  },
  {
    "Name": "VPOPCNTW",
    "Brief": "Count the number of bits set to one in each word element",
    "Description": "\nThis instruction counts the number of bits set to one in each byte, word, dword or qword element of its source (e.g., zmm2 or memory) and places the results in the destination register (zmm1). This instruction supports memory fault suppression.\n\nFor each variant (VPOPCNTB, VPOPCNTW, VPOPCNTD, VPOPCNTQ), the instruction operates on different element sizes:\n- VPOPCNTB: Operates on byte elements (8-bit)\n- VPOPCNTW: Operates on word elements (16-bit)\n- VPOPCNTD: Operates on doubleword elements (32-bit)\n- VPOPCNTQ: Operates on quadword elements (64-bit)\n\nThe instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and can use writemasks for conditional processing. When a writemask is used, the instruction can either merge the results with the existing destination or zero out the elements not selected by the mask.\n",
    "Alias": []
  },
  {
    "Name": "VPOPCNTD",
    "Brief": "Count the number of bits set to one in each dword element",
    "Description": "\nThis instruction counts the number of bits set to one in each byte, word, dword or qword element of its source (e.g., zmm2 or memory) and places the results in the destination register (zmm1). This instruction supports memory fault suppression.\n\nFor each variant (VPOPCNTB, VPOPCNTW, VPOPCNTD, VPOPCNTQ), the instruction operates on different element sizes:\n- VPOPCNTB: Operates on byte elements (8-bit)\n- VPOPCNTW: Operates on word elements (16-bit)\n- VPOPCNTD: Operates on doubleword elements (32-bit)\n- VPOPCNTQ: Operates on quadword elements (64-bit)\n\nThe instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and can use writemasks for conditional processing. When a writemask is used, the instruction can either merge the results with the existing destination or zero out the elements not selected by the mask.\n",
    "Alias": []
  },
  {
    "Name": "VPOPCNTQ",
    "Brief": "Count the number of bits set to one in each qword element",
    "Description": "\nThis instruction counts the number of bits set to one in each byte, word, dword or qword element of its source (e.g., zmm2 or memory) and places the results in the destination register (zmm1). This instruction supports memory fault suppression.\n\nFor each variant (VPOPCNTB, VPOPCNTW, VPOPCNTD, VPOPCNTQ), the instruction operates on different element sizes:\n- VPOPCNTB: Operates on byte elements (8-bit)\n- VPOPCNTW: Operates on word elements (16-bit)\n- VPOPCNTD: Operates on doubleword elements (32-bit)\n- VPOPCNTQ: Operates on quadword elements (64-bit)\n\nThe instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and can use writemasks for conditional processing. When a writemask is used, the instruction can either merge the results with the existing destination or zero out the elements not selected by the mask.\n",
    "Alias": []
  },
  {
    "Name": "VPROLD",
    "Brief": "Rotate doublewords left by an immediate count",
    "Description": "\nThese instructions rotate the bits in individual data elements (doublewords or quadwords) in the first source operand to the left by a specified number of bits. The count operand can be either an immediate value or a vector containing rotation counts.\n\nKey characteristics:\n- If the count operand is greater than 31 (for doublewords) or 63 (for quadwords), the count is taken modulo the data size\n- Supports different vector register sizes: 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM)\n- Uses EVEX encoding with optional writemask and broadcast capabilities\n- VPROLD/VPROLQ use an immediate count\n- VPROLVD/VPROLVQ use a vector containing per-element rotation counts\n\nEVEX.128 version: Destination is an XMM register, source can be XMM register or memory. Upper bits of corresponding ZMM register are zeroed.\n\nEVEX.256 version: Destination is a YMM register, source can be YMM register or memory. Upper bits of corresponding ZMM register are zeroed.\n\nEVEX.512 version: Destination is a ZMM register updated according to the writemask. Supports various source and count operand configurations.\n",
    "Alias": []
  },
  {
    "Name": "VPROLVD",
    "Brief": "Rotate doublewords left by count in a vector",
    "Description": "\nThese instructions rotate the bits in individual data elements (doublewords or quadwords) in the first source operand to the left by a specified number of bits. The count operand can be either an immediate value or a vector containing rotation counts.\n\nKey characteristics:\n- If the count operand is greater than 31 (for doublewords) or 63 (for quadwords), the count is taken modulo the data size\n- Supports different vector register sizes: 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM)\n- Uses EVEX encoding with optional writemask and broadcast capabilities\n- VPROLD/VPROLQ use an immediate count\n- VPROLVD/VPROLVQ use a vector containing per-element rotation counts\n\nEVEX.128 version: Destination is an XMM register, source can be XMM register or memory. Upper bits of corresponding ZMM register are zeroed.\n\nEVEX.256 version: Destination is a YMM register, source can be YMM register or memory. Upper bits of corresponding ZMM register are zeroed.\n\nEVEX.512 version: Destination is a ZMM register updated according to the writemask. Supports various source and count operand configurations.\n",
    "Alias": []
  },
  {
    "Name": "VPROLQ",
    "Brief": "Rotate quadwords left by an immediate count",
    "Description": "\nThese instructions rotate the bits in individual data elements (doublewords or quadwords) in the first source operand to the left by a specified number of bits. The count operand can be either an immediate value or a vector containing rotation counts.\n\nKey characteristics:\n- If the count operand is greater than 31 (for doublewords) or 63 (for quadwords), the count is taken modulo the data size\n- Supports different vector register sizes: 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM)\n- Uses EVEX encoding with optional writemask and broadcast capabilities\n- VPROLD/VPROLQ use an immediate count\n- VPROLVD/VPROLVQ use a vector containing per-element rotation counts\n\nEVEX.128 version: Destination is an XMM register, source can be XMM register or memory. Upper bits of corresponding ZMM register are zeroed.\n\nEVEX.256 version: Destination is a YMM register, source can be YMM register or memory. Upper bits of corresponding ZMM register are zeroed.\n\nEVEX.512 version: Destination is a ZMM register updated according to the writemask. Supports various source and count operand configurations.\n",
    "Alias": []
  },
  {
    "Name": "VPROLVQ",
    "Brief": "Rotate quadwords left by count in a vector",
    "Description": "\nThese instructions rotate the bits in individual data elements (doublewords or quadwords) in the first source operand to the left by a specified number of bits. The count operand can be either an immediate value or a vector containing rotation counts.\n\nKey characteristics:\n- If the count operand is greater than 31 (for doublewords) or 63 (for quadwords), the count is taken modulo the data size\n- Supports different vector register sizes: 128-bit (XMM), 256-bit (YMM), and 512-bit (ZMM)\n- Uses EVEX encoding with optional writemask and broadcast capabilities\n- VPROLD/VPROLQ use an immediate count\n- VPROLVD/VPROLVQ use a vector containing per-element rotation counts\n\nEVEX.128 version: Destination is an XMM register, source can be XMM register or memory. Upper bits of corresponding ZMM register are zeroed.\n\nEVEX.256 version: Destination is a YMM register, source can be YMM register or memory. Upper bits of corresponding ZMM register are zeroed.\n\nEVEX.512 version: Destination is a ZMM register updated according to the writemask. Supports various source and count operand configurations.\n",
    "Alias": []
  },
  {
    "Name": "VPRORD",
    "Brief": "Rotate doublewords right by an immediate value",
    "Description": "\nRotates the bits in the individual data elements (doublewords or quadwords) in the first source operand to the right by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords) or 63 (for quadwords), then the count operand modulo the data size (32 or 64) is used.\n\nEVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\n\nEVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VPRORVD",
    "Brief": "Rotate doublewords right by a variable count",
    "Description": "\nRotates the bits in the individual data elements (doublewords or quadwords) in the first source operand to the right by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords) or 63 (for quadwords), then the count operand modulo the data size (32 or 64) is used.\n\nEVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\n\nEVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VPRORQ",
    "Brief": "Rotate quadwords right by an immediate value",
    "Description": "\nRotates the bits in the individual data elements (doublewords or quadwords) in the first source operand to the right by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords) or 63 (for quadwords), then the count operand modulo the data size (32 or 64) is used.\n\nEVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\n\nEVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VPRORVQ",
    "Brief": "Rotate quadwords right by a variable count",
    "Description": "\nRotates the bits in the individual data elements (doublewords or quadwords) in the first source operand to the right by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords) or 63 (for quadwords), then the count operand modulo the data size (32 or 64) is used.\n\nEVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\n\nEVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VPSCATTERDD",
    "Brief": "Scatter packed dword values to memory using signed dword indices",
    "Description": "\nThese instructions store up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one.\n\nKey characteristics of these scatter instructions include:\n- Writes to overlapping vector indices are guaranteed to be ordered from LSB to MSB\n- If two destination indices completely overlap, the \"earlier\" write(s) may be skipped\n- Faults are delivered in a right-to-left manner\n- Elements may be scattered in any order\n- No AC (alignment) checks are performed\n- Not valid with 16-bit effective addresses\n- Requires a specific VSIB byte encoding\n\nThe different variants (VPSCATTERDD, VPSCATTERDQ, VPSCATTERQD, VPSCATTERQQ) differ in:\n- The type of indices used (32-bit or 64-bit)\n- The size of values being scattered (32-bit or 64-bit)\n\nThe entire mask register will be set to zero by these instructions unless an exception is triggered.\n",
    "Alias": []
  },
  {
    "Name": "VPSCATTERDQ",
    "Brief": "Scatter packed qword values to memory using signed dword indices",
    "Description": "\nThese instructions store up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one.\n\nKey characteristics of these scatter instructions include:\n- Writes to overlapping vector indices are guaranteed to be ordered from LSB to MSB\n- If two destination indices completely overlap, the \"earlier\" write(s) may be skipped\n- Faults are delivered in a right-to-left manner\n- Elements may be scattered in any order\n- No AC (alignment) checks are performed\n- Not valid with 16-bit effective addresses\n- Requires a specific VSIB byte encoding\n\nThe different variants (VPSCATTERDD, VPSCATTERDQ, VPSCATTERQD, VPSCATTERQQ) differ in:\n- The type of indices used (32-bit or 64-bit)\n- The size of values being scattered (32-bit or 64-bit)\n\nThe entire mask register will be set to zero by these instructions unless an exception is triggered.\n",
    "Alias": []
  },
  {
    "Name": "VPSCATTERQD",
    "Brief": "Scatter packed dword values to memory using signed qword indices",
    "Description": "\nThese instructions store up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one.\n\nKey characteristics of these scatter instructions include:\n- Writes to overlapping vector indices are guaranteed to be ordered from LSB to MSB\n- If two destination indices completely overlap, the \"earlier\" write(s) may be skipped\n- Faults are delivered in a right-to-left manner\n- Elements may be scattered in any order\n- No AC (alignment) checks are performed\n- Not valid with 16-bit effective addresses\n- Requires a specific VSIB byte encoding\n\nThe different variants (VPSCATTERDD, VPSCATTERDQ, VPSCATTERQD, VPSCATTERQQ) differ in:\n- The type of indices used (32-bit or 64-bit)\n- The size of values being scattered (32-bit or 64-bit)\n\nThe entire mask register will be set to zero by these instructions unless an exception is triggered.\n",
    "Alias": []
  },
  {
    "Name": "VPSCATTERQQ",
    "Brief": "Scatter packed qword values to memory using signed qword indices",
    "Description": "\nThese instructions store up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one.\n\nKey characteristics of these scatter instructions include:\n- Writes to overlapping vector indices are guaranteed to be ordered from LSB to MSB\n- If two destination indices completely overlap, the \"earlier\" write(s) may be skipped\n- Faults are delivered in a right-to-left manner\n- Elements may be scattered in any order\n- No AC (alignment) checks are performed\n- Not valid with 16-bit effective addresses\n- Requires a specific VSIB byte encoding\n\nThe different variants (VPSCATTERDD, VPSCATTERDQ, VPSCATTERQD, VPSCATTERQQ) differ in:\n- The type of indices used (32-bit or 64-bit)\n- The size of values being scattered (32-bit or 64-bit)\n\nThe entire mask register will be set to zero by these instructions unless an exception is triggered.\n",
    "Alias": []
  },
  {
    "Name": "VPSHLDW",
    "Brief": "Concatenate and shift packed 16-bit words left logically",
    "Description": "\nConcatenate packed data, extract result shifted to the left by constant value.\n\nThe instruction supports three variants based on the operand size:\n- VPSHLDW: Works with 16-bit words\n- VPSHLDD: Works with 32-bit doublewords\n- VPSHLDQ: Works with 64-bit quadwords\n\nEach variant operates on different vector register sizes (128-bit, 256-bit, and 512-bit) and supports:\n- Masking operations with optional write masking\n- Optional zero masking\n- Broadcast memory operations for VPSHLDD and VPSHLDQ\n\nThe basic operation involves:\n1. Concatenating the destination (SRC2) and source (SRC3) operands\n2. Shifting the concatenated value left by a specified immediate value\n3. Extracting the high part of the shifted result into the destination register\n\nThis instruction supports memory fault suppression and is part of the AVX512_VBMI2 instruction set.\n",
    "Alias": []
  },
  {
    "Name": "VPSHLDD",
    "Brief": "Concatenate and shift packed 32-bit doublewords left logically",
    "Description": "\nConcatenate packed data, extract result shifted to the left by constant value.\n\nThe instruction supports three variants based on the operand size:\n- VPSHLDW: Works with 16-bit words\n- VPSHLDD: Works with 32-bit doublewords\n- VPSHLDQ: Works with 64-bit quadwords\n\nEach variant operates on different vector register sizes (128-bit, 256-bit, and 512-bit) and supports:\n- Masking operations with optional write masking\n- Optional zero masking\n- Broadcast memory operations for VPSHLDD and VPSHLDQ\n\nThe basic operation involves:\n1. Concatenating the destination (SRC2) and source (SRC3) operands\n2. Shifting the concatenated value left by a specified immediate value\n3. Extracting the high part of the shifted result into the destination register\n\nThis instruction supports memory fault suppression and is part of the AVX512_VBMI2 instruction set.\n",
    "Alias": []
  },
  {
    "Name": "VPSHLDQ",
    "Brief": "Concatenate and shift packed 64-bit quadwords left logically",
    "Description": "\nConcatenate packed data, extract result shifted to the left by constant value.\n\nThe instruction supports three variants based on the operand size:\n- VPSHLDW: Works with 16-bit words\n- VPSHLDD: Works with 32-bit doublewords\n- VPSHLDQ: Works with 64-bit quadwords\n\nEach variant operates on different vector register sizes (128-bit, 256-bit, and 512-bit) and supports:\n- Masking operations with optional write masking\n- Optional zero masking\n- Broadcast memory operations for VPSHLDD and VPSHLDQ\n\nThe basic operation involves:\n1. Concatenating the destination (SRC2) and source (SRC3) operands\n2. Shifting the concatenated value left by a specified immediate value\n3. Extracting the high part of the shifted result into the destination register\n\nThis instruction supports memory fault suppression and is part of the AVX512_VBMI2 instruction set.\n",
    "Alias": []
  },
  {
    "Name": "VPSHLDVW",
    "Brief": "Concatenate and variable shift packed word data left logical",
    "Description": "\nConcatenate packed data, extract result shifted to the left by variable value.\n\nThis instruction supports memory fault suppression.\n\nThe instruction works by:\n1. Concatenating source registers (destination and source 2)\n2. Shifting the concatenated result left by a variable amount specified in source 3\n3. Extracting the high part of the shifted result back into the destination register\n\nVariations of the instruction exist for different data sizes:\n- VPSHLDVW: Works on 16-bit words\n- VPSHLDVD: Works on 32-bit doublewords\n- VPSHLDVQ: Works on 64-bit quadwords\n\nEach variant supports different vector register sizes (128-bit, 256-bit, and 512-bit) and includes optional masking and zeroing capabilities.\n\nThe shift amount is taken from the corresponding element in the third source register, masked to the appropriate bit width (15 for words, 31 for doublewords, 63 for quadwords).\n",
    "Alias": []
  },
  {
    "Name": "VPSHLDVD",
    "Brief": "Concatenate and variable shift packed dword data left logical",
    "Description": "\nConcatenate packed data, extract result shifted to the left by variable value.\n\nThis instruction supports memory fault suppression.\n\nThe instruction works by:\n1. Concatenating source registers (destination and source 2)\n2. Shifting the concatenated result left by a variable amount specified in source 3\n3. Extracting the high part of the shifted result back into the destination register\n\nVariations of the instruction exist for different data sizes:\n- VPSHLDVW: Works on 16-bit words\n- VPSHLDVD: Works on 32-bit doublewords\n- VPSHLDVQ: Works on 64-bit quadwords\n\nEach variant supports different vector register sizes (128-bit, 256-bit, and 512-bit) and includes optional masking and zeroing capabilities.\n\nThe shift amount is taken from the corresponding element in the third source register, masked to the appropriate bit width (15 for words, 31 for doublewords, 63 for quadwords).\n",
    "Alias": []
  },
  {
    "Name": "VPSHLDVQ",
    "Brief": "Concatenate and variable shift packed qword data left logical",
    "Description": "\nConcatenate packed data, extract result shifted to the left by variable value.\n\nThis instruction supports memory fault suppression.\n\nThe instruction works by:\n1. Concatenating source registers (destination and source 2)\n2. Shifting the concatenated result left by a variable amount specified in source 3\n3. Extracting the high part of the shifted result back into the destination register\n\nVariations of the instruction exist for different data sizes:\n- VPSHLDVW: Works on 16-bit words\n- VPSHLDVD: Works on 32-bit doublewords\n- VPSHLDVQ: Works on 64-bit quadwords\n\nEach variant supports different vector register sizes (128-bit, 256-bit, and 512-bit) and includes optional masking and zeroing capabilities.\n\nThe shift amount is taken from the corresponding element in the third source register, masked to the appropriate bit width (15 for words, 31 for doublewords, 63 for quadwords).\n",
    "Alias": []
  },
  {
    "Name": "VPSHRDW",
    "Brief": "Concatenate and shift packed 16-bit words right",
    "Description": "\nThese instructions concatenate packed data and extract the result shifted to the right by a constant value specified in the immediate byte.\n\nThe VPSHRDW instruction operates on 16-bit words, VPSHRDD on 32-bit doublewords, and VPSHRDQ on 64-bit quadwords. Each instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and provides masked and non-masked versions.\n\nKey characteristics:\n- Supports memory fault suppression\n- Can use writemask and zeroing/merging operations\n- Shift amount is controlled by the immediate byte (imm8)\n- Concatenates destination and source operands before shifting\n- For broadcast memory operands, a single value is used for all elements\n\nThe instructions are part of the AVX512_VBMI2 instruction set and support various vector lengths and data types.\n",
    "Alias": []
  },
  {
    "Name": "VPSHRDD",
    "Brief": "Concatenate and shift packed 32-bit doublewords right",
    "Description": "\nThese instructions concatenate packed data and extract the result shifted to the right by a constant value specified in the immediate byte.\n\nThe VPSHRDW instruction operates on 16-bit words, VPSHRDD on 32-bit doublewords, and VPSHRDQ on 64-bit quadwords. Each instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and provides masked and non-masked versions.\n\nKey characteristics:\n- Supports memory fault suppression\n- Can use writemask and zeroing/merging operations\n- Shift amount is controlled by the immediate byte (imm8)\n- Concatenates destination and source operands before shifting\n- For broadcast memory operands, a single value is used for all elements\n\nThe instructions are part of the AVX512_VBMI2 instruction set and support various vector lengths and data types.\n",
    "Alias": []
  },
  {
    "Name": "VPSHRDQ",
    "Brief": "Concatenate and shift packed 64-bit quadwords right",
    "Description": "\nThese instructions concatenate packed data and extract the result shifted to the right by a constant value specified in the immediate byte.\n\nThe VPSHRDW instruction operates on 16-bit words, VPSHRDD on 32-bit doublewords, and VPSHRDQ on 64-bit quadwords. Each instruction supports different vector lengths (128-bit, 256-bit, and 512-bit) and provides masked and non-masked versions.\n\nKey characteristics:\n- Supports memory fault suppression\n- Can use writemask and zeroing/merging operations\n- Shift amount is controlled by the immediate byte (imm8)\n- Concatenates destination and source operands before shifting\n- For broadcast memory operands, a single value is used for all elements\n\nThe instructions are part of the AVX512_VBMI2 instruction set and support various vector lengths and data types.\n",
    "Alias": []
  },
  {
    "Name": "VPSHRDVW",
    "Brief": "Concatenate and shift packed 16-bit words right by variable value",
    "Description": "\nConcatenate packed data and extract the result shifted to the right by a variable value.\n\nThe instruction supports three variants based on the data width:\n- VPSHRDVW: Operates on 16-bit words\n- VPSHRDVD: Operates on 32-bit doublewords\n- VPSHRDVQ: Operates on 64-bit quadwords\n\nEach variant supports different vector register sizes (128-bit, 256-bit, and 512-bit) and allows:\n- Concatenating the destination and source registers\n- Shifting the concatenated result to the right\n- The shift amount is determined by the third operand (variable shift)\n\nThe instruction supports:\n- Write masking\n- Zeroing/merging masking\n- Broadcast for memory operands (in VPSHRDVD and VPSHRDVQ)\n\nThis instruction is part of the AVX512_VBMI2 instruction set and supports memory fault suppression.\n",
    "Alias": []
  },
  {
    "Name": "VPSHRDVD",
    "Brief": "Concatenate and shift packed 32-bit doublewords right by variable value",
    "Description": "\nConcatenate packed data and extract the result shifted to the right by a variable value.\n\nThe instruction supports three variants based on the data width:\n- VPSHRDVW: Operates on 16-bit words\n- VPSHRDVD: Operates on 32-bit doublewords\n- VPSHRDVQ: Operates on 64-bit quadwords\n\nEach variant supports different vector register sizes (128-bit, 256-bit, and 512-bit) and allows:\n- Concatenating the destination and source registers\n- Shifting the concatenated result to the right\n- The shift amount is determined by the third operand (variable shift)\n\nThe instruction supports:\n- Write masking\n- Zeroing/merging masking\n- Broadcast for memory operands (in VPSHRDVD and VPSHRDVQ)\n\nThis instruction is part of the AVX512_VBMI2 instruction set and supports memory fault suppression.\n",
    "Alias": []
  },
  {
    "Name": "VPSHRDVQ",
    "Brief": "Concatenate and shift packed 64-bit quadwords right by variable value",
    "Description": "\nConcatenate packed data and extract the result shifted to the right by a variable value.\n\nThe instruction supports three variants based on the data width:\n- VPSHRDVW: Operates on 16-bit words\n- VPSHRDVD: Operates on 32-bit doublewords\n- VPSHRDVQ: Operates on 64-bit quadwords\n\nEach variant supports different vector register sizes (128-bit, 256-bit, and 512-bit) and allows:\n- Concatenating the destination and source registers\n- Shifting the concatenated result to the right\n- The shift amount is determined by the third operand (variable shift)\n\nThe instruction supports:\n- Write masking\n- Zeroing/merging masking\n- Broadcast for memory operands (in VPSHRDVD and VPSHRDVQ)\n\nThis instruction is part of the AVX512_VBMI2 instruction set and supports memory fault suppression.\n",
    "Alias": []
  },
  {
    "Name": "VPSHUFBITQMB",
    "Brief": "Shuffle bits from quadword elements using byte indexes into mask",
    "Description": "\nThe VPSHUFBITQMB instruction performs a bit gather select using the second source as control and the first source as data. Each bit uses 6 control bits (2nd source operand) to select which data bit is going to be gathered (first source operand). A given bit can only access 64 different bits of data (first 64 destination bits can access first 64 data bits, second 64 destination bits can access second 64 data bits, etc.).\n\nControl data for each output bit is stored in 8-bit elements of SRC2, but only the 6 least significant bits of each element are used.\n\nThis instruction uses write masking (zeroing only) and supports memory fault suppression.\n\nThe first source operand is a ZMM register. The second source operand is a ZMM register or a memory location. The destination operand is a mask register.\n",
    "Alias": []
  },
  {
    "Name": "VPSLLVW",
    "Brief": "Variable bit shift left logical for words",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the left by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data elements are written with 0.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX encoded VPSLLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n\nEVEX encoded VPSLLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPSLLVD",
    "Brief": "Variable bit shift left logical for doublewords",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the left by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data elements are written with 0.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX encoded VPSLLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n\nEVEX encoded VPSLLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPSLLVQ",
    "Brief": "Variable bit shift left logical for quadwords",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the left by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data elements are written with 0.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX encoded VPSLLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n\nEVEX encoded VPSLLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPSRAVW",
    "Brief": "Shift words right by variable count with sign extension",
    "Description": "\nShifts the bits in the individual data elements (word/doublewords/quadword) in the first source operand to the right by the number of bits specified in the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are set to the MSB (sign extension).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination data element is filled with the corresponding sign bit of the source element.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX.512/256/128 encoded versions: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPSRAVD",
    "Brief": "Shift doublewords right by variable count with sign extension",
    "Description": "\nShifts the bits in the individual data elements (word/doublewords/quadword) in the first source operand to the right by the number of bits specified in the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are set to the MSB (sign extension).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination data element is filled with the corresponding sign bit of the source element.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX.512/256/128 encoded versions: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPSRAVQ",
    "Brief": "Shift quadwords right by variable count with sign extension",
    "Description": "\nShifts the bits in the individual data elements (word/doublewords/quadword) in the first source operand to the right by the number of bits specified in the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are set to the MSB (sign extension).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination data element is filled with the corresponding sign bit of the source element.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\n\nEVEX.512/256/128 encoded versions: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPSRLVW",
    "Brief": "Shift words right by variable amounts while shifting in 0s",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data elements are written with 0.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either a YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX encoded versions: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or for VPSRLVD/Q, a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPSRLVD",
    "Brief": "Shift doublewords right by variable amounts while shifting in 0s",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data elements are written with 0.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either a YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX encoded versions: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or for VPSRLVD/Q, a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPSRLVQ",
    "Brief": "Shift quadwords right by variable amounts while shifting in 0s",
    "Description": "\nShifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0).\n\nThe count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data elements are written with 0.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either a YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\n\nEVEX encoded versions: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or for VPSRLVD/Q, a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VPTERNLOGD",
    "Brief": "Bitwise ternary logic on 32-bit elements",
    "Description": "\nVPTERNLOGD/Q takes three bit vectors of 512-bit length (in the first, second, and third operand) as input data to form a set of 512 indices, each index is comprised of one bit from each input vector. The imm8 byte specifies a boolean logic table producing a binary value for each 3-bit index value. The final 512-bit boolean result is written to the destination operand (the first operand) using the writemask k1 with the granularity of doubleword (VPTERNLOGD) or quadword (VPTERNLOGQ) elements.\n\nThe destination operand is a ZMM (EVEX.512)/YMM (EVEX.256)/XMM (EVEX.128) register. The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location.\n\nThe immediate value (imm8) allows specifying any arbitrary three-input Boolean function. By changing the imm8 value, different logical operations can be implemented, such as AND, OR, XOR, and more complex boolean logic functions.\n\nThe instruction supports both merging and zeroing masking through the k1 writemask, allowing selective modification of the destination register based on the mask.\n",
    "Alias": []
  },
  {
    "Name": "VPTERNLOGQ",
    "Brief": "Bitwise ternary logic on 64-bit elements",
    "Description": "\nVPTERNLOGD/Q takes three bit vectors of 512-bit length (in the first, second, and third operand) as input data to form a set of 512 indices, each index is comprised of one bit from each input vector. The imm8 byte specifies a boolean logic table producing a binary value for each 3-bit index value. The final 512-bit boolean result is written to the destination operand (the first operand) using the writemask k1 with the granularity of doubleword (VPTERNLOGD) or quadword (VPTERNLOGQ) elements.\n\nThe destination operand is a ZMM (EVEX.512)/YMM (EVEX.256)/XMM (EVEX.128) register. The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location.\n\nThe immediate value (imm8) allows specifying any arbitrary three-input Boolean function. By changing the imm8 value, different logical operations can be implemented, such as AND, OR, XOR, and more complex boolean logic functions.\n\nThe instruction supports both merging and zeroing masking through the k1 writemask, allowing selective modification of the destination register based on the mask.\n",
    "Alias": []
  },
  {
    "Name": "VPTESTMB",
    "Brief": "Bitwise AND of packed byte integers and set mask to reflect zero/non-zero status",
    "Description": "\nPerforms a bitwise logical AND operation on the first source operand (the second operand) and second source operand (the third operand) and stores the result in the destination operand (the first operand) under the write-mask. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is non-zero; otherwise it is set to 0.\n\nVPTESTMD/VPTESTMQ: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a mask register updated under the writemask.\n\nVPTESTMB/VPTESTMW: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a mask register updated under the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VPTESTMW",
    "Brief": "Bitwise AND of packed word integers and set mask to reflect zero/non-zero status",
    "Description": "\nPerforms a bitwise logical AND operation on the first source operand (the second operand) and second source operand (the third operand) and stores the result in the destination operand (the first operand) under the write-mask. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is non-zero; otherwise it is set to 0.\n\nVPTESTMD/VPTESTMQ: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a mask register updated under the writemask.\n\nVPTESTMB/VPTESTMW: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a mask register updated under the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VPTESTMD",
    "Brief": "Bitwise AND of packed doubleword integers and set mask to reflect zero/non-zero status",
    "Description": "\nPerforms a bitwise logical AND operation on the first source operand (the second operand) and second source operand (the third operand) and stores the result in the destination operand (the first operand) under the write-mask. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is non-zero; otherwise it is set to 0.\n\nVPTESTMD/VPTESTMQ: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a mask register updated under the writemask.\n\nVPTESTMB/VPTESTMW: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a mask register updated under the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VPTESTMQ",
    "Brief": "Bitwise AND of packed quadword integers and set mask to reflect zero/non-zero status",
    "Description": "\nPerforms a bitwise logical AND operation on the first source operand (the second operand) and second source operand (the third operand) and stores the result in the destination operand (the first operand) under the write-mask. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is non-zero; otherwise it is set to 0.\n\nVPTESTMD/VPTESTMQ: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a mask register updated under the writemask.\n\nVPTESTMB/VPTESTMW: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a mask register updated under the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VPTESTNMB",
    "Brief": "Bitwise NAND of packed byte integers and set mask to reflect zero/non-zero status",
    "Description": "\nPerforms a bitwise logical NAND operation on the byte/word/doubleword/quadword elements of the source operands and stores the logical comparison result into each bit of the destination operand according to the writemask k1.\n\nEach bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second source operands is zero; otherwise it is set to 0.\n\nEVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is updated according to the writemask.\n\nEVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VPTESTNMW",
    "Brief": "Bitwise NAND of packed word integers and set mask to reflect zero/non-zero status",
    "Description": "\nPerforms a bitwise logical NAND operation on the byte/word/doubleword/quadword elements of the source operands and stores the logical comparison result into each bit of the destination operand according to the writemask k1.\n\nEach bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second source operands is zero; otherwise it is set to 0.\n\nEVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is updated according to the writemask.\n\nEVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VPTESTNMD",
    "Brief": "Bitwise NAND of packed doubleword integers and set mask to reflect zero/non-zero status",
    "Description": "\nPerforms a bitwise logical NAND operation on the byte/word/doubleword/quadword elements of the source operands and stores the logical comparison result into each bit of the destination operand according to the writemask k1.\n\nEach bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second source operands is zero; otherwise it is set to 0.\n\nEVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is updated according to the writemask.\n\nEVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VPTESTNMQ",
    "Brief": "Bitwise NAND of packed quadword integers and set mask to reflect zero/non-zero status",
    "Description": "\nPerforms a bitwise logical NAND operation on the byte/word/doubleword/quadword elements of the source operands and stores the logical comparison result into each bit of the destination operand according to the writemask k1.\n\nEach bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second source operands is zero; otherwise it is set to 0.\n\nEVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is updated according to the writemask.\n\nEVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VRANGEPD",
    "Brief": "Range Restriction Calculation for Packed Pairs of Float64 Values",
    "Description": "\nThis instruction calculates 2/4/8 range operation outputs from two sets of packed input double precision floating-point values in the first source operand (the second operand) and the second source operand (the third operand). The range outputs are written to the destination operand (the first operand) under the writemask k1.\n\nThe instruction uses an 8-bit immediate value (imm8) to control the range operation:\n- Bits 7:4 of imm8 must be zero\n- Bits 1:0 (imm8[1:0]) specify the initial comparison operation:\n  * 00b: Select Min value\n  * 01b: Select Max value\n  * 10b: Select Min-Abs value\n  * 11b: Select Max-Abs value\n\n- Bits 3:2 (imm8[3:2]) specify the sign of the range operation output:\n  * 00b: Select sign(SRC1)\n  * 01b: Select sign(Compare_Result)\n  * 10b: Set sign to 0\n  * 11b: Set sign to 1\n\nSpecial handling occurs for various edge cases:\n- When one or more input values are NaN, the comparison may signal an invalid exception\n- For zero values with opposite signs, the MIN/MAX operations have specific behaviors\n- For non-zero, equal-magnitude values with opposite signs, MIN_ABS/MAX_ABS operations have specific rules\n\nThe instruction provides flexibility in selecting values and their signs from two input operands, useful for range checking, clamping, and other mathematical operations involving floating-point values.\n",
    "Alias": []
  },
  {
    "Name": "VRANGEPS",
    "Brief": "Range Restriction Calculation for Packed Pairs of Float32 Values",
    "Description": "\nThis instruction calculates 4/8/16 range operation outputs from two sets of packed input single-precision floating-point values in the first source operand (the second operand) and the second source operand (the third operand). The range outputs are written to the destination operand (the first operand) under the writemask k1.\n\nThe range operation is configured by an 8-bit immediate value (imm8) which specifies two key aspects:\n1. The initial comparison operation (imm8[1:0]):\n   - Max\n   - Min\n   - Max absolute value\n   - Min absolute value\n\n2. The sign selection control (imm8[3:2]):\n   - From the first input value\n   - From the comparison result\n   - Set or clear the sign bit\n\nSpecial handling is provided for various edge cases, such as:\n- NaN inputs\n- Zero and opposite-signed inputs\n- Denormal numbers\n\nA typical use case is checking if an input operand is bounded between ±150, where the instruction can selectively choose values and preserve signs based on the comparison and sign selection controls.\n\nThe instruction is part of the AVX-512 instruction set and supports different vector lengths (128, 256, and 512 bits) with optional write masking and broadcast capabilities.\n",
    "Alias": []
  },
  {
    "Name": "VRANGESD",
    "Brief": "Range Restriction Calculation From a Pair of Scalar Float64 Values",
    "Description": "\nThis instruction calculates a range operation output from two input double precision floating-point values in the low qword element of the first source operand and second source operand. The range output is written to the low qword element of the destination operand under the writemask k1.\n\nThe range operation is configured by an 8-bit immediate value (imm8) which specifies two key aspects:\n1. Comparison operation (imm8[1:0]):\n   - Max\n   - Min\n   - Max absolute value\n   - Min absolute value\n\n2. Sign selection control (imm8[3:2]):\n   - From the first input value\n   - From the comparison result\n   - Set sign to zero\n   - Set sign bit\n\nSpecial cases are handled for:\n- NaN inputs\n- Zero inputs with opposite signs\n- Equal magnitude inputs with opposite signs\n\nThe instruction supports various masking and rounding modes through EVEX encoding.\n\nA common use case is range checking, such as bounding an input value between ±1023. For example:\nVRANGESD xmm_dst, xmm_src, xmm_1023, 02h\n- If |xmm_src| < 1023, its value is written to xmm_dst\n- If |xmm_src| ≥ 1023, 1023 is written to xmm_dst\n- The sign of the original input is preserved\n",
    "Alias": []
  },
  {
    "Name": "VRANGESS",
    "Brief": "Range Restriction Calculation From a Pair of Scalar Float32 Values",
    "Description": "\nThis instruction calculates a range operation output from two input single-precision floating-point values in the low dword element of the first source operand and second source operand. The range output is written to the low dword element of the destination operand under the writemask k1.\n\nThe range operation is configured by an 8-bit immediate value (imm8) with two key components:\n1. Bits [1:0] specify the initial comparison operation:\n   - Max value\n   - Min value\n   - Max absolute value\n   - Min absolute value\n\n2. Bits [3:2] specify the sign of the range operation output:\n   - From the first input value\n   - From the comparison result\n   - Set to zero\n   - Set to one\n\nSpecial handling exists for various edge cases:\n- When input values are NAN, the comparison may signal an invalid exception\n- Special handling for zero and opposite-signed values\n- Non-zero, equal-magnitude with opposite-sign inputs have specific comparison rules\n\nThe instruction provides flexibility in comparing and selecting values based on magnitude and sign, useful for range checking and value constraining operations.\n\nAn example use case is checking if an input is bounded between ±150, demonstrating the instruction's utility in range validation and value clamping.\n",
    "Alias": []
  },
  {
    "Name": "VRCP14PD",
    "Brief": "Compute Approximate Reciprocals of Packed Float64 Values",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocals of eight/four/two packed double precision floating-point values in the source operand and stores the packed double precision floating-point results in the destination operand. The maximum relative error for this approximation is less than 2^-14.\n\nThe source operand can be a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register conditionally updated according to the writemask.\n\nThe VRCP14PD instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. A denormal source value will be treated as zero only in case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e., not as a 0.0). Underflow results are flushed to zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e., correct underflow result is written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nMXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.\n",
    "Alias": []
  },
  {
    "Name": "VRCP14PS",
    "Brief": "Compute approximate reciprocals of packed single-precision floating-point values",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocals of the packed single-precision floating-point values in the source operand and stores the packed single-precision floating-point results in the destination operand. The maximum relative error for this approximation is less than 2^-14.\n\nThe source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated according to the writemask.\n\nThe VRCP14PS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. A denormal source value will be treated as zero only in case of DAZ bit set in MXCSR. Otherwise it is treated correctly. Underflow results are flushed to zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.\n",
    "Alias": []
  },
  {
    "Name": "VRCP14SD",
    "Brief": "Compute approximate reciprocal of scalar Float64 value",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocal of the low double precision floating-point value in the second source operand and stores the result in the low quadword element of the destination operand according to the writemask k1. \n\nKey characteristics include:\n- Computes the approximate reciprocal of a scalar double precision floating-point value\n- Maximum relative error less than 2^-14\n- Not affected by rounding control bits in MXCSR\n- Special case handling:\n  * For 0.0 source, returns ∞ with source sign\n  * Denormal values treated as zero only if DAZ bit set in MXCSR\n  * SNaN converted to QNaN or source QNaN returned\n- MXCSR exception flags are not affected\n- Floating-point exceptions are not reported\n\nOperands:\n- Source operand: XMM register or 64-bit memory location\n- Destination operand: XMM register\n- Upper bits of destination copied from first source operand\n",
    "Alias": []
  },
  {
    "Name": "VRCP14SS",
    "Brief": "Compute Approximate Reciprocal of Scalar Float32 Value",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocal of the low single-precision floating-point value in the second source operand and stores the result in the low quadword element of the destination operand according to the writemask k1. \n\nKey characteristics:\n- Bits (127:32) of the XMM register destination are copied from the first source operand\n- Maximum relative error for approximation is less than 2^-14\n- Source operand can be an XMM register or 32-bit memory location\n- Destination operand is an XMM register\n\nSpecial handling:\n- Not affected by MXCSR rounding control bits\n- When source value is 0.0, returns ∞ with the sign of the source value\n- Denormal source values:\n  - Treated as zero if DAZ bit is set in MXCSR\n  - Otherwise treated correctly\n- Underflow results:\n  - Flushed to zero if FTZ bit is set in MXCSR\n  - Otherwise treated correctly with the sign of the operand\n- SNaN converted to QNaN, or source QNaN is returned\n\nMXCSR exception flags are not affected, and floating-point exceptions are not reported.\n",
    "Alias": []
  },
  {
    "Name": "VRCPPH",
    "Brief": "Compute approximate reciprocals of packed FP16 values",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocals of 8/16/32 packed FP16 values in the source operand (the second operand) and stores the packed FP16 results in the destination operand. The maximum relative error for this approximation is less than 2^-11 + 2^-14.\n\nSpecial cases for the instruction include:\n- For values between 0 and 2^-16, the result is +/- INF\n- For values greater than +∞, the result is +0\n- For values less than -∞, the result is -0\n- For values of 2^-n, the result is 2^n\n- For values of -2^-n, the result is -2^n\n\nThe instruction supports different vector lengths (128, 256, and 512 bits) and can use write masks to conditionally update the destination operand.\n",
    "Alias": []
  },
  {
    "Name": "VRCPSH",
    "Brief": "Compute the approximate reciprocal of a scalar FP16 value",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocal of the low FP16 value in the second source operand and stores the result in the low word element of the destination operand according to the writemask k1. \n\nKey characteristics:\n- The maximum relative error for this approximation is less than 2^-11 + 2^-14\n- Bits 127:16 of the destination are copied from the first source operand\n- Bits MAXVL-1:128 of the destination are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n\nThe instruction supports various mask operations:\n- Unconditional computation\n- Masked computation with zeroing\n- Masked computation with merging\n\nSpecial cases are detailed in the referenced table (Table 5-28).\n",
    "Alias": []
  },
  {
    "Name": "VREDUCEPD",
    "Brief": "Perform reduction transformation on packed double precision floating-point values",
    "Description": "\nPerform reduction transformation of the packed binary encoded double precision floating-point values in the source operand and store the reduced results in binary floating-point format to the destination operand under the writemask k1.\n\nThe reduction transformation subtracts the integer part and the leading M fractional bits from the binary floating-point source value, where M is an unsigned integer specified by imm8[7:4]. Specifically, the reduction transformation can be expressed as:\n\ndest = src – (ROUND(2^M*src))*2^-M;\n\nwhere \"Round()\" treats \"src\", \"2^M\", and their product as binary floating-point numbers with normalized significand and biased exponents.\n\nThe magnitude of the reduced result can be expressed by considering src = 2^p * man2, where 'man2' is the normalized significand and 'p' is the unbiased exponent:\n\n- If RC = RNE: 0 <= |Reduced Result| <= 2^(p-M-1)\n- If RC ≠ RNE: 0 <= |Reduced Result| < 2^(p-M)\n\nThis instruction might end up with a precision exception set. However, in case of SPE set (i.e., Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported.\n\nThe instruction handles special cases for different input values, such as infinities, zeros, and NaNs, with specific rounding and handling rules defined in the specification.\n",
    "Alias": []
  },
  {
    "Name": "VREDUCEPH",
    "Brief": "Perform reduction transformation on packed FP16 values",
    "Description": "\nThis instruction performs a reduction transformation of the packed binary encoded FP16 values in the source operand (the second operand) and store the reduced results in binary FP format to the destination operand (the first operand) under the writemask k1.\n\nThe reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source value, where M is an unsigned integer specified by imm8[7:4]. Specifically, the reduction transformation can be expressed as:\n\ndest = src − (ROUND(2^M * src)) * 2^−M\n\nwhere ROUND() treats src, 2^M, and their product as binary FP numbers with normalized significand and biased exponents.\n\nThe magnitude of the reduced result can be expressed by considering src = 2^p * man2, where 'man2' is the normalized significand and 'p' is the unbiased exponent.\n\nThen if RC=RNE: 0 ≤ |ReducedResult| ≤ 2^−M−1.\nThen if RC ≠ RNE: 0 ≤ |ReducedResult| < 2^−M.\n\nThis instruction might end up with a precision exception set. However, in case of SPE set (i.e., Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported.\n\nThis instruction may generate tiny non-zero results. If it does so, it does not report underflow exception, even if underflow exceptions are unmasked (UM flag in MXCSR register is 0).\n\nSpecial cases are handled according to the provided table, including handling of NaN, infinities, and zero values under different rounding modes.\n",
    "Alias": []
  },
  {
    "Name": "VREDUCEPS",
    "Brief": "Perform reduction transformation on packed single-precision floating-point values",
    "Description": "\nPerform reduction transformation of the packed binary encoded single-precision floating-point values in the source operand and store the reduced results in binary floating-point format to the destination operand under the writemask k1.\n\nThe reduction transformation subtracts the integer part and the leading M fractional bits from the binary floating-point source value, where M is an unsigned integer specified by imm8[7:4]. Specifically, the reduction transformation can be expressed as:\n\ndest = src – (ROUND(2^M*src))*2^-M;\n\nwhere \"Round()\" treats \"src\", \"2^M\", and their product as binary floating-point numbers with normalized significand and biased exponents.\n\nThe magnitude of the reduced result can be understood by considering src = 2^p * man2, where 'man2' is the normalized significand and 'p' is the unbiased exponent.\n\nIf RC = RNE: 0 <= |Reduced Result| <= 2^(p-M-1)\nIf RC ≠ RNE: 0 <= |Reduced Result| < 2^(p-M)\n\nThis instruction might result in a precision exception, but if SPE (Suppress Precision Exception) is set, no precision exception is reported.\n\nEVEX.vvvv is reserved and must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VREDUCESD",
    "Brief": "Perform a reduction transformation on a scalar double precision floating-point value",
    "Description": "\nPerform a reduction transformation of the binary encoded double precision floating-point value in the low qword element of the second source operand (the third operand) and store the reduced result in binary floating-point format to the low qword element of the destination operand (the first operand) under the writemask k1. Bits 127:64 of the destination operand are copied from respective qword elements of the first source operand (the second operand).\n\nThe reduction transformation subtracts the integer part and the leading M fractional bits from the binary floating-point source value, where M is an unsigned integer specified by imm8[7:4]. Specifically, the reduction transformation can be expressed as:\n\ndest = src – (ROUND(2^M*src))*2^-M;\n\nwhere \"Round()\" treats \"src\", \"2^M\", and their product as binary floating-point numbers with normalized significand and biased exponents.\n\nThe magnitude of the reduced result can be expressed by considering src = 2^p * man2, where 'man2' is the normalized significand and 'p' is the unbiased exponent:\n\n- If RC = RNE: 0 <= |Reduced Result| <= 2^(p-M-1)\n- If RC ≠ RNE: 0 <= |Reduced Result| < 2^(p-M)\n\nThis instruction might end up with a precision exception set. However, in case of SPE set (i.e., Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported.\n\nThe operation is write masked.\n",
    "Alias": []
  },
  {
    "Name": "VREDUCESH",
    "Brief": "Perform reduction transformation on scalar FP16 value",
    "Description": "\nThis instruction performs a reduction transformation of the low binary encoded FP16 value in the source operand (the second operand) and store the reduced result in binary FP format to the low element of the destination operand (the first operand) under the writemask k1.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nThis instruction might end up with a precision exception set. However, in case of SPE set (i.e., Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported.\n\nThis instruction may generate tiny non-zero result. If it does so, it does not report underflow exception, even if underflow exceptions are unmasked (UM flag in MXCSR register is 0).\n\nThe reduction transformation involves subtracting a number of fraction bits specified by the imm8 field from the source FP16 value.\n",
    "Alias": []
  },
  {
    "Name": "VREDUCESS",
    "Brief": "Perform a reduction transformation on a scalar single-precision floating-point value",
    "Description": "\nPerform a reduction transformation of the binary encoded single-precision floating-point value in the low dword element of the second source operand and store the reduced result in binary floating-point format to the low dword element of the destination operand under the writemask k1. Bits 127:32 of the destination operand are copied from respective dword elements of the first source operand.\n\nThe reduction transformation subtracts the integer part and the leading M fractional bits from the binary floating-point source value, where M is an unsigned integer specified by imm8[7:4]. The reduction can be expressed as:\n\ndest = src – (ROUND(2^M * src)) * 2^-M\n\nWhere \"Round()\" treats \"src\", \"2^M\", and their product as binary floating-point numbers with normalized significand and biased exponents.\n\nThe magnitude of the reduced result can be expressed by:\n- If RC = RNE: 0 <= |Reduced Result| <= 2^(p-M-1)\n- If RC ≠ RNE: 0 <= |Reduced Result| < 2^(p-M)\n\nWhere 'p' is the unbiased exponent and 'man2' is the normalized significand.\n\nThis instruction might generate a precision exception, but if Suppress Precision Exception (SPE) is set, no precision exception is reported.\n",
    "Alias": []
  },
  {
    "Name": "VRNDSCALEPD",
    "Brief": "Round Packed Float64 Values to Include a Given Number of Fraction Bits",
    "Description": "\nRound the double precision floating-point values in the source operand by the rounding mode specified in the immediate operand and places the result in the destination operand.\n\nThe destination operand (the first operand) is a ZMM/YMM/XMM register conditionally updated according to the writemask. The source operand (the second operand) can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location.\n\nThe rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a double precision floating-point value.\n\nNo overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value).\n\nThe immediate operand specifies control fields for the rounding operation:\n- Bit 3 controls precision exception handling\n- Bit 2 selects the source of rounding mode control\n- Bits 1:0 specify a non-sticky rounding-mode value\n\nIf any source operand is an SNaN, it will be converted to a QNaN. If DAZ is set to '1' then denormals will be converted to zero before rounding.\n\nThe sign of the result is preserved, including the sign of zero.\n\nThe formula for the operation is:\nROUND(x) = 2^-M * Round_to_INT(x * 2^M, round_ctrl)\nwhere M = imm[7:4] and round_ctrl = imm[3:0]\n\nVRNDSCALEPD is a more general form of the VEX-encoded VROUNDPD instruction.\n",
    "Alias": []
  },
  {
    "Name": "VRNDSCALEPH",
    "Brief": "Round Packed FP16 Values to Include a Given Number of Fraction Bits",
    "Description": "\nThis instruction rounds the FP16 values in the source operand by the rounding mode specified in the immediate operand and places the result in the destination operand. The destination operand is conditionally updated according to the writemask.\n\nThe rounding process rounds the input to an integral value, plus a number of fraction bits specified by imm8[7:4] (to be included in the result), and returns the result as an FP16 value.\n\nKey characteristics:\n- No overflow is induced during execution\n- Immediate operand controls rounding operation details\n- Precision Floating-Point Exception is signaled based on immediate operand\n- Sign of the result is preserved, including sign of zero\n- Special cases are handled for infinity, NaN, and zero values\n\nThe rounding formula is:\nROUND(x) = 2^−M * Round_to_INT(x * 2^M, round_ctrl)\n\nWhere:\n- M = number of fixed points to preserve (imm8[7:4])\n- round_ctrl = rounding control bits (imm8[1:0])\n\nThe operation is computed with an unlimited exponent range, preventing overflow.\n",
    "Alias": []
  },
  {
    "Name": "VRNDSCALEPS",
    "Brief": "Round Packed Float32 Values to Include a Given Number of Fraction Bits",
    "Description": "\nRound the single-precision floating-point values in the source operand by the rounding mode specified in the immediate operand and places the result in the destination operand.\n\nThe destination operand is a ZMM register conditionally updated according to the writemask. The source operand can be a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location.\n\nThe rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a single-precision floating-point value.\n\nNo overflow is induced while executing this instruction, although the source is scaled by the imm8[7:4] value.\n\nThe immediate operand specifies control fields for the rounding operation:\n- Bit 3 controls the processor behavior for a precision exception\n- Bit 2 selects the source of rounding mode control\n- Bits 1:0 specify a non-sticky rounding-mode value\n\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN, it will be converted to a QNaN. If DAZ is set to '1', denormals will be converted to zero before rounding.\n\nThe sign of the result is preserved, including the sign of zero.\n\nThe formula for the operation on each data element is:\nROUND(x) = 2^-M * Round_to_INT(x * 2^M, round_ctrl)\n\nVRNDSCALEPS is a more general form of the VEX-encoded VROUNDPS instruction.\n",
    "Alias": []
  },
  {
    "Name": "VRNDSCALESD",
    "Brief": "Round scalar double precision floating-point value to include a given number of fraction bits",
    "Description": "\nRounds a double precision floating-point value in the low quadword element of the second source operand by the rounding mode specified in the immediate operand and places the result in the corresponding element of the destination operand according to the writemask. The quadword element at bits 127:64 of the destination is copied from the first source operand.\n\nThe destination and first source operands are XMM registers, the 2nd source operand can be an XMM register or memory location. Bits MAXVL-1:128 of the destination register are cleared.\n\nThe rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a double precision floating-point value.\n\nNo overflow is induced while executing this instruction, although the source is scaled by the imm8[7:4] value.\n\nThe immediate operand specifies control fields for the rounding operation:\n- Bit 3 controls the processor behavior for a precision exception\n- Bit 2 selects the source of rounding mode control\n- Bits 1:0 specify a non-sticky rounding-mode value\n\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN, it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before rounding.\n\nThe sign of the result is preserved, including the sign of zero.\n\nThe formula of the operation is:\nROUND(x) = 2^-M * Round_to_INT(x * 2^M, round_ctrl)\nwhere:\n- round_ctrl = imm[3:0]\n- M = imm[7:4]\n\nVRNDSCALESD is a more general form of the VEX-encoded VROUNDSD instruction.\n",
    "Alias": []
  },
  {
    "Name": "VRNDSCALESH",
    "Brief": "Round Scalar FP16 Value to Include a Given Number of Fraction Bits",
    "Description": "\nThis instruction rounds the low FP16 value in the second source operand by the rounding mode specified in the immediate operand and places the result in the destination operand.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nThe rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result), and returns the result as a FP16 value.\n\nNote that no overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value).\n\nThe immediate operand also specifies control fields for the rounding operation. Three bit fields are defined:\n- Bit 3 controls the processor behavior for a precision exception\n- Bit 2 selects the source of rounding mode control\n- Bits 1:0 specify a non-sticky rounding-mode value\n\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN.\n\nThe sign of the result of this instruction is preserved, including the sign of zero.\n\nThe formula of the operation is:\nROUND(x) = 2^(-M) * Round_to_INT(x * 2^M, round_ctrl)\nWhere:\n- round_ctrl = imm[3:0]\n- M = imm[7:4]\n\nThe operation of x * 2^M is computed as if the exponent range is unlimited (i.e., no overflow ever occurs).\n",
    "Alias": []
  },
  {
    "Name": "VRNDSCALESS",
    "Brief": "Round Scalar Float32 Value to Include a Given Number of Fraction Bits",
    "Description": "\nRounds the single-precision floating-point value in the low doubleword element of the second source operand by the rounding mode specified in the immediate operand and places the result in the corresponding element of the destination operand according to the writemask.\n\nThe rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a single-precision floating-point value.\n\nNo overflow is induced while executing this instruction, although the source is scaled by the imm8[7:4] value.\n\nThe immediate operand specifies control fields for the rounding operation:\n- Bit 3 controls the processor behavior for a precision exception\n- Bit 2 selects the source of rounding mode control\n- Bits 1:0 specify a non-sticky rounding-mode value\n\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN, it will be converted to a QNaN. If DAZ is set to '1', denormals will be converted to zero before rounding.\n\nThe sign of the result is preserved, including the sign of zero.\n\nThe formula for the operation is:\nROUND(x) = 2^-M * Round_to_INT(x * 2^M, round_ctrl)\nWhere:\n- round_ctrl = imm[3:0]\n- M = imm[7:4]\n\nThe operation of x * 2^M is computed as if the exponent range is unlimited (i.e., no overflow ever occurs).\n",
    "Alias": []
  },
  {
    "Name": "VRSQRT14PD",
    "Brief": "Compute approximate reciprocals of square roots of packed double precision floating-point values",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocals of the square roots of the packed double precision floating-point values in the source operand and stores the packed double precision floating-point results in the destination operand according to the writemask. The maximum relative error for this approximation is less than 2^-14.\n\nEVEX.512 encoded version: The source operand can be a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\n\nEVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n\nThe VRSQRT14PD instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. When the source operand is an +∞ then +ZERO value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR. Otherwise it is treated correctly and performs the approximation with the specified masked response. When a source value is a negative value (other than 0.0) a floating-point QNaN_indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\n\nMXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.\n",
    "Alias": []
  },
  {
    "Name": "VRSQRT14PS",
    "Brief": "Compute approximate reciprocals of square roots of packed float32 values",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocals of the square roots of packed single-precision floating-point values in the source operand and stores the results in the destination operand according to the writemask. The maximum relative error for this approximation is less than 2^-14.\n\nThe instruction supports different vector register sizes (ZMM, YMM, XMM) and can work with registers, memory locations, or broadcasted values. The source can be a register, memory location, or a 32-bit value broadcasted to the vector.\n\nKey characteristics:\n- Not affected by MXCSR rounding control bits\n- Special case handling:\n  * 0.0 returns ∞ with source sign\n  * +∞ returns +ZERO\n  * Negative values (except 0.0) return QNaN_indefinite\n  * SNaN/QNaN are converted or returned as-is\n- Denormal values are treated as zero if DAZ is set in MXCSR\n- No floating-point exceptions are reported\n- MXCSR exception flags are not affected\n\nNote: EVEX.vvvv must be 1111b, otherwise the instruction will trigger an undefined instruction (#UD) exception.\n",
    "Alias": []
  },
  {
    "Name": "VRSQRT14SD",
    "Brief": "Compute approximate reciprocal of square root of scalar Float64 value",
    "Description": "\nComputes the approximate reciprocal of the square roots of the scalar double precision floating-point value in the low quadword element of the source operand and stores the result in the low quadword element of the destination operand according to the writemask. The maximum relative error for this approximation is less than 2^-14.\n\nThe source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nThe instruction is not affected by the rounding control bits in the MXCSR register. Special cases include:\n- For 0.0, an ∞ with the sign of the source value is returned\n- For +∞, a +ZERO value is returned\n- For negative values (other than 0.0), a floating-point QNaN_indefinite is returned\n- Denormal source values are treated as zero only if DAZ bit is set in MXCSR\n- SNaN or QNaN are converted or returned as expected\n\nMXCSR exception flags are not affected and floating-point exceptions are not reported.\n",
    "Alias": []
  },
  {
    "Name": "VRSQRT14SS",
    "Brief": "Compute approximate reciprocal of square root of scalar float32 value",
    "Description": "\nComputes the approximate reciprocal of the square root of the scalar single-precision floating-point value in the low doubleword element of the source operand and stores the result in the low doubleword element of the destination operand according to the writemask. The maximum relative error for this approximation is less than 2^-14.\n\nThe source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nThe instruction is not affected by the rounding control bits in the MXCSR register. Special cases include:\n- When source is 0.0, returns ∞ with the sign of the source\n- When source is ∞, returns zero with the sign of the source\n- When source is a negative value (other than 0.0), returns a floating-point indefinite\n- Denormal values are treated as zero if DAZ bit is set in MXCSR\n- SNaN is converted to QNaN, or source QNaN is returned\n\nMXCSR exception flags are not affected, and floating-point exceptions are not reported.\n",
    "Alias": []
  },
  {
    "Name": "VRSQRTPH",
    "Brief": "Compute approximate reciprocals of square roots of packed FP16 values",
    "Description": "\nThis instruction performs a SIMD computation of the approximate reciprocals square-root of 8/16/32 packed FP16 floating-point values in the source operand (the second operand) and stores the packed FP16 floating-point results in the destination operand.\n\nThe maximum relative error for this approximation is less than 2^-11 + 2^-14. \n\nSpecial cases handling includes:\n- Denormal inputs are converted to normal values\n- For X = 2^(-2n), returns 2^n\n- Negative inputs return QNaN_Indefinite\n- -0 returns -∞\n- +0 returns +∞\n- +∞ returns +0\n\nThe destination elements are updated according to the writemask.\n",
    "Alias": []
  },
  {
    "Name": "VRSQRTSH",
    "Brief": "Compute approximate reciprocal of square root of scalar FP16 value",
    "Description": "\nThis instruction performs the computation of the approximate reciprocal square-root of the low FP16 value in the second source operand (the third operand) and stores the result in the low word element of the destination operand (the first operand) according to the writemask k1.\n\nThe maximum relative error for this approximation is less than 2^-11 + 2^-14.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL−1:128 of the destination operand are zeroed.\n\nThe instruction is useful for quickly computing an approximate reciprocal square root of a half-precision floating-point value with low computational overhead and acceptable precision.\n",
    "Alias": []
  },
  {
    "Name": "VSCALEFPD",
    "Brief": "Scale packed double precision floating-point values by 2 to the power of the second source operand",
    "Description": "\nPerforms a floating-point scale of the packed double precision floating-point values in the first source operand by multiplying them by 2 to the power of the double precision floating-point values in the second source operand.\n\nThe equation of this operation is given by:\nzmm1 := zmm2 * 2^floor(zmm3)\n\nFloor(zmm3) means maximum integer value ≤ zmm3.\n\nIf the result cannot be represented in double precision, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.\n\nThe first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\n\nSpecial case handling includes various scenarios with NaN, infinity, zero, and denormal values, with specific rules for how these are processed during the scaling operation.\n",
    "Alias": []
  },
  {
    "Name": "VSCALEFPH",
    "Brief": "Scale Packed FP16 Values with FP16 Values",
    "Description": "\nThis instruction performs a floating-point scale of the packed FP16 values in the first source operand by multiplying it by 2 to the power of the FP16 values in second source operand. The destination elements are updated according to the writemask.\n\nThe equation of this operation is given by:\nzmm1 := zmm2 * 2^floor(zmm3)\n\nFloor(zmm3) means maximum integer value ≤ zmm3.\n\nIf the result cannot be represented in FP16, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand), is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits), and on the SAE bit.\n\nSpecial case handling includes:\n- For NaN, SNaN, Infinity, and Zero inputs, specific result values are defined\n- Underflow occurs when |result| < 2^-24, resulting in ±0 or ±Min-Denormal\n- Overflow occurs when |result| ≥ 2^16, resulting in ±INF or ±Max-Denormal\n\nDenormal-operand exception is checked for the first source operand only if the second source operand is not NaN.\n",
    "Alias": []
  },
  {
    "Name": "VSCALEFPS",
    "Brief": "Scale packed single-precision floating-point values by 2^floor(scaling value)",
    "Description": "\nPerforms a floating-point scale of the packed single-precision floating-point values in the first source operand by multiplying them by 2 to the power of the float32 values in second source operand.\n\nThe equation of this operation is given by:\nzmm1 := zmm2*2^floor(zmm3)\n\nFloor(zmm3) means maximum integer value ≤ zmm3.\n\nIf the result cannot be represented in single-precision, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.\n\nThe instruction supports three vector lengths:\n- EVEX.512: ZMM registers, 512-bit operations\n- EVEX.256: YMM registers, 256-bit operations\n- EVEX.128: XMM registers, 128-bit operations\n\nSpecial case handling includes:\n- Results less than 2^-149 return ±0 or ±Min-Denormal (with source sign)\n- Results greater than or equal to 2^128 return ±INF or ±Max-normal (with source sign)\n",
    "Alias": []
  },
  {
    "Name": "VSCALEFSD",
    "Brief": "Scale scalar double precision floating-point value",
    "Description": "\nPerforms a floating-point scale of the scalar double precision floating-point value in the first source operand by multiplying it by 2 to the power of the double precision floating-point value in second source operand.\n\nThe equation of this operation is given by:\nxmm1 := xmm2*2^floor(xmm3)\n\nFloor(xmm3) means maximum integer value ≤ xmm3.\n\nIf the result cannot be represented in double precision, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.\n\nEVEX encoded version: The first source operand is an XMM register. The second source operand is an XMM register or a memory location. The destination operand is an XMM register conditionally updated with writemask k1.\n\nHandling of special-case input values are detailed in referenced tables.\n",
    "Alias": []
  },
  {
    "Name": "VSCALEFSH",
    "Brief": "Scale Scalar FP16 Values with FP16 Values",
    "Description": "\nThis instruction performs a floating-point scale of the low FP16 element in the first source operand by multiplying it by 2 to the power of the low FP16 element in second source operand, storing the result in the low element of the destination operand.\n\nBits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nThe equation of this operation is given by:\nxmm1 := xmm2 * 2^floor(xmm3)\n\nFloor(xmm3) means maximum integer value ≤ xmm3.\n\nIf the result cannot be represented in FP16, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand), is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.\n\nHandling of special-case input values are listed in referenced tables.\n",
    "Alias": []
  },
  {
    "Name": "VSCALEFSS",
    "Brief": "Scale Scalar Float32 Value With Float32 Value",
    "Description": "\nPerforms a floating-point scale of the scalar single-precision floating-point value in the first source operand by multiplying it by 2 to the power of the float32 value in second source operand.\n\nThe equation of this operation is given by:\nxmm1 := xmm2 * 2^floor(xmm3)\n\nFloor(xmm3) means maximum integer value ≤ xmm3.\n\nIf the result cannot be represented in single-precision, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.\n\nEVEX encoded version: The first source operand is an XMM register. The second source operand is an XMM register or a memory location. The destination operand is an XMM register conditionally updated with writemask k1.\n\nHandling of special-case input values are listed in referenced tables (not shown in this excerpt).\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERDPS",
    "Brief": "Scatter single-precision floating-point values to memory using signed dword indices",
    "Description": "\nStores up to 16 elements (or 8 elements) in doubleword/quadword vector to memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one.\n\nKey characteristics of these scatter instructions include:\n- Uses signed dword (32-bit) or qword (64-bit) indices for memory addressing\n- Supports different vector lengths (128, 256, and 512-bit)\n- Uses a writemask to selectively store elements\n- Entire mask register will be set to zero by the instruction unless an exception is triggered\n\nImportant notes about the scatter operations:\n- Writes to overlapping vector indices are guaranteed to be ordered from LSB to MSB\n- Non-overlapping writes may happen in any order\n- Faults are delivered from right-to-left\n- Does not perform AC (alignment) checks\n- Not valid with 16-bit effective addresses\n- Requires a VSIB (Vector-Scale-Index-Base) byte in the instruction\n\nThe instruction provides flexibility in scattering floating-point values to memory using various index and scale configurations, primarily used in SIMD (Single Instruction, Multiple Data) operations.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERDPD",
    "Brief": "Scatter double-precision floating-point values to memory using signed dword indices",
    "Description": "\nStores up to 16 elements (or 8 elements) in doubleword/quadword vector to memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one.\n\nKey characteristics of these scatter instructions include:\n- Uses signed dword (32-bit) or qword (64-bit) indices for memory addressing\n- Supports different vector lengths (128, 256, and 512-bit)\n- Uses a writemask to selectively store elements\n- Entire mask register will be set to zero by the instruction unless an exception is triggered\n\nImportant notes about the scatter operations:\n- Writes to overlapping vector indices are guaranteed to be ordered from LSB to MSB\n- Non-overlapping writes may happen in any order\n- Faults are delivered from right-to-left\n- Does not perform AC (alignment) checks\n- Not valid with 16-bit effective addresses\n- Requires a VSIB (Vector-Scale-Index-Base) byte in the instruction\n\nThe instruction provides flexibility in scattering floating-point values to memory using various index and scale configurations, primarily used in SIMD (Single Instruction, Multiple Data) operations.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERQPS",
    "Brief": "Scatter single-precision floating-point values to memory using signed qword indices",
    "Description": "\nStores up to 16 elements (or 8 elements) in doubleword/quadword vector to memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one.\n\nKey characteristics of these scatter instructions include:\n- Uses signed dword (32-bit) or qword (64-bit) indices for memory addressing\n- Supports different vector lengths (128, 256, and 512-bit)\n- Uses a writemask to selectively store elements\n- Entire mask register will be set to zero by the instruction unless an exception is triggered\n\nImportant notes about the scatter operations:\n- Writes to overlapping vector indices are guaranteed to be ordered from LSB to MSB\n- Non-overlapping writes may happen in any order\n- Faults are delivered from right-to-left\n- Does not perform AC (alignment) checks\n- Not valid with 16-bit effective addresses\n- Requires a VSIB (Vector-Scale-Index-Base) byte in the instruction\n\nThe instruction provides flexibility in scattering floating-point values to memory using various index and scale configurations, primarily used in SIMD (Single Instruction, Multiple Data) operations.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERQPD",
    "Brief": "Scatter double-precision floating-point values to memory using signed qword indices",
    "Description": "\nStores up to 16 elements (or 8 elements) in doubleword/quadword vector to memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one.\n\nKey characteristics of these scatter instructions include:\n- Uses signed dword (32-bit) or qword (64-bit) indices for memory addressing\n- Supports different vector lengths (128, 256, and 512-bit)\n- Uses a writemask to selectively store elements\n- Entire mask register will be set to zero by the instruction unless an exception is triggered\n\nImportant notes about the scatter operations:\n- Writes to overlapping vector indices are guaranteed to be ordered from LSB to MSB\n- Non-overlapping writes may happen in any order\n- Faults are delivered from right-to-left\n- Does not perform AC (alignment) checks\n- Not valid with 16-bit effective addresses\n- Requires a VSIB (Vector-Scale-Index-Base) byte in the instruction\n\nThe instruction provides flexibility in scattering floating-point values to memory using various index and scale configurations, primarily used in SIMD (Single Instruction, Multiple Data) operations.\n",
    "Alias": []
  },
  {
    "Name": "VSHUFF32x4",
    "Brief": "Shuffle 128-bit packed single-precision floating-point values",
    "Description": "\nThese instructions perform shuffling of packed values at 128-bit granularity from two source operands into a destination operand.\n\n256-bit Version:\n- Moves one of two 128-bit packed values from the first source operand into the low 128-bit of the destination operand\n- Moves one of two 128-bit packed values from the second source operand into the high 128-bit of the destination operand\n- The selector operand determines which values are moved\n\n512-bit Version:\n- Moves two of four 128-bit packed values from the first source operand into the low 256-bit of each double qword of the destination operand\n- Moves two of four 128-bit packed values from the second source operand into the high 256-bit of the destination operand\n- The selector operand determines which values are moved\n\nKey characteristics:\n- First source operand is a vector register\n- Second source operand can be a ZMM register, memory location, or broadcasted from a 32/64-bit memory location\n- Destination operand is a vector register\n- Supports writemask updates with granularity of 32/64-bit data elements\n\nVariations include:\n- VSHUFF32x4: Shuffles single-precision floating-point values\n- VSHUFF64x2: Shuffles double-precision floating-point values\n- VSHUFI32x4: Shuffles double-word values\n- VSHUFI64x2: Shuffles quad-word values\n",
    "Alias": []
  },
  {
    "Name": "VSHUFF64x2",
    "Brief": "Shuffle 128-bit packed double precision floating-point values",
    "Description": "\nThese instructions perform shuffling of packed values at 128-bit granularity from two source operands into a destination operand.\n\n256-bit Version:\n- Moves one of two 128-bit packed values from the first source operand into the low 128-bit of the destination operand\n- Moves one of two 128-bit packed values from the second source operand into the high 128-bit of the destination operand\n- The selector operand determines which values are moved\n\n512-bit Version:\n- Moves two of four 128-bit packed values from the first source operand into the low 256-bit of each double qword of the destination operand\n- Moves two of four 128-bit packed values from the second source operand into the high 256-bit of the destination operand\n- The selector operand determines which values are moved\n\nKey characteristics:\n- First source operand is a vector register\n- Second source operand can be a ZMM register, memory location, or broadcasted from a 32/64-bit memory location\n- Destination operand is a vector register\n- Supports writemask updates with granularity of 32/64-bit data elements\n\nVariations include:\n- VSHUFF32x4: Shuffles single-precision floating-point values\n- VSHUFF64x2: Shuffles double-precision floating-point values\n- VSHUFI32x4: Shuffles double-word values\n- VSHUFI64x2: Shuffles quad-word values\n",
    "Alias": []
  },
  {
    "Name": "VSHUFI32x4",
    "Brief": "Shuffle 128-bit packed double-word values",
    "Description": "\nThese instructions perform shuffling of packed values at 128-bit granularity from two source operands into a destination operand.\n\n256-bit Version:\n- Moves one of two 128-bit packed values from the first source operand into the low 128-bit of the destination operand\n- Moves one of two 128-bit packed values from the second source operand into the high 128-bit of the destination operand\n- The selector operand determines which values are moved\n\n512-bit Version:\n- Moves two of four 128-bit packed values from the first source operand into the low 256-bit of each double qword of the destination operand\n- Moves two of four 128-bit packed values from the second source operand into the high 256-bit of the destination operand\n- The selector operand determines which values are moved\n\nKey characteristics:\n- First source operand is a vector register\n- Second source operand can be a ZMM register, memory location, or broadcasted from a 32/64-bit memory location\n- Destination operand is a vector register\n- Supports writemask updates with granularity of 32/64-bit data elements\n\nVariations include:\n- VSHUFF32x4: Shuffles single-precision floating-point values\n- VSHUFF64x2: Shuffles double-precision floating-point values\n- VSHUFI32x4: Shuffles double-word values\n- VSHUFI64x2: Shuffles quad-word values\n",
    "Alias": []
  },
  {
    "Name": "VSHUFI64x2",
    "Brief": "Shuffle 128-bit packed quad-word values",
    "Description": "\nThese instructions perform shuffling of packed values at 128-bit granularity from two source operands into a destination operand.\n\n256-bit Version:\n- Moves one of two 128-bit packed values from the first source operand into the low 128-bit of the destination operand\n- Moves one of two 128-bit packed values from the second source operand into the high 128-bit of the destination operand\n- The selector operand determines which values are moved\n\n512-bit Version:\n- Moves two of four 128-bit packed values from the first source operand into the low 256-bit of each double qword of the destination operand\n- Moves two of four 128-bit packed values from the second source operand into the high 256-bit of the destination operand\n- The selector operand determines which values are moved\n\nKey characteristics:\n- First source operand is a vector register\n- Second source operand can be a ZMM register, memory location, or broadcasted from a 32/64-bit memory location\n- Destination operand is a vector register\n- Supports writemask updates with granularity of 32/64-bit data elements\n\nVariations include:\n- VSHUFF32x4: Shuffles single-precision floating-point values\n- VSHUFF64x2: Shuffles double-precision floating-point values\n- VSHUFI32x4: Shuffles double-word values\n- VSHUFI64x2: Shuffles quad-word values\n",
    "Alias": []
  },
  {
    "Name": "VSQRTPH",
    "Brief": "Compute square roots of packed FP16 values",
    "Description": "\nThis instruction performs a packed FP16 square-root computation on the values from source operand and stores the packed FP16 result in the destination operand. The destination elements are updated according to the write-mask.\n\nThe instruction is available in three vector length variants:\n1. EVEX.128: Computes square roots for 8 FP16 values in 128-bit vectors\n2. EVEX.256: Computes square roots for 16 FP16 values in 256-bit vectors\n3. EVEX.512: Computes square roots for 32 FP16 values in 512-bit vectors\n\nThe instruction supports various masking and rounding options:\n- Optional write mask (k1) to selectively update destination elements\n- Optional zeroing of masked elements\n- Rounding mode control for 512-bit vectors\n\nSupported CPUID feature flags include:\n- AVX512-FP16\n- AVX512VL (for 128 and 256-bit variants)\n",
    "Alias": []
  },
  {
    "Name": "VSQRTSH",
    "Brief": "Compute square root of scalar FP16 value",
    "Description": "\nThis instruction performs a scalar FP16 square-root computation on the source operand and stores the FP16 result in the destination operand. Bits 127:16 of the destination operand are copied from the corresponding bits of the first source operand. Bits MAXVL-1:128 of the destination operand are zeroed. The low FP16 element of the destination is updated according to the writemask.\n\nThe instruction supports various masking and rounding options:\n- Can use a writemask to conditionally update the result\n- Supports zeroing or merging masking\n- Provides optional rounding modes for the square root computation\n\nThe operation performs these key steps:\n1. Compute the square root of the low FP16 element of the source\n2. Copy the upper bits from the first source operand\n3. Zero out the upper bits of the destination\n4. Apply the writemask to control the update of the result\n\nFloating-point exceptions that may be raised include:\n- Invalid operation\n- Precision\n- Denormal\n",
    "Alias": []
  },
  {
    "Name": "VSUBPH",
    "Brief": "Subtract packed FP16 values",
    "Description": "\nThis instruction subtracts packed FP16 values from the second source operand from the corresponding elements in the first source operand, storing the packed FP16 result in the destination operand. The destination elements are updated according to the writemask.\n\nThe instruction supports three vector length variants:\n- 128-bit (XMM registers): 8 FP16 values\n- 256-bit (YMM registers): 16 FP16 values\n- 512-bit (ZMM registers): 32 FP16 values\n\nThe operation can be performed with different masking modes:\n- No mask: All elements are computed\n- Writemask: Only elements with corresponding mask bit set are computed\n- Zeroing mask: Elements with corresponding mask bit not set are set to zero\n\nFor memory sources, there's an option for broadcast mode where a single FP16 value from memory can be subtracted from all elements of the source register.\n\nThe rounding mode can be controlled by MXCSR or explicitly specified for the 512-bit version.\n",
    "Alias": []
  },
  {
    "Name": "VSUBSH",
    "Brief": "Subtract scalar FP16 value",
    "Description": "\nThis instruction subtracts the low FP16 value from the second source operand from the corresponding value in the first source operand, storing the FP16 result in the destination operand. \n\nSpecifically:\n- The low FP16 element is subtracted\n- Bits 127:16 of the destination operand are copied from the first source operand \n- Bits MAXVL-1:128 of the destination operand are zeroed\n- The low FP16 element of the destination is updated according to the writemask\n\nThe instruction supports various rounding modes and masking options, including:\n- Explicit rounding control\n- Mask-based conditional execution\n- Zeroing or merging masked elements\n\nPotential floating-point exceptions include:\n- Invalid operation\n- Underflow\n- Overflow\n- Precision\n- Denormal\n",
    "Alias": []
  },
  {
    "Name": "VTESTPS",
    "Brief": "Packed Bit Test for Single-Precision Floating-Point",
    "Description": "\nVTESTPS and VTESTPD perform a bitwise comparison of sign bits in packed floating-point elements:\n\n1. For VTESTPS (Single-Precision):\n   - Compares sign bits of 4 (128-bit) or 8 (256-bit) single-precision floating-point elements\n   - Sets Zero Flag (ZF) if AND of source and destination sign bits produces all zeros\n   - Sets Carry Flag (CF) if AND of source sign bits with inverted destination sign bits produces all zeros\n\n2. For VTESTPD (Double-Precision):\n   - Compares sign bits of 2 (128-bit) or 4 (256-bit) double-precision floating-point elements\n   - Follows the same ZF and CF setting logic as VTESTPS\n\nKey characteristics:\n- First source register specified by ModR/M reg field\n- 128-bit version uses XMM registers\n- 256-bit version uses YMM registers\n- Destination register is not modified\n- VEX.vvvv must be 1111b, otherwise #UD exception is raised\n- Attempting to execute with VEX.W=1 causes #UD exception\n\nThe instruction is useful for bit-level testing and comparison of packed floating-point sign bits without modifying the source operands.\n",
    "Alias": []
  },
  {
    "Name": "VTESTPD",
    "Brief": "Packed Bit Test for Double-Precision Floating-Point",
    "Description": "\nVTESTPS and VTESTPD perform a bitwise comparison of sign bits in packed floating-point elements:\n\n1. For VTESTPS (Single-Precision):\n   - Compares sign bits of 4 (128-bit) or 8 (256-bit) single-precision floating-point elements\n   - Sets Zero Flag (ZF) if AND of source and destination sign bits produces all zeros\n   - Sets Carry Flag (CF) if AND of source sign bits with inverted destination sign bits produces all zeros\n\n2. For VTESTPD (Double-Precision):\n   - Compares sign bits of 2 (128-bit) or 4 (256-bit) double-precision floating-point elements\n   - Follows the same ZF and CF setting logic as VTESTPS\n\nKey characteristics:\n- First source register specified by ModR/M reg field\n- 128-bit version uses XMM registers\n- 256-bit version uses YMM registers\n- Destination register is not modified\n- VEX.vvvv must be 1111b, otherwise #UD exception is raised\n- Attempting to execute with VEX.W=1 causes #UD exception\n\nThe instruction is useful for bit-level testing and comparison of packed floating-point sign bits without modifying the source operands.\n",
    "Alias": []
  },
  {
    "Name": "VUCOMISH",
    "Brief": "Unordered Compare Scalar FP16 Values and Set EFLAGS",
    "Description": "\nThis instruction compares the FP16 values in the low word of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\n\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 16-bit memory location.\n\nThe VUCOMISH instruction differs from the VCOMISH instruction in that it signals a SIMD floating-point invalid operation exception (#I) only if a source operand is an SNaN. The COMISS instruction signals an invalid numeric exception when a source operand is either a QNaN or SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated. EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VZEROALL",
    "Brief": "Zero XMM, YMM, and ZMM Registers",
    "Description": "\nIn 64-bit mode, the instruction zeroes XMM0-XMM15, YMM0-YMM15, and ZMM0-ZMM15. Outside 64-bit mode, it zeroes only XMM0-XMM7, YMM0-YMM7, and ZMM0-ZMM7. VZEROALL does not modify ZMM16-ZMM31.\n\nNote: VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified.\n\nThe instruction works by setting all bits of the specified SIMD registers to zero across the register file. In 64-bit mode, it affects registers XMM0-XMM15, YMM0-YMM15, and ZMM0-ZMM15, while in other modes it affects only the first 8 registers of each type.\n",
    "Alias": []
  },
  {
    "Name": "VZEROUPPER",
    "Brief": "Zero upper bits of YMM and ZMM registers",
    "Description": "\nIn 64-bit mode, the instruction zeroes the bits in positions 128 and higher in YMM0-YMM15 and ZMM0-ZMM15. Outside 64-bit mode, it zeroes those bits only in YMM0-YMM7 and ZMM0-ZMM7. VZEROUPPER does not modify the lower 128 bits of these registers and it does not modify ZMM16-ZMM31.\n\nThis instruction is recommended when transitioning between AVX and legacy SSE code; it will eliminate performance penalties caused by false dependencies.\n\nNote: VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified.\n",
    "Alias": []
  },
  {
    "Name": "WBINVD",
    "Brief": "Write back and invalidate internal and external caches",
    "Description": "\nWrites back all modified cache lines in the processor's internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated.\n\nAfter executing this instruction, the processor does not wait for the external caches to complete their write-back and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back and flush signals. The amount of time or cycles for WBINVD to complete will vary due to size and other factors of different cache hierarchies.\n\nThe WBINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction.\n\nIn situations where cache coherency with main memory is not a concern, software can use the INVD instruction.\n\nThis instruction is not supported on IA-32 processors earlier than the Intel486 processor, and its function may be implemented differently on future Intel 64 and IA-32 processors.\n",
    "Alias": []
  },
  {
    "Name": "WBNOINVD",
    "Brief": "Write back internal caches without flushing",
    "Description": "\nThe WBNOINVD instruction writes back all modified cache lines in the processor's internal cache to main memory but does not invalidate (flush) the internal caches.\n\nAfter executing this instruction, the processor does not wait for the external caches to complete their write-back operation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back signal. The amount of time or cycles for WBNOINVD to complete will vary due to size and other factors of different cache hierarchies. As a consequence, the use of the WBNOINVD instruction can have an impact on logical processor interrupt/event response time.\n\nThe WBNOINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction.\n\nThe instruction writes back internal caches and continues execution immediately without waiting for external caches to complete their write-back operation.\n",
    "Alias": []
  },
  {
    "Name": "WRFSBASE",
    "Brief": "Write FS segment base address",
    "Description": "\nLoads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.\n\nThe source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.\n\nThis instruction is supported only in 64-bit mode. \n\nKey characteristics:\n- Requires FSGSBASE feature to be enabled\n- Requires CR4.FSGSBASE[bit 16] to be set\n- Can use 32-bit or 64-bit registers\n- Source register must contain a canonical address\n- Not supported in protected, real, virtual-8086, or compatibility modes\n\nThe instruction simply sets the base address of the FS or GS segment to the value in the specified source register.\n",
    "Alias": []
  },
  {
    "Name": "WRGSBASE",
    "Brief": "Write GS segment base address",
    "Description": "\nLoads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.\n\nThe source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.\n\nThis instruction is supported only in 64-bit mode. \n\nKey characteristics:\n- Requires FSGSBASE feature to be enabled\n- Requires CR4.FSGSBASE[bit 16] to be set\n- Can use 32-bit or 64-bit registers\n- Source register must contain a canonical address\n- Not supported in protected, real, virtual-8086, or compatibility modes\n\nThe instruction simply sets the base address of the FS or GS segment to the value in the specified source register.\n",
    "Alias": []
  },
  {
    "Name": "WRMSR",
    "Brief": "Write to Model Specific Register",
    "Description": "\nWrites the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected MSR and the contents of the EAX register are copied to low-order 32 bits of the MSR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an MSR should be set to values previously read.\n\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to bits in a reserved MSR.\n\nWhen the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated. This includes global entries.\n\nMSRs control functions for testability, execution tracing, performance-monitoring and machine check errors. Each processor family has its own set of MSRs.\n\nThe WRMSR instruction is a serializing instruction. Note that WRMSR to the IA32_TSC_DEADLINE MSR and the X2APIC MSRs are not serializing.\n\nThe CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction.\n",
    "Alias": []
  },
  {
    "Name": "WRPKRU",
    "Brief": "Write Data to User Page Key Register",
    "Description": "\nWrites the value of EAX into PKRU. ECX and EDX must be 0 when WRPKRU is executed; otherwise, a general-protection exception (#GP) occurs.\n\nWRPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].\n\nOn processors that support the Intel 64 Architecture, the high-order 32-bits of RCX, RDX, and RAX are ignored.\n\nWRPKRU will never execute speculatively. Memory accesses affected by PKRU register will not execute (even speculatively) until all prior executions of WRPKRU have completed execution and updated the PKRU register.\n",
    "Alias": []
  },
  {
    "Name": "WRSSD",
    "Brief": "Write 4 bytes to shadow stack",
    "Description": "\nWrites bytes in register source to the shadow stack.\n\nThe instruction behaves differently based on the privilege level (CPL) and certain control register and model-specific register settings:\n\n- For CPL = 3 (user mode):\n  - CR4.CET and IA32_U_CET.SH_STK_EN must be enabled\n  - IA32_U_CET.WR_SHSTK_EN must be enabled\n\n- For CPL < 3 (supervisor mode):\n  - CR4.CET and IA32_S_CET.SH_STK_EN must be enabled\n  - IA32_S_CET.WR_SHSTK_EN must be enabled\n\nThe instruction checks for proper alignment:\n- 64-bit version (WRSSQ) requires 8-byte alignment\n- 32-bit version (WRSSD) requires 4-byte alignment\n\nIf any of these conditions are not met, the instruction will generate an appropriate exception (#UD or #GP).\n\nThe primary purpose is to write data to a shadow stack, which is a security feature designed to protect against certain types of control-flow hijacking attacks.\n",
    "Alias": []
  },
  {
    "Name": "WRSSQ",
    "Brief": "Write 8 bytes to shadow stack",
    "Description": "\nWrites bytes in register source to the shadow stack.\n\nThe instruction behaves differently based on the privilege level (CPL) and certain control register and model-specific register settings:\n\n- For CPL = 3 (user mode):\n  - CR4.CET and IA32_U_CET.SH_STK_EN must be enabled\n  - IA32_U_CET.WR_SHSTK_EN must be enabled\n\n- For CPL < 3 (supervisor mode):\n  - CR4.CET and IA32_S_CET.SH_STK_EN must be enabled\n  - IA32_S_CET.WR_SHSTK_EN must be enabled\n\nThe instruction checks for proper alignment:\n- 64-bit version (WRSSQ) requires 8-byte alignment\n- 32-bit version (WRSSD) requires 4-byte alignment\n\nIf any of these conditions are not met, the instruction will generate an appropriate exception (#UD or #GP).\n\nThe primary purpose is to write data to a shadow stack, which is a security feature designed to protect against certain types of control-flow hijacking attacks.\n",
    "Alias": []
  },
  {
    "Name": "WRUSSD",
    "Brief": "Write 4 bytes to user shadow stack",
    "Description": "\nWrites bytes in register source to a user shadow stack page. The WRUSS instruction can be executed only if CPL = 0, however the processor treats its shadow-stack accesses as user accesses.\n\nThe instructions have the following key characteristics:\n- WRUSSD writes 4 bytes to the shadow stack\n- WRUSSQ writes 8 bytes to the shadow stack\n- Can only be executed when CPL (Current Privilege Level) is 0\n- Requires CR4.CET (Control Register 4 Control-Flow Enforcement Technology bit) to be set\n- Destination must be aligned (4 bytes for WRUSSD, 8 bytes for WRUSSQ)\n- Processor treats shadow stack accesses as user-mode accesses\n\nThese instructions are part of the Control-Flow Enforcement Technology (CET) feature, which helps protect against certain types of attacks like return-oriented programming.\n",
    "Alias": []
  },
  {
    "Name": "WRUSSQ",
    "Brief": "Write 8 bytes to user shadow stack",
    "Description": "\nWrites bytes in register source to a user shadow stack page. The WRUSS instruction can be executed only if CPL = 0, however the processor treats its shadow-stack accesses as user accesses.\n\nThe instructions have the following key characteristics:\n- WRUSSD writes 4 bytes to the shadow stack\n- WRUSSQ writes 8 bytes to the shadow stack\n- Can only be executed when CPL (Current Privilege Level) is 0\n- Requires CR4.CET (Control Register 4 Control-Flow Enforcement Technology bit) to be set\n- Destination must be aligned (4 bytes for WRUSSD, 8 bytes for WRUSSQ)\n- Processor treats shadow stack accesses as user-mode accesses\n\nThese instructions are part of the Control-Flow Enforcement Technology (CET) feature, which helps protect against certain types of attacks like return-oriented programming.\n",
    "Alias": []
  },
  {
    "Name": "XABORT",
    "Brief": "Forces an RTM (Restricted Transactional Memory) abort",
    "Description": "\nXABORT forces an RTM abort. Following an RTM abort, the logical processor resumes execution at the fallback address computed through the outermost XBEGIN instruction. The EAX register is updated to reflect that an XABORT instruction caused the abort, and the imm8 argument will be provided in bits 31:24 of EAX.\n\nWhen XABORT is executed outside of an RTM (Restricted Transactional Memory) execution context, it is treated as a NOP (No Operation). When executed during RTM execution, it triggers the RTM abort processing, which includes:\n- Restoring architectural register state\n- Discarding memory updates performed in the transaction\n- Updating EAX with status and XABORT argument\n- Resetting RTM_NEST_COUNT to 0\n- Setting RTM_ACTIVE to 0\n- Setting SUSLDTRK_ACTIVE to 0\n- Resuming execution at the fallback instruction address (RIP or EIP)\n\nThe instruction is only valid when RTM (Restricted Transactional Memory) is supported, as indicated by the CPUID feature flag.\n",
    "Alias": []
  },
  {
    "Name": "XACQUIRE",
    "Brief": "Hint to start lock elision on a memory address",
    "Description": "\nThe XACQUIRE prefix is a hint to start lock elision on the memory address specified by the instruction, and the XRELEASE prefix is a hint to end lock elision on the memory address specified by the instruction.\n\nThe XACQUIRE prefix can only be used with specific instructions that have an explicit LOCK prefix or the XCHG instruction. These instructions are referred to as XACQUIRE-enabled.\n\nThe XRELEASE prefix can be used with similar LOCK-prefixed instructions, the XCHG instruction, and certain MOV instructions. These are referred to as XRELEASE-enabled.\n\nThe lock variables must satisfy specific guidelines described in the Intel 64 and IA-32 Architectures Software Developer's Manual for elision to be successful, otherwise an HLE (Hardware Lock Elision) abort may be signaled.\n\nIf both XACQUIRE and XRELEASE prefixes are present, the HLE semantic is determined by the prefix byte closest to the instruction opcode.\n\nThe effect of the XACQUIRE/XRELEASE prefix hint is the same in both non-64-bit modes and 64-bit mode. For instructions that do not support these hints, the prefixes behave according to their traditional semantics.\n",
    "Alias": []
  },
  {
    "Name": "XRELEASE",
    "Brief": "Hint to end lock elision on a memory address",
    "Description": "\nThe XACQUIRE prefix is a hint to start lock elision on the memory address specified by the instruction, and the XRELEASE prefix is a hint to end lock elision on the memory address specified by the instruction.\n\nThe XACQUIRE prefix can only be used with specific instructions that have an explicit LOCK prefix or the XCHG instruction. These instructions are referred to as XACQUIRE-enabled.\n\nThe XRELEASE prefix can be used with similar LOCK-prefixed instructions, the XCHG instruction, and certain MOV instructions. These are referred to as XRELEASE-enabled.\n\nThe lock variables must satisfy specific guidelines described in the Intel 64 and IA-32 Architectures Software Developer's Manual for elision to be successful, otherwise an HLE (Hardware Lock Elision) abort may be signaled.\n\nIf both XACQUIRE and XRELEASE prefixes are present, the HLE semantic is determined by the prefix byte closest to the instruction opcode.\n\nThe effect of the XACQUIRE/XRELEASE prefix hint is the same in both non-64-bit modes and 64-bit mode. For instructions that do not support these hints, the prefixes behave according to their traditional semantics.\n",
    "Alias": []
  },
  {
    "Name": "XADD",
    "Brief": "Exchange and Add - swaps the first and second operands, then stores their sum in the destination",
    "Description": "\nExchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIA-32 processors earlier than the Intel486 processor do not recognize this instruction. If this instruction is used, an equivalent code sequence that runs on earlier processors should be provided.\n\nThe operation follows these steps:\n1. Create a temporary variable with the sum of the source and destination\n2. Copy the destination value to the source\n3. Store the temporary sum in the destination\n\nThe CF, PF, AF, SF, ZF, and OF flags are set according to the result of the addition, which is stored in the destination operand.\n",
    "Alias": []
  },
  {
    "Name": "XBEGIN",
    "Brief": "Specifies the start of a Restricted Transactional Memory (RTM) region",
    "Description": "\nThe XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in transactional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execution. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback code path following a transactional abort.\n\nOn an RTM abort, the logical processor discards all architectural register and memory updates performed during the RTM execution and restores architectural state to that corresponding to the outermost XBEGIN instruction. The fallback address following an abort is computed from the outermost XBEGIN instruction.\n\nExecution of XBEGIN while in a suspend read address tracking region causes a transactional abort.\n\nKey points:\n- Marks the beginning of a transactional memory region\n- Provides a fallback address for abort scenarios\n- Supports nested transactions up to a maximum nesting count\n- Discards all updates and restores state on abort\n",
    "Alias": []
  },
  {
    "Name": "XCHG",
    "Brief": "Exchange the contents of the destination and source operands",
    "Description": "\nExchanges the contents of the destination (first) and source (second) operands. The operands can be two general-purpose registers or a register and a memory location. If a memory operand is referenced, the processor's locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL.\n\nThis instruction is useful for implementing semaphores or similar data structures for process synchronization. The XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nNote: XCHG (E)AX, (E)AX (encoded instruction byte is 90H) is an alias for NOP regardless of data size prefixes, including REX.W.\n\nThe operation can be summarized as:\nTEMP := DEST;\nDEST := SRC;\nSRC := TEMP;\n",
    "Alias": []
  },
  {
    "Name": "XEND",
    "Brief": "Marks the end of an RTM (Restricted Transactional Memory) code region",
    "Description": "\nThe instruction marks the end of an RTM code region. If this corresponds to the outermost scope (that is, including this XEND instruction, the number of XBEGIN instructions is the same as number of XEND instructions), the logical processor will attempt to commit the logical processor state atomically.\n\nIf the commit fails, the logical processor will rollback all architectural register and memory updates performed during the RTM execution. The logical processor will resume execution at the fallback address computed from the outermost XBEGIN instruction. The EAX register is updated to reflect RTM abort information.\n\nExecution of XEND outside a transactional region causes a general-protection exception (#GP). Execution of XEND while in a suspend read address tracking region causes a transactional abort.\n\nThe instruction works in both 64-bit and 32-bit modes, and requires the RTM (Restricted Transactional Memory) CPUID feature flag.\n",
    "Alias": []
  },
  {
    "Name": "XGETBV",
    "Brief": "Get Value of Extended Control Register",
    "Description": "\nReads the contents of the extended control register (XCR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the XCR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the XCR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.\n\nXCR0 is supported on any processor that supports the XGETBV instruction. If CPUID.(EAX=0DH,ECX=1):EAX.XG1[bit 2] = 1, executing XGETBV with ECX = 1 returns in EDX:EAX the logical AND of XCR0 and the current value of the XINUSE state-component bitmap. This allows software to discover the state of the init optimization used by XSAVEOPT and XSAVES.\n\nUse of any other value for ECX results in a general-protection (#GP) exception.\n",
    "Alias": []
  },
  {
    "Name": "XLAT",
    "Brief": "Table Look-up Translation",
    "Description": "\nLocates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer.\n\nThe XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.)\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operand form (XLAT): Allows the base address of the table to be specified explicitly with a symbol. However, the actual base address is always specified by the DS:(E)BX registers.\n2. No-operands form (XLATB): Provides a \"short form\" of the XLAT instruction.\n\nIn 64-bit mode, the operation is similar to legacy or compatibility mode. AL is used to specify the table index (the operand size is fixed at 8 bits), and RBX is used to specify the table's base address.\n",
    "Alias": []
  },
  {
    "Name": "XLATB",
    "Brief": "Table Look-up Translation",
    "Description": "\nLocates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer.\n\nThe XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.)\n\nAt the assembly-code level, two forms of this instruction are allowed:\n1. Explicit-operand form (XLAT): Allows the base address of the table to be specified explicitly with a symbol. However, the actual base address is always specified by the DS:(E)BX registers.\n2. No-operands form (XLATB): Provides a \"short form\" of the XLAT instruction.\n\nIn 64-bit mode, the operation is similar to legacy or compatibility mode. AL is used to specify the table index (the operand size is fixed at 8 bits), and RBX is used to specify the table's base address.\n",
    "Alias": []
  },
  {
    "Name": "XOR",
    "Brief": "Performs a bitwise exclusive OR (XOR) operation on the destination and source operands",
    "Description": "\nPerforms a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.\n\nThe OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.\n",
    "Alias": []
  },
  {
    "Name": "XORPD",
    "Brief": "Bitwise Logical XOR of Packed Double Precision Floating-Point Values",
    "Description": "\nPerforms a bitwise logical XOR of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand can be a ZMM register or a vector memory location. The destination operand is a ZMM register conditionally updated with write-mask k1.\n\nVEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "XORPS",
    "Brief": "Bitwise Logical XOR of Packed Single Precision Floating-Point Values",
    "Description": "\nPerforms a bitwise logical XOR of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\n\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand can be a ZMM register or a vector memory location. The destination operand is a ZMM register conditionally updated with write-mask k1.\n\nVEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\n\nVEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\n",
    "Alias": []
  },
  {
    "Name": "XRESLDTRK",
    "Brief": "Resume tracking load addresses in an Intel TSX transaction",
    "Description": "\nThe instruction marks the end of an Intel TSX (RTM) suspend load address tracking region. If the instruction is used inside a suspend load address tracking region it will end the suspend region and all following load addresses will be added to the transaction read set. If this instruction is used inside an active transaction but not in a suspend region it will cause transaction abort.\n\nIf the instruction is used outside of a transactional region it behaves like a NOP.\n\nThis instruction is part of the Intel Transactional Synchronization Extensions (TSX) and is used to manage load address tracking during a transaction. When used within a suspend load address tracking region, it resumes tracking load addresses for the transaction's read set.\n\nChapter 16, \"Programming with Intel® Transactional Synchronization Extensions‚\" in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1 provides additional information on Intel® TSX Suspend Load Address Tracking.\n",
    "Alias": []
  },
  {
    "Name": "XRSTOR",
    "Brief": "Restore Processor Extended States",
    "Description": "\nPerforms a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\n\nThe format of the XSAVE area is detailed in Section 13.4, \"XSAVE Area,\" of Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix.\n\nThe instruction can execute in two forms:\n1. Standard form (when bit 63 of XCOMP_BV is 0)\n2. Compacted form (when bit 63 of XCOMP_BV is 1)\n\nKey points:\n- If a state component's bit is 0 in RFBM, XRSTOR does not update that component\n- If a state component's bit is 1 in RFBM and 0 in XSTATE_BV, XRSTOR initializes the component\n- If a state component's bit is 1 in both RFBM and XSTATE_BV, XRSTOR loads the component from the XSAVE area\n\nUse of a source operand not aligned to a 64-byte boundary results in a general-protection (#GP) exception.\n",
    "Alias": []
  },
  {
    "Name": "XRSTORS",
    "Brief": "Restore Processor Extended States Supervisor",
    "Description": "\nPerforms a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if CPL = 0.\n\nKey characteristics of XRSTORS include:\n- Similar to the compacted form of XRSTOR\n- Can restore state components corresponding to bits set in the IA32_XSS MSR\n- If RFBM[i] = 0, does not update state component i\n- If RFBM[i] = 1 and bit i is clear in the XSTATE_BV field, initializes state component i\n- If RFBM[i] = 1 and XSTATE_BV[i] = 1, loads state component i from the XSAVE area\n- Loads the internal value XRSTOR_INFO for potential optimization of subsequent XSAVEOPT or XSAVES\n\nUse of a source operand not aligned to a 64-byte boundary results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n",
    "Alias": []
  },
  {
    "Name": "XRSTORS64",
    "Brief": "Restore Processor Extended States Supervisor in 64-bit mode",
    "Description": "\nPerforms a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if CPL = 0.\n\nKey characteristics of XRSTORS include:\n- Similar to the compacted form of XRSTOR\n- Can restore state components corresponding to bits set in the IA32_XSS MSR\n- If RFBM[i] = 0, does not update state component i\n- If RFBM[i] = 1 and bit i is clear in the XSTATE_BV field, initializes state component i\n- If RFBM[i] = 1 and XSTATE_BV[i] = 1, loads state component i from the XSAVE area\n- Loads the internal value XRSTOR_INFO for potential optimization of subsequent XSAVEOPT or XSAVES\n\nUse of a source operand not aligned to a 64-byte boundary results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n",
    "Alias": []
  },
  {
    "Name": "XSAVE",
    "Brief": "Save Processor Extended States",
    "Description": "\nPerforms a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\n\nThe format of the XSAVE area is detailed in the Intel 64 and IA-32 Architectures Software Developer's Manual. Key characteristics include:\n\n1. XSAVE saves state component i if and only if RFBM[i] = 1.\n2. It does not modify bytes 511:464 of the legacy region of the XSAVE area.\n3. It reads and writes the XSTATE_BV field of the XSAVE header based on the requested feature bitmap.\n4. An exception is made for MXCSR and MXCSR_MASK, which are saved if either RFBM[1] or RFBM[2] is 1.\n\nUse of a destination operand not aligned to a 64-byte boundary results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n",
    "Alias": []
  },
  {
    "Name": "XSAVEC",
    "Brief": "Save Processor Extended States With Compaction",
    "Description": "\nPerforms a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\n\nKey characteristics of XSAVEC include:\n\n1. Similar to XSAVE, but uses compaction and may use init optimization\n2. Saves state components only if they are in use and requested\n3. Does not modify bytes 511:464 of the legacy region of the XSAVE area\n4. Writes the logical AND of RFBM and XINUSE to the XSTATE_BV field\n5. Sets bit 63 of the XCOMP_BV field and sets bits 62:0 to RFBM[62:0]\n6. Always uses the compacted format of the extended region of the XSAVE area\n\nUse of a destination operand not aligned to a 64-byte boundary results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n",
    "Alias": []
  },
  {
    "Name": "XSAVEOPT",
    "Brief": "Save processor extended states with optimization",
    "Description": "\nPerforms a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\n\nKey characteristics of XSAVEOPT include:\n\n1. Similar to XSAVE, but with potential performance optimizations\n2. May use \"init\" and \"modified\" optimizations to improve performance\n3. Saves state components only if:\n   - The requested feature bitmap (RFBM) bit is set\n   - The component is currently in use (XINUSE)\n   - The component has been modified since the last XRSTOR\n\n4. Does not modify bytes 511:464 of the legacy region of the XSAVE area\n5. Reads and writes the XSTATE_BV field of the XSAVE header\n6. Always uses the standard format of the extended region of the XSAVE area\n\nAn exception is made for MXCSR and MXCSR_MASK, which are always saved if the corresponding feature bitmap bits are set, regardless of XINUSE.\n\nUse of a destination operand not aligned to a 64-byte boundary will result in a general-protection (#GP) exception.\n",
    "Alias": []
  },
  {
    "Name": "XSAVES",
    "Brief": "Save Processor Extended States Supervisor",
    "Description": "\nPerforms a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logical AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0.\n\nKey characteristics of XSAVES include:\n- Similar to XSAVEC, but can save state components corresponding to bits set in the IA32_XSS MSR\n- May use modified optimization\n- Saves state component i only if RFBM[i] = 1 and XINUSE[i] = 1\n- Does not modify bytes 511:464 of the legacy region of the XSAVE area\n- Always uses the compacted format of the extended region of the XSAVE area\n- Writes the logical AND of RFBM and XINUSE to the XSTATE_BV field of the XSAVE header\n- Sets bit 63 of the XCOMP_BV field and sets bits 62:0 of that field to RFBM[62:0]\n\nDestination operand must be aligned to a 64-byte boundary. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n",
    "Alias": []
  },
  {
    "Name": "XSETBV",
    "Brief": "Write the value in EDX:EAX to the XCR specified by ECX",
    "Description": "\nWrites the contents of registers EDX:EAX into the 64-bit extended control register (XCR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected XCR and the contents of the EAX register are copied to low-order 32 bits of the XCR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an XCR should be set to values previously read.\n\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented XCR in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to reserved bits in an XCR.\n\nCurrently, only XCR0 is supported. Thus, all other values of ECX are reserved and will cause a #GP(0). Note that bit 0 of XCR0 (corresponding to x87 state) must be set to 1; the instruction will cause a #GP(0) if an attempt is made to clear this bit. In addition, the instruction causes a #GP(0) if an attempt is made to set XCR0[2] (AVX state) while clearing XCR0[1] (SSE state); it is necessary to set both bits to use AVX instructions.\n",
    "Alias": []
  },
  {
    "Name": "XSUSLDTRK",
    "Brief": "Suspend tracking load addresses in Intel TSX (RTM) region",
    "Description": "\nThe instruction marks the start of an Intel TSX (RTM) suspend load address tracking region. If the instruction is used inside a transactional region, subsequent loads are not added to the read set of the transaction. If the instruction is used inside a suspend load address tracking region it will cause transaction abort.\n\nIf the instruction is used outside of a transactional region it behaves like a NOP.\n\nChapter 16, \"Programming with Intel® Transactional Synchronization Extensions‚\" in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1 provides additional information on Intel® TSX Suspend Load Address Tracking.\n\nThe instruction's behavior can be summarized as:\n- If in an active transactional region and suspend load tracking is not active, activate suspend load tracking\n- If in an active transactional region and suspend load tracking is already active, abort the transaction\n- If not in a transactional region, act as a no-operation (NOP)\n",
    "Alias": []
  },
  {
    "Name": "XTEST",
    "Brief": "Test if executing in a transactional region",
    "Description": "\nThe XTEST instruction queries the transactional execution status. If the instruction executes inside a transactionally executing RTM (Restricted Transactional Memory) region or a transactionally executing HLE (Hardware Lock Elision) region, then the ZF (Zero) flag is cleared, else it is set.\n\nWhen executed, the instruction checks if the processor is currently in a transactional execution state:\n- If a transactional region is active (RTM_ACTIVE = 1 or HLE_ACTIVE = 1), the Zero Flag (ZF) is cleared to 0\n- If no transactional region is active, the Zero Flag (ZF) is set to 1\n\nThe instruction affects only the Zero Flag (ZF), and clears the Carry Flag (CF), Overflow Flag (OF), Sign Flag (SF), Parity Flag (PF), and Auxiliary Carry Flag (AF).\n\nThis instruction requires support for either Hardware Lock Elision (HLE) or Restricted Transactional Memory (RTM) as indicated by specific CPUID feature flags.\n",
    "Alias": []
  },
  {
    "Name": "ENCLS",
    "Brief": "Execute a privileged Intel SGX leaf function for managing and debugging enclaves",
    "Description": "\nThe ENCLS instruction invokes the specified privileged Intel SGX leaf function for managing and debugging enclaves. Software specifies the leaf function by setting the appropriate value in the register EAX as input. The registers RBX, RCX, and RDX have leaf-specific purpose, and may act as input, as output, or may be unused. In 64-bit mode, the instruction ignores upper 32 bits of the RAX register.\n\nThe ENCLS instruction produces an invalid-opcode exception (#UD) if:\n- CR0.PE = 0\n- RFLAGS.VM = 1\n- Executed in system-management mode (SMM)\n- Executed with CPL > 0\n\nThe instruction produces a general-protection exception (#GP) if:\n- CR0.PG = 0\n- An attempt is made to invoke an undefined leaf function\n\nIn VMX non-root operation, execution of ENCLS may cause a VM exit if the \"enable ENCLS exiting\" VM-execution control is 1. Each bit in the ENCLS-exiting bitmap field corresponds to the index of an ENCLS leaf function.\n\nAddresses and operands are 32 bits outside 64-bit mode and 64 bits in 64-bit mode. The DS segment is used to create linear addresses. Segment override prefixes, address-size override prefixes, and REX prefix are ignored.\n",
    "Alias": []
  },
  {
    "Name": "EADD",
    "Brief": "Add a Page to an Uninitialized Enclave",
    "Description": "\nThis leaf function copies a source page from non-enclave memory into the Enclave Page Cache (EPC), associates the EPC page with an SECS page residing in the EPC, and stores the linear address and security attributes in EPCM. As part of the association, the enclave offset and the security attributes are measured and extended into the SECS.MRENCLAVE.\n\nThe instruction can only be executed when the current privilege level is 0. It takes three main parameters:\n1. RBX: Contains the effective address of a PAGEINFO structure\n2. RCX: Contains the effective address of an EPC page\n3. EAX: Set to 01H to indicate the EADD leaf function\n\nKey operations include:\n- Copying 4KB from the source page to the EPC page\n- Checking and validating security attributes\n- Ensuring the page is within the enclave's linear address space\n- Updating the enclave's measurement (MRENCLAVE)\n- Setting EPCM (Enclave Page Cache Management) entry fields\n\nThe instruction has multiple faulting conditions, including improper alignment, invalid security attributes, locked resources, and attempts to add pages to an already initialized enclave.\n",
    "Alias": []
  },
  {
    "Name": "EAUG",
    "Brief": "Add a Page to an Initialized Enclave",
    "Description": "\nThis leaf function zeroes a page of EPC (Enclave Page Cache) memory, associates the EPC page with an SECS (System Enclave Security) page residing in the EPC, and stores the linear address and security attributes in the EPCM (Enclave Page Cache Metadata).\n\nKey characteristics of the EAUG instruction include:\n- Can only be executed when current privilege level is 0\n- Zeroes the target page of EPC memory\n- Associates the page with an SECS page\n- Stores linear address and security attributes in EPCM\n- Prevents access to the EPC page until confirmed by EACCEPT or EACCEPTCOPY leaf functions\n\nThe instruction takes three key parameters:\n1. RBX: Effective address of a PAGEINFO structure\n2. RCX: Effective address of an EPC page\n3. EAX: Set to 0DH for EAUG leaf function\n\nThe instruction will fault under various conditions, such as:\n- Operands not properly aligned\n- Unsupported security attributes\n- Invalid or locked SECS\n- EPC page already valid\n- Enclave offset outside address space\n- SECS already initialized\n\nThis instruction is part of Intel Software Guard Extensions (SGX) and requires the SGX2 CPUID feature flag.\n",
    "Alias": []
  },
  {
    "Name": "EBLOCK",
    "Brief": "Mark a page in EPC as Blocked",
    "Description": "\nThis leaf function causes an EPC page to be marked as BLOCKED. This instruction can only be executed when current privilege level is 0.\n\nThe content of RCX is an effective address of an EPC page. The DS segment is used to create linear address. Segment override is not supported.\n\nAn error code is returned in RAX. The possible error codes include:\n- No Error: EBLOCK successful\n- SGX_BLKSTATE: Page already blocked\n- SGX_ENTRYEPOCH_LOCKED: SECS locked for Entry Epoch update\n- SGX_NOTBLOCKABLE: Page type is not blockable\n- SGX_PG_INVLD: Page is not valid and cannot be blocked\n- SGX_EPC_PAGE_CONFLICT: Page is being written by another operation\n\nThe instruction checks various conditions such as:\n- Page alignment\n- Page validity\n- Page type (only certain page types can be blocked)\n- Whether the page is already blocked\n\nIf all conditions are met, the page's BLOCKED status is set to 1.\n",
    "Alias": []
  },
  {
    "Name": "ECREATE",
    "Brief": "Create an SECS page in the Enclave Page Cache",
    "Description": "\nECREATE is the first instruction executed in the enclave build process. It copies an SECS (Secure Enclave Control Structure) structure outside the Enclave Page Cache (EPC) into an SECS page inside the EPC. The internal structure of SECS is not accessible to software.\n\nECREATE sets up fields in the protected SECS and marks the page as valid inside the EPC. It initializes or checks unused fields.\n\nSoftware must set the following fields in the source structure:\n- SECS:BASEADDR\n- SECS:SIZE (in bytes)\n- ATTRIBUTES\n- CONFIGID\n- CONFIGSVN\n\nRequirements:\n- SECS:BASEADDR must be naturally aligned on an SECS.SIZE boundary\n- SECS.SIZE must be at least 2 pages (8192 bytes)\n\nThe instruction uses three main parameters:\n1. RBX: Contains an effective address of a PAGEINFO structure\n2. RCX: Effective address of the destination SECS (an empty slot in the EPC)\n3. SECINFO flags must specify the page as an SECS page\n\nThe instruction performs various checks, including alignment, address validity, and attribute verification before creating the SECS page.\n",
    "Alias": []
  },
  {
    "Name": "EDBGRD",
    "Brief": "Read from a debug enclave",
    "Description": "\nThis leaf function copies a quadword/doubleword from an EPC page belonging to a debug enclave into the RBX register. Eight bytes are read in 64-bit mode, four bytes are read in non-64-bit modes. The size of data read cannot be overridden.\n\nThe effective address of the source location inside the EPC is provided in the register RCX.\n\nThe instruction has several key characteristics:\n1. It can only read from pages in a debug enclave\n2. The page must be in a readable state (not PENDING or MODIFIED)\n3. In 64-bit mode, the address must be 8-byte aligned\n4. In non-64-bit modes, the address must be 4-byte aligned\n\nError conditions include:\n- Attempting to read from a page that is not debuggable\n- Pointing to an invalid or non-EPC page\n- Accessing a page from a non-debug enclave\n- Attempting to read beyond the architectural size of a Thread Control Structure (TCS)\n\nThe instruction returns an error code in RAX and sets the Zero Flag (ZF) to indicate success or failure of the read operation.\n",
    "Alias": []
  },
  {
    "Name": "EDBGWR",
    "Brief": "Write to a Debug Enclave",
    "Description": "\nThis leaf function copies the content in EBX/RBX to an EPC page belonging to a debug enclave. Eight bytes are written in 64-bit mode, four bytes are written in non-64-bit modes. The size of data cannot be overridden.\n\nThe effective address of the target location inside the EPC is provided in the register RCX.\n\nThe instruction can fault under several conditions, including:\n- RCX points into a page that is an SECS\n- RCX does not resolve to a naturally aligned linear address\n- RCX points to a page that does not belong to an enclave that is in debug mode\n- RCX points to a location inside a TCS that is not the FLAGS word\n- Any segment violation occurs\n- Current Privilege Level (CPL) is not 0\n\nThere are two possible error codes:\n1. No Error: EDBGWR successful\n2. SGX_PAGE_NOT_DEBUGGABLE: The EPC page cannot be accessed because it is in the PENDING or MODIFIED state\n\nThis instruction ignores the EPCM RWX attributes on the enclave page, so violation of these attributes does not result in a #GP.\n",
    "Alias": []
  },
  {
    "Name": "EEXTEND",
    "Brief": "Extend Uninitialized Enclave Measurement by 256 Bytes",
    "Description": "\nThis leaf function updates the MRENCLAVE measurement register of an SECS with the measurement of an EXTEND string compromising of \"EEXTEND\" || ENCLAVEOFFSET || PADDING || 256 bytes of the enclave page. This instruction can only be executed when current privilege level is 0 and the enclave is uninitialized.\n\nRBX contains the effective address of the SECS of the region to be measured. The address must be the same as the one used to add the page into the enclave.\n\nRCX contains the effective address of the 256 byte region of an EPC page to be measured. The DS segment is used to create linear addresses. Segment override is not supported.\n\nThe instruction performs the following key operations:\n1. Validates input parameters and memory addresses\n2. Calculates the enclave offset\n3. Prepares an update field with \"EEXTEND\" string and enclave offset\n4. Updates the MRENCLAVE (measurement register) using SHA256 algorithm\n5. Incrementally updates the measurement by processing 256 bytes in 64-byte chunks\n\nThe instruction can only be executed in ring 0 (kernel mode) and only for an uninitialized enclave. It is part of Intel SGX (Software Guard Extensions) instruction set, used for secure enclave page measurement.\n",
    "Alias": []
  },
  {
    "Name": "EINIT",
    "Brief": "Initialize an Enclave for Execution",
    "Description": "\nThis leaf function is the final instruction executed in the enclave build process. After EINIT, the MRENCLAVE measurement is complete, and the enclave is ready to start user code execution using the EENTER instruction.\n\nEINIT takes the effective address of a SIGSTRUCT and EINITTOKEN. The SIGSTRUCT describes the enclave including MRENCLAVE, ATTRIBUTES, ISVSVN, a 3072 bit RSA key, and a signature using the included key. \n\nThe EINITTOKEN contains the MRENCLAVE, MRSIGNER, and ATTRIBUTES. These values must match the corresponding values in the SECS. If the EINITTOKEN was created with a debug launch key, the enclave must be in debug mode as well.\n\nThe instruction performs several key validation steps:\n1. Validates that SIGSTRUCT is signed using the enclosed public key\n2. Checks that the completed computation of SECS.MRENCLAVE equals SIGSTRUCT.HASHENCLAVE\n3. Verifies no unauthorized ATTRIBUTES bits are set\n4. Checks the EINITTOKEN's validity and matching measurements\n5. Commits the SECS.MRENCLAVE and sets other SECS metadata\n6. Updates the SECS as Initialized\n\nIf any validation fails, the instruction sets an error code in RAX and sets the Zero Flag (ZF).\n",
    "Alias": []
  },
  {
    "Name": "ELDB",
    "Brief": "Load an EPC page and mark it as blocked",
    "Description": "\nThese leaf functions copy a page from regular main memory to the Enclave Page Cache (EPC). As part of the copying process, the page is cryptographically authenticated and decrypted. These instructions can only be executed when the current privilege level is 0.\n\nThe ELDB leaf function sets the BLOCK bit in the EPCM entry for the destination page in the EPC after copying. The ELDU leaf function clears the BLOCK bit in the EPCM entry for the destination page in the EPC after copying.\n\nRBX contains the effective address of a PAGEINFO structure; RCX contains the effective address of the destination EPC page; RDX holds the effective address of the version array slot that holds the version of the page.\n\nThe ELDBC/ELDUC leafs are very similar to ELDB and ELDU. They provide an error code on the concurrency conflict for any of the pages which need to acquire a lock. These include the destination, SECS, and VA slot.\n\nThe page is loaded, verified, and its state is modified according to the specific instruction (blocked or unblocked). The instructions include mechanisms for handling page conflicts and ensuring the integrity of the enclave page cache.\n",
    "Alias": []
  },
  {
    "Name": "ELDU",
    "Brief": "Load an EPC page and mark it as unblocked",
    "Description": "\nThese leaf functions copy a page from regular main memory to the Enclave Page Cache (EPC). As part of the copying process, the page is cryptographically authenticated and decrypted. These instructions can only be executed when the current privilege level is 0.\n\nThe ELDB leaf function sets the BLOCK bit in the EPCM entry for the destination page in the EPC after copying. The ELDU leaf function clears the BLOCK bit in the EPCM entry for the destination page in the EPC after copying.\n\nRBX contains the effective address of a PAGEINFO structure; RCX contains the effective address of the destination EPC page; RDX holds the effective address of the version array slot that holds the version of the page.\n\nThe ELDBC/ELDUC leafs are very similar to ELDB and ELDU. They provide an error code on the concurrency conflict for any of the pages which need to acquire a lock. These include the destination, SECS, and VA slot.\n\nThe page is loaded, verified, and its state is modified according to the specific instruction (blocked or unblocked). The instructions include mechanisms for handling page conflicts and ensuring the integrity of the enclave page cache.\n",
    "Alias": []
  },
  {
    "Name": "ELDBC",
    "Brief": "Load an EPC page and mark it as blocked with improved conflict handling",
    "Description": "\nThese leaf functions copy a page from regular main memory to the Enclave Page Cache (EPC). As part of the copying process, the page is cryptographically authenticated and decrypted. These instructions can only be executed when the current privilege level is 0.\n\nThe ELDB leaf function sets the BLOCK bit in the EPCM entry for the destination page in the EPC after copying. The ELDU leaf function clears the BLOCK bit in the EPCM entry for the destination page in the EPC after copying.\n\nRBX contains the effective address of a PAGEINFO structure; RCX contains the effective address of the destination EPC page; RDX holds the effective address of the version array slot that holds the version of the page.\n\nThe ELDBC/ELDUC leafs are very similar to ELDB and ELDU. They provide an error code on the concurrency conflict for any of the pages which need to acquire a lock. These include the destination, SECS, and VA slot.\n\nThe page is loaded, verified, and its state is modified according to the specific instruction (blocked or unblocked). The instructions include mechanisms for handling page conflicts and ensuring the integrity of the enclave page cache.\n",
    "Alias": []
  },
  {
    "Name": "ELDUC",
    "Brief": "Load an EPC page and mark it as unblocked with improved conflict handling",
    "Description": "\nThese leaf functions copy a page from regular main memory to the Enclave Page Cache (EPC). As part of the copying process, the page is cryptographically authenticated and decrypted. These instructions can only be executed when the current privilege level is 0.\n\nThe ELDB leaf function sets the BLOCK bit in the EPCM entry for the destination page in the EPC after copying. The ELDU leaf function clears the BLOCK bit in the EPCM entry for the destination page in the EPC after copying.\n\nRBX contains the effective address of a PAGEINFO structure; RCX contains the effective address of the destination EPC page; RDX holds the effective address of the version array slot that holds the version of the page.\n\nThe ELDBC/ELDUC leafs are very similar to ELDB and ELDU. They provide an error code on the concurrency conflict for any of the pages which need to acquire a lock. These include the destination, SECS, and VA slot.\n\nThe page is loaded, verified, and its state is modified according to the specific instruction (blocked or unblocked). The instructions include mechanisms for handling page conflicts and ensuring the integrity of the enclave page cache.\n",
    "Alias": []
  },
  {
    "Name": "EMODPR",
    "Brief": "Restrict the Permissions of an EPC Page",
    "Description": "\nThis leaf function restricts the access rights associated with an EPC page in an initialized enclave. The RWX bits of the SECINFO parameter are treated as a permissions mask; supplying a value that does not restrict the page permissions will have no effect. This instruction can only be executed when current privilege level is 0.\n\nRBX contains the effective address of a SECINFO structure while RCX contains the effective address of an EPC page.\n\nThe instruction faults under several conditions, including:\n- Operands are not properly aligned\n- Unsupported security attributes are set\n- Enclave is not initialized\n- SECS is locked by another thread\n- EPC page is locked by another thread\n- RCX does not contain an effective address of an EPC page in the running enclave\n- The EPC page is not valid\n\nThe function can return two specific error codes:\n1. SGX_PAGE_NOT_MODIFIABLE: The EPC page cannot be modified because it is in the PENDING or MODIFIED state\n2. SGX_EPC_PAGE_CONFLICT: Page is being written by another SGX instruction (EADD, EAUG, ECREATE, ELDU/B, EMODT, or EWB)\n\nThe operation involves checking various conditions, updating the EPCM (Enclave Page Cache Management) permissions by performing a bitwise AND on the read, write, and execute flags, and setting a permission restriction (PR) bit.\n",
    "Alias": []
  },
  {
    "Name": "EMODT",
    "Brief": "Change the type of an existing EPC page",
    "Description": "\nThis leaf function modifies the type of an EPC page. The security attributes are configured to prevent access to the EPC page at its new type until a corresponding invocation of the EACCEPT leaf confirms the modification. This instruction can only be executed when current privilege level is 0.\n\nRBX contains the effective address of a SECINFO structure while RCX contains the effective address of an EPC page. \n\nThe instruction faults under several conditions, including:\n- Operands are not properly aligned\n- Unsupported security attributes are set\n- The Enclave is not initialized\n- SECS is locked by another thread\n- The EPC page is locked by another thread\n- RCX does not contain an effective address of an EPC page in the running enclave\n- The EPC page is not valid\n\nPossible error codes include:\n- No Error: EMODT successful\n- SGX_PAGE_NOT_MODIFIABLE: The EPC page cannot be modified because it is in the PENDING or MODIFIED state\n- SGX_EPC_PAGE_CONFLICT: Page is being written by another SGX instruction\n\nThe instruction has specific concurrency restrictions and can only be executed with exclusive access to the target EPC page.\n",
    "Alias": []
  },
  {
    "Name": "EPA",
    "Brief": "Add Version Array to the EPC (Enclave Page Cache)",
    "Description": "\nThis leaf function creates an empty version array in the EPC (Enclave Page Cache) page whose logical address is given by DS:RCX, and sets up EPCM (Enclave Page Cache Manager) attributes for that page.\n\nKey requirements and actions:\n1. At the time of execution, the register RBX must be set to PT_VA (Page Type Version Array).\n2. The memory page must be 4KByte aligned and within the EPC.\n3. The EPC page must be empty (not already valid).\n\nThe instruction performs the following operations:\n- Clears the entire 32KB EPC page\n- Sets the page type to PT_VA\n- Initializes EPCM attributes:\n  - Enclave Address = 0\n  - Blocked = 0\n  - Pending = 0\n  - Modified = 0\n  - Page Rights = 0\n  - Read/Write/Execute = 0\n  - Sets the page as VALID\n\nThis is part of the Intel Software Guard Extensions (SGX) instruction set, used for secure enclave management.\n",
    "Alias": []
  },
  {
    "Name": "ERDINFO",
    "Brief": "Read type and status information about an EPC page",
    "Description": "\nThis instruction reads type and status information about an EPC page and returns it in a RDINFO structure. The STATUS field of the structure describes the status of the page and determines the validity of the remaining fields. The FLAGS field returns the EPCM permissions of the page; the page type; and the BLOCKED, PENDING, MODIFIED, and PR status of the page.\n\nFor enclave pages, the ENCLAVECONTEXT field of the structure returns the value of SECS.ENCLAVECONTEXT. For non-enclave pages (e.g., VA), ENCLAVECONTEXT returns 0.\n\nFor invalid or non-EPC pages, the instruction returns an information code indicating the page's status, in addition to populating the STATUS field.\n\nERDINFO returns an error code if the destination EPC page is being modified by a concurrent SGX instruction.\n\nThe instruction uses RBX to contain the effective address of a RDINFO structure and RCX to contain the effective address of an EPC page. It can fault under various conditions such as misalignment, non-canonical addresses, or page faults.\n\nPossible error codes include:\n- No Error (0): ERDINFO successful\n- SGX_EPC_PAGE_CONFLICT: Failure due to concurrent operation of another SGX instruction\n- SGX_PG_INVLD: Target page is not a valid EPC page\n- SGX_PG_NONEPC: Page is not an EPC page\n",
    "Alias": []
  },
  {
    "Name": "EREMOVE",
    "Brief": "Remove a page from the Enclave Page Cache (EPC)",
    "Description": "\nThis leaf function causes an EPC page to be un-associated with its SECS (System Enclave Control Structure) and be marked as unused. This instruction can only be executed when the current privilege level is 0.\n\nThe content of RCX is an effective address of an EPC page. The DS segment is used to create linear address, and segment override is not supported.\n\nThe instruction fails if:\n- The operand is not properly aligned\n- The operand does not refer to an EPC page\n- The page is in use by another thread\n- Other threads are running in the enclave to which the page belongs\n- The operand refers to an SECS with associations\n\nThe instruction can return different error codes:\n- No Error: EREMOVE successful\n- SGX_CHILD_PRESENT: If the SECS still has enclave pages loaded into EPC\n- SGX_ENCLAVE_ACT: If there are still logical processors executing inside the enclave\n\nThe instruction is part of the Intel Software Guard Extensions (SGX) and is used for managing the Enclave Page Cache.\n",
    "Alias": []
  },
  {
    "Name": "ETRACKC",
    "Brief": "Activates EBLOCK Checks",
    "Description": "\nThe ETRACKC instruction is a thread-safe variant of the ETRACK leaf and can be executed concurrently with other CPU threads operating on the same SECS (Secure Enclave Control Structure).\n\nThis leaf function provides the mechanism for hardware to track that software has completed the required TLB address clears successfully. The instruction can only be executed when the current privilege level is 0.\n\nThe content of RCX is an effective address of an EPC (Enclave Page Cache) page. The instruction checks various conditions such as:\n- Proper alignment of the EPC page\n- Validity of the EPC page\n- Concurrency with other SGX (Software Guard Extensions) instructions\n- Completion of previous tracking sequences\n\nThe instruction returns different error codes depending on the outcome:\n- 0: ETRACKC successful\n- 7: Failure due to concurrent operation of another SGX instruction\n- 6: Target page is not a valid EPC page\n- 17: All processors did not complete the previous tracking sequence\n- 27: Target page type does not require tracking\n\nThe instruction affects the zero flag (ZF) and carry flag (CF) to indicate the result of the operation.\n",
    "Alias": []
  },
  {
    "Name": "ETRACK",
    "Brief": "Activates EBLOCK Checks",
    "Description": "\nThis leaf function provides the mechanism for hardware to track that software has completed the required TLB address clears successfully. The instruction can only be executed when the current privilege level is 0.\n\nThe content of RCX is an effective address of an EPC page. \n\nThe function has two possible return values:\n1. No Error: ETRACK successful\n2. SGX_PREV_TRK_INCMPL: All processors did not complete the previous shoot-down sequence\n\nKey characteristics:\n- Requires privilege level 0\n- Used in Intel SGX (Software Guard Extensions)\n- Checks TLB address clearing across processors\n- Can only be used with EPC (Enclave Page Cache) pages\n- Provides hardware tracking mechanism for enclave operations\n\nConcurrency restrictions include:\n- Exclusive access to SECS (Secure Enclave Control Structure) when performing ETRACK\n- Checks for conflicts with other SGX instructions\n- Ensures all processors have completed previous tracking cycles\n",
    "Alias": []
  },
  {
    "Name": "EWB",
    "Brief": "Invalidate an EPC page and write out to main memory",
    "Description": "\nThis leaf function copies a page from the EPC (Enclave Page Cache) to regular main memory. As part of the copying process, the page is cryptographically protected. This instruction can only be executed when the current privilege level is 0.\n\nThe instruction performs several key operations:\n1. Checks the validity and alignment of memory parameters\n2. Verifies the EPC page and version array page conditions\n3. Performs page-type-specific checks\n4. Encrypts the page using AES-GCM\n5. Writes the encrypted page and metadata to main memory\n6. Updates the version array slot\n7. Invalidates the EPCM (EPC Map) entry for the source page\n\nThe instruction supports different page types, including regular pages, TCS pages, SECS pages, and version array pages. It includes multiple error checks and handles various edge cases, such as:\n- Checking if the page is blocked\n- Verifying tracking correctness\n- Ensuring no child pages are present\n- Handling version array slot occupancy\n\nThe instruction is part of the Intel SGX (Software Guard Extensions) instruction set and is designed to manage secure enclave memory with strong cryptographic protections.\n",
    "Alias": []
  },
  {
    "Name": "ENCLU",
    "Brief": "Execute a non-privileged Intel SGX leaf function",
    "Description": "\nThe ENCLU instruction invokes specified non-privileged Intel SGX leaf functions. Software specifies the leaf function by setting the appropriate value in the EAX register. The registers RBX, RCX, and RDX have leaf-specific purposes and may act as input, output, or remain unused.\n\nKey characteristics of the ENCLU instruction include:\n\n1. It can only be executed at privilege level 3 (user mode)\n2. It produces an invalid-opcode exception (#UD) if:\n   - CR0.PE = 0\n   - RFLAGS.VM = 1\n   - Executed in system-management mode (SMM)\n   - Executed with CPL < 3\n\n3. It produces a general-protection exception (#GP) if:\n   - CR0.PG = 0\n   - CR0.NE = 0\n   - An undefined leaf function is invoked\n\n4. It produces a device not available exception (#NM) if CR0.TS = 1\n\n5. Segment override prefixes, address-size override prefixes, and REX prefix are ignored\n\nThe instruction is part of Intel Software Guard Extensions (SGX) and is used to execute specific user-mode enclave operations.\n",
    "Alias": []
  },
  {
    "Name": "EACCEPTCOPY",
    "Brief": "Initialize a dynamically allocated EPC page from another page in the EPC",
    "Description": "\nThis leaf function copies the contents of an existing EPC page into an uninitialized EPC page (created by EAUG). After initialization, the instruction may also modify the access rights associated with the destination EPC page. This instruction leaf can only be executed when inside the enclave.\n\nRBX contains the effective address of a SECINFO structure while RCX and RDX each contain the effective address of an EPC page. \n\nThe instruction has specific memory parameter semantics:\n- SECINFO: Read access permitted by Non Enclave\n- Destination EPCPAGE: Read/Write access permitted by Enclave\n- Source EPCPAGE: Read access permitted by Enclave\n\nThe instruction will fault under several conditions, such as:\n- Operands are not properly aligned\n- EPC page is locked by another thread\n- Invalid security attributes\n- Operands are not within the running enclave\n\nIf successful, the instruction copies the 4KB contents from the source EPC page to the destination EPC page and updates the EPCM (Enclave Page Cache Management) permissions based on the SECINFO structure.\n\nThis is part of Intel SGX (Software Guard Extensions) technology, specifically using the SGX2 feature, which provides advanced page management capabilities for secure enclaves.\n",
    "Alias": []
  },
  {
    "Name": "EACCEPT",
    "Brief": "Accept Changes to an EPC Page",
    "Description": "\nThis leaf function accepts changes to a page in the running enclave by verifying that the security attributes specified in the SECINFO match the security attributes of the page in the EPCM. This instruction leaf can only be executed when inside the enclave.\n\nRBX contains the effective address of a SECINFO structure while RCX contains the effective address of an EPC page. \n\nThe instruction performs several checks:\n1. Validates the SECINFO and destination EPC page addresses\n2. Checks for proper alignment and access permissions\n3. Verifies the page type, pending, and modified flags\n4. Ensures that all required threads have left the enclave\n\nIf all checks pass, it clears the PENDING and MODIFIED flags of the EPC page, marking the accept operation complete. If any check fails, it sets appropriate error codes and flags.\n\nThe instruction is part of Intel Software Guard Extensions (SGX) and is used to manage the lifecycle and security of enclave pages during runtime.\n",
    "Alias": []
  },
  {
    "Name": "EDECCSSA",
    "Brief": "Decrements TCS.CSSA for the current enclave thread",
    "Description": "\nThis leaf function changes the current SSA (State Save Area) frame by decrementing TCS.CSSA (Current State Save Area index) for the current enclave thread. If the enclave has enabled CET (Control Flow Enforcement Technology) shadow stacks or indirect branch tracking, then EDECCSSA also changes the current CET state save frame.\n\nKey characteristics of the instruction include:\n\n1. It can only be executed inside an enclave.\n2. The instruction faults if:\n   - TCS.CSSA is 0\n   - TCS is not valid, available, or locked\n   - The SSA frame is not valid or in use\n\nThe instruction performs several checks before decrementing the CSSA:\n- Validates the SSA frame pages\n- Checks page accessibility and EPC (Enclave Page Cache) metadata\n- Handles CET-related state save area if CET is enabled for the enclave\n\nAfter successful validation, it decrements the CSSA and updates the corresponding physical addresses for the GPR (General Purpose Registers) and XSAVE areas.\n",
    "Alias": []
  },
  {
    "Name": "EENTER",
    "Brief": "Enters an Enclave",
    "Description": "\nThe ENCLU[EENTER] instruction transfers execution to an enclave. At the end of the instruction, the logical processor is executing in enclave mode at the RIP computed as EnclaveBase + TCS.OENTRY. If the target address is not within the CS segment (32-bit) or is not canonical (64-bit), a #GP(0) results.\n\nKey operations performed by EENTER include:\n1. Saving RSP and RBP in the current SSA frame\n2. Storing the AEP (Asynchronous Exit Pointer) in the TCS\n3. Saving and constructing new FS and GS segments using TCS base and limit values\n4. If CR4.OSXSAVE is set, saving XCR0 and replacing it with SECS.ATTRIBUTES.XFRM\n5. Handling debug flags and performance monitoring counters\n6. Setting up CET (Control Flow Enforcement Technology) state if supported\n\nThe instruction performs extensive validation checks before entering the enclave, including:\n- Checking memory alignment and accessibility\n- Verifying TCS (Thread Control Structure) and SECS (Secure Enclave Structure) attributes\n- Ensuring proper enclave initialization and mode compatibility\n- Validating segment and address constraints\n\nIf any validation fails, the instruction generates a general protection (#GP) or page fault (#PF) exception.\n",
    "Alias": []
  },
  {
    "Name": "EEXIT",
    "Brief": "Exits an Enclave",
    "Description": "\nThe ENCLU[EEXIT] instruction exits the currently executing enclave and branches to the location specified in RBX. RCX receives the current AEP (Asynchronous Exit Pointer). If RBX is not within the CS (32-bit mode) or is not canonical (64-bit mode), a #GP(0) results.\n\nKey behaviors during enclave exit include:\n- If RBX specifies an address inside the enclave, the next instruction fetch will occur in non-enclave mode but will return a fixed data pattern.\n- Secrets in registers must be cleared by enclave software.\n- XCR0 is restored to its value at the most recent EENTER or ERESUME.\n- For opt-out enclaves, RFLAGS.TF is loaded from the value saved on EENTER.\n- Code and data breakpoints are unsuppressed.\n- Performance monitoring counters are unsuppressed.\n\nThe instruction sets CR_ENCLAVE_MODE to 0 and marks the Thread Control Structure (TCS) state as INACTIVE. It also performs a linear context flush to ensure consistent translations.\n",
    "Alias": []
  },
  {
    "Name": "EGETKEY",
    "Brief": "Retrieves a cryptographic key from the processor specific key hierarchy",
    "Description": "\nThe ENCLU[EGETKEY] instruction returns a 128-bit secret key from the processor specific key hierarchy. The register RBX contains the effective address of a KEYREQUEST structure, which the instruction interprets to determine the key being requested. The RCX register contains the effective address where the key will be returned. Both the addresses in RBX & RCX should be locations inside the enclave.\n\nEGETKEY derives keys using a processor unique value to create a specific key based on a number of possible inputs. This instruction leaf can only be executed inside an enclave.\n\nThe key derivation process involves:\n1. Assembling derivation data based on various enclave and system parameters\n2. Computing a derived key using the derivation data and package specific value\n3. Outputting the calculated key to the specified address\n\nDifferent types of keys can be requested, including:\n- Seal Key\n- Report Key\n- EINITTOKEN Key\n- Provision Key\n- Provision Seal Key\n\nThe instruction includes various checks to ensure:\n- The key request is valid\n- The enclave has appropriate attributes\n- The requested SVN (Software Version Number) is not beyond the current configuration\n- The key name is supported\n\nIf any validation fails, the instruction sets the zero flag (ZF) and returns an error code indicating the specific issue.\n",
    "Alias": []
  },
  {
    "Name": "EMODPE",
    "Brief": "Extend an EPC Page Permissions",
    "Description": "\nThis leaf function extends the access rights associated with an existing EPC page in the running enclave. The RWX bits of the SECINFO parameter are treated as a permissions mask; supplying a value that does not extend the page permissions will have no effect. This instruction leaf can only be executed when inside the enclave.\n\nRBX contains the effective address of a SECINFO structure while RCX contains the effective address of an EPC page. The function provides additional semantics for SECINFO and EPCPAGE, allowing read access to the EPC page by the enclave.\n\nThe instruction has several faulting conditions, including:\n- Improperly aligned operands\n- Inaccessible SECINFO page\n- EPC page locked by another thread\n- Invalid EPC page\n- Invalid request in SECINFO\n\nThe instruction updates the EPCM (Enclave Page Cache Management) permissions by performing a bitwise OR operation on the existing R, W, and X flags with the flags from the SECINFO structure. This allows extending the page permissions within the enclave.\n",
    "Alias": []
  },
  {
    "Name": "EREPORT",
    "Brief": "Create a cryptographic report of the enclave",
    "Description": "\nThis leaf function creates a cryptographic REPORT that describes the contents of the enclave. This instruction leaf can only be executed when inside the enclave. The cryptographic report can be used by other enclaves to determine that the enclave is running on the same platform.\n\nRBX contains the effective address of the MRENCLAVE value of the enclave that will authenticate the REPORT output, using the REPORT key delivered by EGETKEY command for that enclave. RCX contains the effective address of a 64-byte REPORTDATA structure, which allows the caller of the instruction to associate data with the enclave from which the instruction is called. RDX contains the address where the REPORT will be output by the instruction.\n\nThe instruction performs the following steps:\n1. Validate the 3 operands (RBX, RCX, RDX) are inside the enclave.\n2. Compute a report key for the target enclave, as indicated by the value located in RBX(TARGETINFO).\n3. Assemble the enclave SECS data to complete the REPORT structure (including the data provided using the RCX (REPORTDATA) operand).\n4. Computes a cryptographic hash over REPORT structure.\n5. Add the computed hash to the REPORT structure.\n6. Output the completed REPORT structure to the address in RDX (OUTPUTDATA).\n\nThe instruction fails if the operands are not properly aligned. CR_REPORT_KEYID, used to provide key wearout protection, is populated with a statistically unique value on boot of the platform by a trusted entity within the SGX TCB.\n",
    "Alias": []
  },
  {
    "Name": "ERESUME",
    "Brief": "Re-enters an enclave after an interrupt",
    "Description": "\nThe ENCLU[ERESUME] instruction resumes execution of an enclave that was interrupted due to an exception or interrupt, using the machine state previously stored in the SSA (Save State Area).\n\nKey operations include:\n- Restoring the processor state from the SSA frame\n- Saving and restoring segment registers (FS and GS)\n- Handling debug state based on enclave configuration\n- Managing Control Flow Enforcement Technology (CET) state\n- Setting up the execution environment for the enclave\n\nThe instruction performs extensive validation checks before resuming enclave execution, including:\n- Verifying the Thread Control Structure (TCS)\n- Checking enclave initialization and state\n- Validating memory access and segment configurations\n- Ensuring compatibility with processor features and enclave attributes\n\nThe instruction is part of the Intel Software Guard Extensions (SGX) and is used to safely resume an interrupted enclave execution context.\n",
    "Alias": []
  },
  {
    "Name": "ENCLV",
    "Brief": "Execute a privileged SGX leaf function for managing enclaves in a virtualized environment",
    "Description": "\nThe ENCLV instruction invokes the virtualization SGX leaf functions for managing enclaves in a virtualized environment. Software specifies the leaf function by setting the appropriate value in the register EAX as input. The registers RBX, RCX, and RDX have leaf-specific purpose, and may act as input, as output, or may be unused.\n\nThe ENCLV instruction produces an invalid-opcode exception (#UD) if:\n- CR0.PE = 0 or RFLAGS.VM = 1\n- Executed in system-management mode (SMM)\n- Not in VMX operation\n- Executed with CPL > 0\n\nIt produces a general-protection exception (#GP) if:\n- CR0.PG = 0\n- An attempt is made to invoke an undefined leaf function\n\nIn VMX root mode, the execution of the ENCLV instruction in VMX non-root mode can be enabled by setting the enable ENCLV execution control in the VMCS. If this control is not set, executing ENCLV in VMX non-root mode results in #UD.\n\nWhen execution of ENCLV is enabled in VMX non-root mode, software in VMX root operation can intercept the invocation of various ENCLV leaf functions by setting corresponding bits in the ENCLV-exiting bitmap.\n\nAddresses and operands are 32 bits in 32-bit mode and 64 bits in 64-bit mode. Segment override prefixes, address-size override prefixes, and the REX prefix are ignored.\n",
    "Alias": []
  },
  {
    "Name": "EDECVIRTCHILD",
    "Brief": "Decrement VIRTCHILDCNT in SECS",
    "Description": "\nThis instruction decrements the SECS VIRTCHILDCNT field. It can only be executed when the current privilege level is 0.\n\nThe content of RCX is an effective address of an EPC page. The DS segment is used to create a linear address, and segment override is not supported.\n\nThe instruction has several key characteristics and checks:\n1. It verifies the alignment and validity of the memory operands\n2. Checks that the page types are correct (REG, TCS, TRIM, SECS, etc.)\n3. Ensures the page is associated with the correct SECS\n4. Performs an atomic decrement of the VIRTCHILDCNT field\n5. Checks for potential underflow during decrement\n\nThe instruction can return different error codes:\n- 0: Successful operation\n- SGX_EPC_PAGE_CONFLICT: Failure due to concurrent operation\n- SGX_INVALID_COUNTER: Attempt to decrement counter that is already zero\n\nThe instruction affects the Zero Flag (ZF), which is set if the operation fails due to a concurrent operation or counter underflow.\n",
    "Alias": []
  },
  {
    "Name": "EINCVIRTCHILD",
    "Brief": "Increment VIRTCHILDCNT in SECS",
    "Description": "\nThis instruction increments the SECS VIRTCHILDCNT field. It can only be executed when the current privilege level is 0.\n\nThe content of RCX is an effective address of an EPC page, and the DS segment is used to create a linear address. Segment override is not supported.\n\nKey points about the instruction:\n1. It requires the current privilege level to be 0.\n2. Uses RCX to specify the address of an SECS page.\n3. Uses RBX to specify the address of an enclave page.\n4. Can fault under various conditions, such as:\n   - Memory operand address is outside segment limit\n   - Page fault occurs\n   - RBX does not refer to a valid enclave page\n   - RCX does not refer to an SECS page\n   - Misaligned memory addresses\n\nThe instruction performs an atomic increment of the VIRTCHILDCNT field in the specified SECS, with specific concurrency and error handling mechanisms.\n",
    "Alias": []
  },
  {
    "Name": "ESETCONTEXT",
    "Brief": "Set the ENCLAVECONTEXT field in SECS",
    "Description": "\nThe ESETCONTEXT leaf overwrites the ENCLAVECONTEXT field in the SECS (Secure Enclave Control Structure). ECREATE and ELD of an SECS initially set the ENCLAVECONTEXT field in the SECS to the address of the SECS (for access later in ERDINFO). \n\nThe ESETCONTEXT instruction allows a Virtual Machine Monitor (VMM) to overwrite the default context value if necessary, such as when the VMM is emulating ECREATE or ELD on behalf of a guest.\n\nThe instruction takes two key parameters:\n1. RCX: Contains the effective address of the SECS page to be updated\n2. RDX: Contains the address pointing to the value to be stored in the SECS\n\nThe instruction fails under the following conditions:\n- The operand is not properly aligned\n- RCX does not refer to an SECS page\n\nThe DS segment is used to create the linear address, and segment override is not supported. The instruction provides a way for a VMM to modify the enclave context in a controlled manner.\n",
    "Alias": []
  },
  {
    "Name": "GETSEC[CAPABILITIES]",
    "Brief": "Report the SMX capabilities",
    "Description": "\nThe GETSEC[CAPABILITIES] function returns a bit vector of supported GETSEC leaf functions. The CAPABILITIES leaf of GETSEC is selected with EAX set to 0 at entry. EBX is used as the selector for returning the bit vector field in EAX. GETSEC[CAPABILITIES] may be executed at all privilege levels, but the CR4.SMXE bit must be set or an undefined opcode exception (#UD) is returned.\n\nWith EBX = 0 upon execution of GETSEC[CAPABILITIES], EAX returns a bit vector representing status on the presence of an Intel® TXT-capable chipset and the first 30 available GETSEC leaf functions.\n\nIf bit 0 is set to 1, then an Intel® TXT-capable chipset has been sampled present by the processor. If bits in the range of 1-30 are set, then the corresponding GETSEC leaf function is available. If the bit value at a given bit index is 0, then the GETSEC leaf function corresponding to that index is unsupported and attempted execution results in a #UD.\n\nBit 31 of EAX indicates if further leaf indexes are supported. If the Extended Leafs bit 31 is set, then additional leaf functions are accessed by repeating GETSEC[CAPABILITIES] with EBX incremented by one. When the most significant bit of EAX is not set, then additional GETSEC leaf functions are not supported.\n",
    "Alias": []
  },
  {
    "Name": "GETSEC[ENTERACCS]",
    "Brief": "Execute Authenticated Chipset Code",
    "Description": "\nThe GETSEC[ENTERACCS] function loads, authenticates, and executes an authenticated code module using an Intel® TXT platform chipset's public key. The ENTERACCS leaf of GETSEC is selected with EAX set to 2 at entry.\n\nKey characteristics and restrictions include:\n- Execution is only allowed in protected or IA-32e mode with CPL = 0\n- Processor cache must be available\n- Requires an Intel TXT-capable chipset\n- Cannot already be in authenticated code execution mode\n- Cannot be in SMM or VMX operation\n- Must be executed by the boot-strap processor (BSP)\n\nThe function performs several critical steps:\n- Checks and validates the authenticated code module\n- Masks external events like INIT, A20M, NMI, and SMI\n- Broadcasts protection messages for memory and I/O\n- Loads and authenticates the code module\n- Initializes processor state based on the module header\n- Unlocks Intel TXT chipset private configuration space\n- Begins execution at the defined module entry point\n\nUpon successful completion, the processor enters authenticated code execution mode with a specific, controlled processor state, including:\n- Paging disabled\n- Specific register initializations\n- Cleared debug and performance counter states\n- Preserved critical platform settings\n\nThe authenticated code module can subsequently enable interrupts and establish its own interrupt handling infrastructure.\n",
    "Alias": []
  },
  {
    "Name": "GETSEC[EXITAC]",
    "Brief": "Exit authenticated code execution mode",
    "Description": "\nThe GETSEC[EXITAC] leaf function exits the processor out of authenticated code execution mode established by GETSEC[ENTERACCS] or GETSEC[SENTER]. \n\nKey details:\n- EBX (or RBX in 64-bit mode) holds the near jump target offset for processor execution resumption\n- EDX contains additional parameter control information (currently only 0 is supported)\n- Can only be executed in protected mode with CPL = 0, EFLAGS.VM = 0, and in authenticated code execution mode\n- Cannot be executed in SMM or VMX operation\n\nUpon completion, the processor performs several steps:\n- Invalidate the internal authenticated code execution area\n- Invalidate processor TLBs\n- Clear the internal processor AC Mode indicator flag\n- Re-lock the TPM locality 3 space\n- Unlock Intel TXT-capable chipset memory and I/O protections\n- Perform a near absolute indirect jump to the designated instruction location\n\nThe instruction also conditionally unmasks external event signals like INIT#, NMI#, and SMI#, depending on how the authenticated code execution mode was entered.\n\nCaution must be taken to re-establish any data structures and segmentation/paging structures outside of the authenticated RAM area before executing EXITAC.\n",
    "Alias": []
  },
  {
    "Name": "GETSEC[PARAMETERS]",
    "Brief": "Report the SMX parameters",
    "Description": "\nThe GETSEC[PARAMETERS] instruction returns specific parameter information for SMX (Safer Mode Extensions) features supported by the processor. Parameter information is returned in EAX, EBX, and ECX, with the input parameter selected using EBX.\n\nSoftware retrieves parameter information by searching with an input index for EBX starting at 0, and then reading the returned results in EAX, EBX, and ECX. EAX[4:0] is designated to return a parameter type field indicating if a parameter is available and what type it is. If EAX[4:0] is returned with 0, this designates a null parameter and indicates no more parameters are available.\n\nThe instruction can report various parameters, including:\n1. Supported AC (Authenticated Code) module versions\n2. Maximum size of authenticated code execution area\n3. External memory types supported during AC mode\n4. Selective SENTER functionality control\n5. TXT (Trusted Execution Technology) extensions support\n\nIf the GETSEC[PARAMETERS] leaf or specific parameter is not present for a given SMX capable processor, default parameter values should be assumed.\n\nThe instruction can only be executed when CR4.SMXE is set, and it will generate an Undefined Opcode (#UD) exception if this condition is not met or if the processor does not support the GETSEC[PARAMETERS] function.\n",
    "Alias": []
  },
  {
    "Name": "GETSEC[SENTER]",
    "Brief": "Launch a measured environment and enter authenticated code execution mode",
    "Description": "\nThe GETSEC[SENTER] instruction initiates the launch of a measured environment and places the initiating logical processor (ILP) into the authenticated code execution mode. The instruction is used to start a secure environment with specific hardware-based security features.\n\nKey aspects of the GETSEC[SENTER] instruction include:\n\n1. Processor State Requirements:\n- Must be in protected mode or IA-32e mode with CPL = 0\n- Processor cache must be available\n- Must be the bootstrap processor (BSP)\n- Cannot be in SMM or VMX operation\n\n2. Authentication Process:\n- Authenticates an Authenticated Code (AC) module\n- Verifies the module's cryptographic signature\n- Stores the module's hash in a trusted storage facility (TPM or FTM)\n\n3. Processor State Initialization:\n- Masks external events like SMI, INIT, A20M, and NMI\n- Disables paging\n- Clears performance counters and debug registers\n- Initializes segment registers and other processor state\n\n4. Multi-Processor Behavior:\n- Initiates a rendezvous sequence for all logical processors\n- Other logical processors enter a SENTER sleep state\n- Can only be awakened by a subsequent GETSEC[WAKEUP] instruction\n\nThe instruction provides a hardware-based mechanism for establishing a measured and authenticated execution environment with strict security controls.\n",
    "Alias": []
  },
  {
    "Name": "GETSEC[SEXIT]",
    "Brief": "Exit measured environment",
    "Description": "\nThe GETSEC[SEXIT] instruction initiates an exit of a measured environment established by GETSEC[SENTER]. This instruction leaf sends a message to all logical processors in the platform to signal the measured environment exit.\n\nThere are strict restrictions for executing this instruction:\n- Must be in protected mode (CR0.PE = 1) with CPL = 0 and EFLAGS.VM = 0\n- Processor must be in a measured environment launched by a previous GETSEC[SENTER] instruction\n- Cannot be in SMM or VMX operation\n- Must be executed by the bootstrap processor (BSP)\n\nThe instruction performs the following key actions:\n- Initiates a rendezvous of remote logical processors (RLPs) with the initial logical processor (ILP)\n- Clears the internal processor flag indicating operation in a measured environment\n- Unmsaks external event signals like INIT#, A20M, NMI#, and SMI#\n- Re-locks the Intel TXT-capable chipset private configuration space\n\nWhen executed, RLPs will restart execution from their previous state, with special handling for different processor states like HLT, MWAIT, or string instructions. If an RLP was in the SENTER sleep state, it will be sent to the wait-for-SIPI state.\n\nOn successful completion, execution proceeds to the next instruction, with pending trap conditions allowed to be signaled if previously enabled.\n",
    "Alias": []
  },
  {
    "Name": "GETSEC[SMCTRL]",
    "Brief": "SMX Mode Control instruction to re-enable SMI events",
    "Description": "\nThe GETSEC[SMCTRL] instruction is available for performing certain SMX specific mode control operations. The operation to be performed is selected through the input register EBX. Currently only an input value in EBX of 0 is supported. All other EBX settings will result in the signaling of a general protection violation.\n\nIf EBX is set to 0, then the SMCTRL leaf is used to re-enable SMI events. SMI is masked by the ILP executing the GETSEC[SENTER] instruction (SMI is also masked in the responding logical processors in response to SENTER rendezvous messages.).\n\nAs part of support for launching a measured environment, the SMI, NMI, and INIT events are masked after GETSEC[SENTER], and remain masked after exiting authenticated execution mode. Unmasking these events should be accompanied by securely enabling these event handlers.\n\nThe VM monitor can choose two approaches:\n1. Set up an SMM monitor in parallel to the executive VMM to handle SMI events without compromising security.\n2. Use GETSEC[SMCTRL(0)] to re-enable SMI within the measured environment if no dedicated SMM monitor is established.\n\nThe ability to use GETSEC[SMCTRL(0)] depends on the specific processor context, including whether the processor is in VMX operation, SMM, or authenticated code execution mode.\n",
    "Alias": []
  },
  {
    "Name": "GETSEC[WAKEUP]",
    "Brief": "Wake up sleeping processors in a measured environment",
    "Description": "\nThe GETSEC[WAKEUP] leaf function broadcasts a wake-up message to all logical processors currently in the SENTER sleep state. This GETSEC leaf must be executed only by the Initial Logical Processor (ILP), in order to wake up the Responding Logical Processors (RLPs).\n\nThe GETSEC[WAKEUP] instruction may only be executed:\n- In a measured environment as initiated by execution of GETSEC[SENTER]\n- Outside of authenticated code execution mode\n- In protected mode with CPL = 0 and EFLAGS.VM = 0\n- By the boot-strap processor (IA32_APIC_BASE.BSP = 1)\n\nIf these conditions are not met, attempts to execute GETSEC[WAKEUP] result in a general protection violation.\n\nWhen an RLP exits the SENTER sleep state, it retrieves a pointer to a data structure containing information to enable execution from a defined entry point. This data structure is located using a physical address in the Intel TXT-capable chipset configuration register LT.MLE.JOIN.\n\nThe MLE JOIN data structure contains information to initialize RLP processor state and permit the processor to join the measured environment, including GDTR, LIP, and CS, DS, SS, and ES selector values.\n",
    "Alias": []
  },
  {
    "Name": "INVEPT",
    "Brief": "Invalidate Translations Derived from EPT",
    "Description": "\nInvalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches that were derived from extended page tables (EPT). Invalidation is based on the INVEPT type specified in the register operand and the INVEPT descriptor specified in the memory operand.\n\nOutside IA-32e mode, the register operand is always 32 bits, regardless of the value of CS.D; in 64-bit mode, the register operand has 64 bits (the instruction cannot be executed in compatibility mode).\n\nThere are two INVEPT types currently defined:\n\n1. Single-context invalidation (Type 1): The logical processor invalidates all mappings associated with bits 51:12 of the EPT pointer (EPTP) specified in the INVEPT descriptor. It may invalidate other mappings as well.\n\n2. Global invalidation (Type 2): The logical processor invalidates mappings associated with all EPTPs.\n\nIf an unsupported INVEPT type is specified, the instruction fails. INVEPT invalidates all the specified mappings for the indicated EPTP(s) regardless of the VPID and PCID values with which those mappings may be associated.\n\nThe INVEPT descriptor comprises 128 bits and contains a 64-bit EPTP value in bits 63:0.\n",
    "Alias": []
  },
  {
    "Name": "INVVPID",
    "Brief": "Invalidate Translations Based on Virtual Processor Identifier (VPID)",
    "Description": "\nInvalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on virtual processor identifier (VPID). Invalidation is based on the INVVPID type specified in the register operand and the INVVPID descriptor specified in the memory operand.\n\nOutside IA-32e mode, the register operand is always 32 bits; in 64-bit mode, the register operand has 64 bits (the instruction cannot be executed in compatibility mode).\n\nFour INVVPID types are currently defined:\n\n1. Individual-address invalidation (Type 0): Invalidates mappings for a specific linear address and VPID.\n\n2. Single-context invalidation (Type 1): Invalidates all mappings tagged with a specific VPID.\n\n3. All-contexts invalidation (Type 2): Invalidates all mappings tagged with all VPIDs except VPID 0000H.\n\n4. Single-context invalidation, retaining global translations (Type 3): Invalidates all mappings tagged with a specific VPID except global translations.\n\nIf an unsupported INVVPID type is specified, the instruction fails. INVVPID invalidates all specified mappings for the indicated VPID(s) regardless of the EPTP and PCID values.\n\nThe INVVPID descriptor is 128 bits, consisting of a VPID and a linear address.\n",
    "Alias": []
  },
  {
    "Name": "VMCALL",
    "Brief": "Call to VM monitor by causing VM exit",
    "Description": "\nThis instruction allows guest software to make a call for service into an underlying VM monitor. The details of the programming interface for such calls are VMM-specific; this instruction does nothing more than cause a VM exit, registering the appropriate exit reason.\n\nUse of this instruction in VMX root operation invokes an SMM monitor. This invocation will activate the dual-monitor treatment of system-management interrupts (SMIs) and system-management mode (SMM) if it is not already active.\n\nThe instruction can only be executed under specific conditions:\n- Must be in VMX operation\n- Must be in VMX non-root operation or in VMX root operation\n- Must be executed at privilege level 0\n- Cannot be executed in certain processor states (e.g., real mode, certain compatibility mode conditions)\n\nIf the conditions are not met, the instruction will generate an exception or VM exit with an appropriate error condition.\n",
    "Alias": []
  },
  {
    "Name": "VMCLEAR",
    "Brief": "Clear Virtual-Machine Control Structure",
    "Description": "\nThis instruction applies to the VMCS (Virtual Machine Control Structure) whose VMCS region resides at the physical address contained in the instruction operand. The instruction ensures that VMCS data for that VMCS (some of these data may be currently maintained on the processor) are copied to the VMCS region in memory. It also initializes parts of the VMCS region (for example, it sets the launch state of that VMCS to clear).\n\nThe operand of this instruction is always 64 bits and is always in memory. If the operand is the current-VMCS pointer, then that pointer is made invalid (set to FFFFFFFF_FFFFFFFFH).\n\nNote that the VMCLEAR instruction might not explicitly write any VMCS data to memory; the data may be already resident in memory before the VMCLEAR is executed.\n\nThe instruction can only be executed in VMX operation, at privilege level 0, and with certain specific conditions met. If these conditions are not met, various exceptions can be raised.\n",
    "Alias": []
  },
  {
    "Name": "VMFUNC",
    "Brief": "Invoke VM function specified in EAX",
    "Description": "\nThis instruction allows software in VMX non-root operation to invoke a VM function, which is processor functionality enabled and configured by software in VMX root operation. The value of EAX selects the specific VM function being invoked.\n\nThe behavior of each VM function (including any additional fault checking) is specified in Section 26.5.6, \"VM Functions.\"\n\nThe instruction has the following key characteristics:\n- Can only be executed in VMX non-root operation\n- Requires \"enable VM functions\" VM-execution control to be set\n- EAX must be less than 64 to specify a valid VM function\n- The specific functionality depends on the VM function selected in EAX\n\nExceptions will be raised if:\n- Executed outside VMX non-root operation\n- \"enable VM functions\" VM-execution control is 0\n- EAX is greater than or equal to 64\n",
    "Alias": []
  },
  {
    "Name": "VMLAUNCH",
    "Brief": "Launch virtual machine managed by current VMCS",
    "Description": "\nEffects a VM entry managed by the current VMCS.\n\n- VMLAUNCH fails if the launch state of current VMCS is not \"clear\". If the instruction is successful, it sets the launch state to \"launched.\"\n- VMRESUME fails if the launch state of the current VMCS is not \"launched.\"\n\nIf VM entry is attempted, the logical processor performs a series of consistency checks as detailed in Chapter 27, \"VM Entries.\" Failure to pass checks on the VMX controls or on the host-state area passes control to the instruction following the VMLAUNCH or VMRESUME instruction. If these pass but checks on the guest-state area fail, the logical processor loads state from the host-state area of the VMCS, passing control to the instruction referenced by the RIP field in the host-state area.\n\nVM entry is not allowed when events are blocked by MOV SS or POP SS. Neither VMLAUNCH nor VMRESUME should be used immediately after either MOV to SS or POP to SS.\n",
    "Alias": []
  },
  {
    "Name": "VMRESUME",
    "Brief": "Resume virtual machine managed by current VMCS",
    "Description": "\nEffects a VM entry managed by the current VMCS.\n\n- VMLAUNCH fails if the launch state of current VMCS is not \"clear\". If the instruction is successful, it sets the launch state to \"launched.\"\n- VMRESUME fails if the launch state of the current VMCS is not \"launched.\"\n\nIf VM entry is attempted, the logical processor performs a series of consistency checks as detailed in Chapter 27, \"VM Entries.\" Failure to pass checks on the VMX controls or on the host-state area passes control to the instruction following the VMLAUNCH or VMRESUME instruction. If these pass but checks on the guest-state area fail, the logical processor loads state from the host-state area of the VMCS, passing control to the instruction referenced by the RIP field in the host-state area.\n\nVM entry is not allowed when events are blocked by MOV SS or POP SS. Neither VMLAUNCH nor VMRESUME should be used immediately after either MOV to SS or POP to SS.\n",
    "Alias": []
  },
  {
    "Name": "VMPTRLD",
    "Brief": "Load Pointer to Virtual-Machine Control Structure",
    "Description": "\nMarks the current-VMCS pointer valid and loads it with the physical address in the instruction operand. The instruction fails if its operand is not properly aligned, sets unsupported physical-address bits, or is equal to the VMXON pointer. In addition, the instruction fails if the 32 bits in memory referenced by the operand do not match the VMCS revision identifier supported by this processor.\n\nThe operand of this instruction is always 64 bits and is always in memory. The instruction can only be executed in VMX operation and at privilege level 0. It will cause an #UD (Undefined Opcode) exception if attempted in other modes or privilege levels.\n\nKey failure conditions include:\n- Operand not 4KB-aligned\n- Operand sets unsupported physical-address bits\n- Operand is the same as the VMXON pointer\n- 32-bit revision identifier does not match the processor's supported VMCS revision\n\nWhen successful, the instruction loads the current VMCS pointer with the specified physical address.\n",
    "Alias": []
  },
  {
    "Name": "VMPTRST",
    "Brief": "Store Pointer to Virtual-Machine Control Structure",
    "Description": "\nStores the current-VMCS pointer into a specified memory address. The operand of this instruction is always 64 bits and is always in memory.\n\nThe instruction can only be executed in VMX operation at privilege level 0. If the instruction is executed in any other mode or privilege level, it will generate an appropriate exception:\n- In real-address mode, virtual-8086 mode, or compatibility mode, it will generate an #UD (Undefined Opcode) exception\n- If not at privilege level 0, it will generate a #GP (General Protection) exception\n- If not in VMX operation, it will generate an #UD exception\n\nWhen executed successfully, the current VMCS (Virtual Machine Control Structure) pointer is stored into the specified 64-bit memory location.\n",
    "Alias": []
  },
  {
    "Name": "VMREAD",
    "Brief": "Read Field from Virtual-Machine Control Structure",
    "Description": "\nReads a specified field from a VMCS and stores it into a specified destination operand (register or memory). In VMX root operation, the instruction reads from the current VMCS. If executed in VMX non-root operation, the instruction reads from the VMCS referenced by the VMCS link pointer field in the current VMCS.\n\nThe VMCS field is specified by the VMCS-field encoding contained in the register source operand. Outside IA-32e mode, the source operand has 32 bits, regardless of the value of CS.D. In 64-bit mode, the source operand has 64 bits.\n\nThe effective size of the destination operand, which may be a register or in memory, is always 32 bits outside IA-32e mode (the setting of CS.D is ignored with respect to operand size) and 64 bits in 64-bit mode. If the VMCS field specified by the source operand is shorter than this effective operand size, the high bits of the destination operand are cleared to 0. If the VMCS field is longer, then the high bits of the field are not read.\n\nNote that any faults resulting from accessing a memory destination operand can occur only after determining that the relevant VMCS pointer is valid and that the specified VMCS field is supported.\n",
    "Alias": []
  },
  {
    "Name": "VMWRITE",
    "Brief": "Write Field to Virtual-Machine Control Structure",
    "Description": "\nWrites the contents of a primary source operand (register or memory) to a specified field in a VMCS. In VMX root operation, the instruction writes to the current VMCS. If executed in VMX non-root operation, the instruction writes to the VMCS referenced by the VMCS link pointer field in the current VMCS.\n\nThe VMCS field is specified by the VMCS-field encoding contained in the register secondary source operand. Outside IA-32e mode, the secondary source operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode, the secondary source operand has 64 bits.\n\nThe effective size of the primary source operand, which may be a register or in memory, is always 32 bits outside IA-32e mode (the setting of CS.D is ignored with respect to operand size) and 64 bits in 64-bit mode. If the VMCS field specified by the secondary source operand is shorter than this effective operand size, the high bits of the primary source operand are ignored. If the VMCS field is longer, then the high bits of the field are cleared to 0.\n\nNote that any faults resulting from accessing a memory source operand occur after determining that the relevant VMCS pointer is valid but before determining if the destination VMCS field is supported.\n",
    "Alias": []
  },
  {
    "Name": "VMXOFF",
    "Brief": "Leave VMX Operation",
    "Description": "\nTakes the logical processor out of VMX operation, unblocks INIT signals, conditionally re-enables A20M, and clears any address-range monitoring.\n\nKey operational details:\n- Cannot be executed outside VMX operation\n- Cannot be executed with CPL > 0 in VMX root operation\n- If in VMX non-root operation, triggers a VMexit\n- Unblocks INIT signals\n- Conditionally unblocks SMIs based on IA32_SMM_MONITOR_CTL register\n- Clears address-range monitoring\n- May re-enable A20M if outside SMX operation\n\nExceptions:\n- #UD (Undefined Opcode) if executed:\n  * Outside VMX operation\n  * In real-address mode\n  * In virtual-8086 mode\n  * In compatibility mode\n- #GP(0) if executed in VMX root operation with CPL > 0\n",
    "Alias": []
  },
  {
    "Name": "VMXON",
    "Brief": "Enter VMX Operation",
    "Description": "\nPuts the logical processor in VMX operation with no current VMCS, blocks INIT signals, disables A20M, and clears any address-range monitoring established by the MONITOR instruction.\n\nThe operand of this instruction is a 4KB-aligned physical address (the VMXON pointer) that references the VMXON region, which the logical processor may use to support VMX operation. This operand is always 64 bits and is always in memory.\n\nThe instruction performs several checks before entering VMX operation:\n- Verifies CR0, CR4, and RFLAGS settings\n- Checks IA32_FEATURE_CONTROL MSR\n- Ensures the VMXON pointer is correctly aligned\n- Validates the VMCS revision identifier\n\nIf all checks pass, the processor:\n- Enters VMX operation\n- Blocks INIT signals\n- Disables A20M\n- Clears address-range monitoring\n- Potentially disables Intel Processor Trace (PT)\n\nThe instruction can only be executed with sufficient privileges and specific processor conditions met.\n",
    "Alias": []
  },
  {
    "Name": "PREFETCHWT1",
    "Brief": "Prefetch Vector Data Into Caches With Intent to Write and T1 Hint",
    "Description": "\nFetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by an intent to write hint (so that data is brought into 'Exclusive' state via a request for ownership) and a locality hint:\n\n- T1 (temporal data with respect to first level cache)—prefetch data into the second level cache.\n\nThe source operand is a byte memory location. (The locality hints are encoded into the machine level instruction using bits 3 through 5 of the ModR/M byte. Use of any ModR/M value other than the specified ones will lead to unpredictable behavior.)\n\nIf the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\n\nThe PREFETCHWT1 instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor in anticipation of future use.\n\nThe implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes.\n\nIt should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A PREFETCHWT1 instruction is considered a hint to this speculative behavior.\n",
    "Alias": []
  },
  {
    "Name": "V4FMADDPS",
    "Brief": "Packed Single Precision Floating-Point Fused Multiply-Add (4-Iterations)",
    "Description": "\nThis instruction computes 4 sequential packed fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.\n\nThe notation of \"+3\" is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\n\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any of the 16 lowest significant mask bits is set to 1 or if a \"no masking\" encoding is used.\n\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.\n\nRounding is performed at every FMA (fused multiply and add) boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc.\n",
    "Alias": []
  },
  {
    "Name": "V4FNMADDPS",
    "Brief": "Packed Single Precision Floating-Point Fused Multiply-Negate-Add (4-Iterations)",
    "Description": "\nThis instruction computes 4 sequential packed fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.\n\nThe notation of \"+3\" is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\n\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any of the 16 lowest significant mask bits is set to 1 or if a \"no masking\" encoding is used.\n\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.\n\nRounding is performed at every FMA (fused multiply and add) boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc.\n",
    "Alias": []
  },
  {
    "Name": "V4FMADDSS",
    "Brief": "Scalar single-precision floating-point fused multiply-add (4-iterations)",
    "Description": "\nThis instruction computes 4 sequential scalar fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.\n\nThe notation of \"+3\" is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\n\nThe instruction supports memory fault suppression. The entire memory operand is loaded if the least significant mask bit is set to 1 or if a \"no masking\" encoding is used.\n\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.\n\nRounding is performed at every FMA boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc.\n\nV4FMADDSS performs a standard fused multiply-add operation, while V4FNMADDSS performs a fused multiply-add with negation.\n",
    "Alias": []
  },
  {
    "Name": "V4FNMADDSS",
    "Brief": "Scalar single-precision floating-point fused multiply-add with negation (4-iterations)",
    "Description": "\nThis instruction computes 4 sequential scalar fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.\n\nThe notation of \"+3\" is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\n\nThe instruction supports memory fault suppression. The entire memory operand is loaded if the least significant mask bit is set to 1 or if a \"no masking\" encoding is used.\n\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.\n\nRounding is performed at every FMA boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc.\n\nV4FMADDSS performs a standard fused multiply-add operation, while V4FNMADDSS performs a fused multiply-add with negation.\n",
    "Alias": []
  },
  {
    "Name": "VEXP2PD",
    "Brief": "Approximation to the Exponential 2^x of Packed Double Precision Floating-Point Values With Less Than 2^-23 Relative Error",
    "Description": "\nComputes the approximate base-2 exponential evaluation of the double precision floating-point values in the source operand (the second operand) and stores the results to the destination operand (the first operand) using the writemask k1. The approximate base-2 exponential is evaluated with less than 2^-23 of relative error.\n\nDenormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do not signal #UE, irrespective of MXCSR.FTZ.\n\nThe source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nSpecial values behavior includes:\n- NaN inputs produce QNaN (with #I exception for SNaN)\n- +∞ input produces +∞\n- +/-0 input produces 1.0f exactly\n- -∞ input produces +0.0f\n- Integral values N produce 2^N exactly\n",
    "Alias": []
  },
  {
    "Name": "VEXP2PS",
    "Brief": "Approximation to the exponential 2^x of packed single precision floating-point values with less than 2^-23 relative error",
    "Description": "\nComputes the approximate base-2 exponential evaluation of the single-precision floating-point values in the source operand (the second operand) and store the results in the destination operand (the first operand) using the write-mask k1. The approximate base-2 exponential is evaluated with less than 2^-23 of relative error.\n\nDenormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do not signal #UE, irrespective of MXCSR.FTZ.\n\nThe source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nSpecial value behaviors include:\n- NaN input returns QNaN (signals invalid exception for SNaN)\n- +∞ input returns +∞\n- +/-0 input returns 1.0f exactly\n- -∞ input returns +0.0f\n- Integral value N input returns 2^(N) exactly\n",
    "Alias": []
  },
  {
    "Name": "VGATHERPF0DPS",
    "Brief": "Sparse Prefetch Packed Single Precision Data Values with Signed Dword Indices Using T0 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nLines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):\n- T0 (temporal data)—prefetch data into the first level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nImportant notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VGATHERPF0QPS",
    "Brief": "Sparse Prefetch Packed Single Precision Data Values with Signed Qword Indices Using T0 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nLines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):\n- T0 (temporal data)—prefetch data into the first level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nImportant notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VGATHERPF0DPD",
    "Brief": "Sparse Prefetch Packed Double Precision Data Values with Signed Dword Indices Using T0 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nLines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):\n- T0 (temporal data)—prefetch data into the first level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nImportant notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VGATHERPF0QPD",
    "Brief": "Sparse Prefetch Packed Double Precision Data Values with Signed Qword Indices Using T0 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nLines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):\n- T0 (temporal data)—prefetch data into the first level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nImportant notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VGATHERPF1DPS",
    "Brief": "Sparse Prefetch Packed Single Precision Data Values with Signed Dword Indices using T1 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nLines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):\n- T1 (temporal data)—prefetch data into the second level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nKey characteristics:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VGATHERPF1QPS",
    "Brief": "Sparse Prefetch Packed Single Precision Data Values with Signed Qword Indices using T1 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nLines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):\n- T1 (temporal data)—prefetch data into the second level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nKey characteristics:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VGATHERPF1DPD",
    "Brief": "Sparse Prefetch Packed Double Precision Data Values with Signed Dword Indices using T1 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nLines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):\n- T1 (temporal data)—prefetch data into the second level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nKey characteristics:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VGATHERPF1QPD",
    "Brief": "Sparse Prefetch Packed Double Precision Data Values with Signed Qword Indices using T1 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nLines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):\n- T1 (temporal data)—prefetch data into the second level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nKey characteristics:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VP4DPWSSD",
    "Brief": "Dot Product of Signed Words With Dword Accumulation (4-Iterations)",
    "Description": "\nThis instruction computes 4 sequential register source-block dot-products of two signed word operands with doubleword accumulation.\n\nThe instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest 16-bits of the mask is set to 1 or if a \"no masking\" encoding is used.\n\nThe notation of \"+3\" is used to denote that the instruction accesses 4 source registers based on the operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\n\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.\n\nThe instruction performs a dot product by multiplying signed words from the source register block by signed words from the memory operand and accumulating the resulting signed dwords.\n\nThe diagram illustrates the register source-block dot product of two signed word operands with doubleword accumulation, showing how the computation is performed across multiple registers and memory elements.\n",
    "Alias": []
  },
  {
    "Name": "VP4DPWSSDS",
    "Brief": "Dot Product of Signed Words With Dword Accumulation and Saturation (4-Iterations)",
    "Description": "\nThis instruction computes 4 sequential register source-block dot-products of two signed word operands with doubleword accumulation and signed saturation. The memory operand is sequentially selected in each of the four steps.\n\nThe notation of \"+3\" is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\n\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest 16-bits of the mask is set to 1 or if a \"no masking\" encoding is used.\n\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.\n\nThe instruction multiplies signed words from the source register block by signed words from memory, accumulates the resulting dword results with signed saturation.\n",
    "Alias": []
  },
  {
    "Name": "VRCP28PD",
    "Brief": "Computes the approximate reciprocals of packed double precision floating-point values with less than 2^-28 relative error",
    "Description": "\nComputes the reciprocal approximation of the float64 values in the source operand and store the results to the destination operand. The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error.\n\nDenormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do not signal #UE, irrespective of MXCSR.FTZ.\n\nIf any source element is NaN, the quietized NaN source value is returned for that element. If any source element is ±∞, ±0.0 is returned for that element. Also, if any source element is ±0.0, ±∞ is returned for that element.\n\nThe source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nSpecial cases include handling of NaN, denormal, zero, and infinity inputs with specific return values as detailed in the special cases table.\n",
    "Alias": []
  },
  {
    "Name": "VRCP28PS",
    "Brief": "Computes the approximate reciprocals of packed single-precision floating-point values with less than 2^-28 relative error",
    "Description": "\nComputes the reciprocal approximation of the float32 values in the source operand and store the results to the destination operand using the writemask k1. The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final results are rounded to < 2^-23 relative error before written to the destination.\n\nDenormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do not signal #UE, irrespective of MXCSR.FTZ.\n\nIf any source element is NaN, the quietized NaN source value is returned for that element. If any source element is ±∞, ±0.0 is returned for that element. Also, if any source element is ±0.0, ±∞ is returned for that element.\n\nThe source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VRCP28SD",
    "Brief": "Approximation to the reciprocal of scalar double precision floating-point value with less than 2^-28 relative error",
    "Description": "\nComputes the reciprocal approximation of the low float64 value in the second source operand and store the result to the destination operand. The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error. The result is written into the low float64 element of the destination operand according to the writemask k1. Bits 127:64 of the destination is copied from the corresponding bits of the first source operand.\n\nA denormal input value is treated as zero and does not signal #DE, irrespective of MXCSR.DAZ. A denormal result is flushed to zero and does not signal #UE, irrespective of MXCSR.FTZ.\n\nIf any source element is NaN, the quietized NaN source value is returned for that element. If any source element is ±∞, ±0.0 is returned for that element. Also, if any source element is ±0.0, ±∞ is returned for that element.\n\nThe first source operand is an XMM register. The second source operand is an XMM register or a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VRCP28SS",
    "Brief": "Computes the approximate reciprocal of a scalar single-precision floating-point value with less than 2^-28 relative error",
    "Description": "\nComputes the reciprocal approximation of the low float32 value in the second source operand and store the result to the destination operand. The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final result is rounded to < 2^-23 relative error before written into the low float32 element of the destination according to writemask k1. Bits 127:32 of the destination is copied from the corresponding bits of the first source operand.\n\nA denormal input value is treated as zero and does not signal #DE, irrespective of MXCSR.DAZ. A denormal result is flushed to zero and does not signal #UE, irrespective of MXCSR.FTZ.\n\nIf any source element is NaN, the quietized NaN source value is returned for that element. If any source element is ±∞, ±0.0 is returned for that element. Also, if any source element is ±0.0, ±∞ is returned for that element.\n\nThe first source operand is an XMM register. The second source operand is an XMM register or a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.\n",
    "Alias": []
  },
  {
    "Name": "VRSQRT28PD",
    "Brief": "Approximation to the Reciprocal Square Root of Packed Double Precision Floating-Point Values With Less Than 2^-28 Relative Error",
    "Description": "\nComputes the reciprocal square root of the float64 values in the source operand (the second operand) and store the results to the destination operand (the first operand). The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error.\n\nIf any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero) source numbers, as well as -∞, return the canonical NaN and set the Invalid Flag (#I).\n\nA value of -0 must return -∞ and set the DivByZero flags (#Z). Negative numbers should return NaN and set the Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative denormals return -∞ and set the DivByZero flag.\n\nThe source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nSpecial cases include:\n- NaN inputs return QNAN\n- Negative inputs return QNaN\n- -0 or negative denormals return -∞\n- +0 or positive denormals return +∞\n- +∞ returns +0\n",
    "Alias": []
  },
  {
    "Name": "VRSQRT28PS",
    "Brief": "Compute approximation to the reciprocal square root of packed single precision floating-point values with less than 2^-28 relative error",
    "Description": "\nComputes the reciprocal square root of the float32 values in the source operand (the second operand) and store the results to the destination operand (the first operand). The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final results is rounded to < 2^-23 relative error before written to the destination.\n\nIf any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero) source numbers, as well as -∞, return the canonical NaN and set the Invalid Flag (#I).\n\nA value of -0 must return -∞ and set the DivByZero flags (#Z). Negative numbers should return NaN and set the Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative denormals return -∞ and set the DivByZero flag.\n\nThe source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\n\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n",
    "Alias": []
  },
  {
    "Name": "VRSQRT28SD",
    "Brief": "Compute approximate reciprocal square root of scalar double precision floating-point value with less than 2^-28 relative error",
    "Description": "\nComputes the reciprocal square root of the low float64 value in the second source operand and store the result to the destination operand. The approximate reciprocal square root is evaluated with less than 2^-28 of maximum relative error.\n\nThe result is written into the low float64 element of xmm1 according to the writemask k1. Bits 127:64 of the destination is copied from the corresponding bits of the first source operand.\n\nSpecial handling for various input values:\n- If input is NaN, returns quietized NaN source value\n- Negative (non-zero) source numbers and -∞ return canonical NaN and set Invalid Flag (#I)\n- -0 returns -∞ and sets DivByZero flags (#Z)\n- Negative denormals return -∞ and set DivByZero flag\n- Positive 0 or denormals return +∞ and set DivByZero flag\n- +∞ returns +0\n\nThe first source operand is an XMM register, the second source operand is an XMM register or 64-bit memory location, and the destination operand is an XMM register.\n",
    "Alias": []
  },
  {
    "Name": "VRSQRT28SS",
    "Brief": "Approximation to the Reciprocal Square Root of Scalar Single Precision Floating-Point Value With Less Than 2^-28 Relative Error",
    "Description": "\nComputes the reciprocal square root of the low float32 value in the second source operand and store the result to the destination operand. The approximate reciprocal square root is evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final result is rounded to < 2^-23 relative error before written to the low float32 element of the destination according to the writemask k1. Bits 127:32 of the destination is copied from the corresponding bits of the first source operand.\n\nIf any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero) source numbers, as well as -∞, return the canonical NaN and set the Invalid Flag (#I).\n\nA value of -0 must return -∞ and set the DivByZero flags (#Z). Negative numbers should return NaN and set the Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative denormals return -∞ and set the DivByZero flag.\n\nThe first source operand is an XMM register. The second source operand is an XMM register or a 32-bit memory location. The destination operand is a XMM register.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERPF0DPS",
    "Brief": "Sparse Prefetch Packed Single Precision Data with Signed Dword Indices Using T0 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nCache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):\n- T0 (temporal data)—prefetch data into the first level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nKey notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERPF0QPS",
    "Brief": "Sparse Prefetch Packed Single Precision Data with Signed Qword Indices Using T0 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nCache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):\n- T0 (temporal data)—prefetch data into the first level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nKey notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERPF0DPD",
    "Brief": "Sparse Prefetch Packed Double Precision Data with Signed Dword Indices Using T0 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nCache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):\n- T0 (temporal data)—prefetch data into the first level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nKey notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERPF0QPD",
    "Brief": "Sparse Prefetch Packed Double Precision Data with Signed Qword Indices Using T0 Hint",
    "Description": "\nThe instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nCache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):\n- T0 (temporal data)—prefetch data into the first level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nKey notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERPF1DPS",
    "Brief": "Sparse Prefetch Packed Single Precision Data with Signed Dword Indices",
    "Description": "\nThe instructions conditionally prefetch up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nCache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):\n- T1 (temporal data)—prefetch data into the second level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nImportant notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERPF1QPS",
    "Brief": "Sparse Prefetch Packed Single Precision Data with Signed Qword Indices",
    "Description": "\nThe instructions conditionally prefetch up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nCache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):\n- T1 (temporal data)—prefetch data into the second level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nImportant notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERPF1DPD",
    "Brief": "Sparse Prefetch Packed Double Precision Data with Signed Dword Indices",
    "Description": "\nThe instructions conditionally prefetch up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nCache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):\n- T1 (temporal data)—prefetch data into the second level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nImportant notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  },
  {
    "Name": "VSCATTERPF1QPD",
    "Brief": "Sparse Prefetch Packed Double Precision Data with Signed Qword Indices",
    "Description": "\nThe instructions conditionally prefetch up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.\n\nCache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):\n- T1 (temporal data)—prefetch data into the second level cache.\n\n[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruction will prefetch eight values.\n\n[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.\n\nImportant notes:\n(1) The prefetches may happen in any order (or not at all). The instruction is a hint.\n(2) The mask is left unchanged.\n(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.\n(4) No FP nor memory faults may be produced by this instruction.\n(5) Prefetches do not handle cache line splits\n(6) A #UD is signaled if the memory operand is encoded without the SIB byte.\n",
    "Alias": []
  }
]